{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Experiments with Agda support for Scott\u2013Strachey denotational semantics</p>"},{"location":"#examples","title":"Examples","text":"<p>Complete examples of denotational semantics definitions in Agda:</p> <ul> <li>Lambda-calculus</li> <li>PCF</li> <li>Scm</li> </ul>"},{"location":"#domains-in-denotational-semantics","title":"Domains in Denotational Semantics","text":"<p>In the Scott\u2013Strachey style of denotational semantics:</p> <ul> <li>types of denotations are (Scott-)domains;</li> <li>domains are cpos with least elements, and can be defined recursively;</li> <li>denotations are defined in \u03bb-notation, and functions are continuous;</li> <li>the isomorphisms between domains and their definitions are left implicit.</li> </ul>"},{"location":"#domains-in-agda","title":"Domains in Agda","text":"<p>In Agda, the DomainTheory modules from the TypeTopology library provide well-developed support for domains.</p> <ul> <li> <p>Domains <code>D</code> are tuples <code>(\u27eaD\u27eb, \u22a5, _\u2291_, axioms)</code> where:</p> </li> <li> <p><code>\u27eaD\u27eb</code> is a type of elements,</p> </li> <li><code>\u22a5</code> is a distinguished element of <code>\u27eaD\u27eb</code>,</li> <li><code>_\u2291_</code> is a partial order on <code>\u27eaD\u27eb</code>, and</li> <li> <p><code>axioms</code> prove that <code>(\u27eaD\u27eb, _\u2291_)</code> is a directed-complete poset (dcpo)     with <code>\u22a5</code> least.</p> </li> <li> <p>Continuous functions <code>c</code> from domain <code>D</code> to domain <code>E</code>  are pairs   <code>(f, axioms)</code> where:</p> </li> <li> <p><code>f</code> is an underlying function from <code>\u27eaD\u27eb</code> to <code>\u27eaE\u27eb</code>, and</p> </li> <li> <p><code>axioms</code> prove that <code>f</code> preserves limits of directed sets.</p> </li> <li> <p>Domains are defined recursively as bilimits of diagrams.</p> </li> <li> <p>Elements of domains are defined in \u03bb-notation, where:</p> </li> <li> <p>\u03bb-abstractions need to be paired with continuity proofs,</p> </li> <li>applications need to select the underlying functions, and</li> <li>the isomorphisms between domains and their definitions are explicit.</li> </ul> <p>Such requirements give significant pragmatic issues: explicit continuity   proofs are generally tedious to formulate (and subsequently read); and the   notation for pairing and selection prevents direct embedding in Agda of   \u03bb-notation from denotational definitions.</p>"},{"location":"#extending-agda-with-scott-domains","title":"Extending Agda with Scott-Domains","text":"<p>The purpose of this repository is to experiment with extending Agda to allow denotational semantics to be defined more straightforwardly.</p> <p>The current examples presented here illustrate how denotational semantics can be defined in Agda. However, they use postulates to allow Agda to type-check the definitions, and some of the postulates are inconsistent with the underlying Agda logic. This does not affect type-checking, but could lead to unsound equivalence proofs.</p>"},{"location":"#adding-a-universe-of-domains","title":"Adding a Universe of Domains","text":"<p>One idea is to distinguish between declarations of types that correspond to domains and declarations of ordinary types \u2013 e.g., by introducing a universe (hierarchy) for domains.</p> <p>A domain type would implicitly be a cpo, with built-in notation for its partial order and least element. A type that corresponds to the domain of continuous  functions from a domain to itself would also have a least fixed-point function.</p>"},{"location":"#implementing-synthetic-domain-theory","title":"Implementing Synthetic Domain Theory","text":"<p>An implementation of Synthetic Domain Theory (SDT) in Agda would address the pragmatic issues with using the DomainTheory modules from the TypeTopology library.</p> <p>From the abstract of Formalizing Synthetic Domain Theory by Bernhard Reus (J. Automated Reasoning, 1999):</p> <p>Synthetic Domain Theory (SDT) is a constructive variant of Domain Theory where all functions are continuous following Dana Scott\u2019s idea of \u201cdomains as sets\u201d.</p> <p>In this article a logical and axiomatic version of SDT capturing the essence of Domain Theory \u00e0 la Scott is presented. It is based on a sufficiently expressive version of constructive type theory and fully implemented in the proof checker Lego.</p> <p>It appears that the implementation uses impredicativity and proof-irrelevance, which may prevent migration to Agda.</p> <p>From the abstract of Computational adequacy for recursive types in models of intuitionistic set theory by Alex Simpson (Ann. Pure and Applied Logic, 2004):</p> <p>This paper provides a unifying axiomatic account of the interpretation of recursive types that incorporates both domain-theoretic and realizability models as concrete instances. Our approach is to view such models as full subcategories of categorical models of intuitionistic set theory. </p> <p>From \u00a73:</p> <p>Although in this paper we use models of IZF set theory to achieve algebraic compactness, many other set theories and type theories appear rich enough to carry out the proofs in this paper. ... In fact, it seems likely that, with appropriate reformulations, the development of this paper could be carried out in the (predicative) context of Martin-L\u00f6f\u2019s Type Theory.</p> <p>It remains to be seen whether the development can be implemented in Agda...</p>"},{"location":"#discussion","title":"Discussion","text":"<p>Advice and suggestions are welcome, e.g., by posting to the repo Discussions.</p> <p>Peter Mosses p.d.mosses@tudelft.nl</p>"},{"location":"LC/","title":"Lambda-Calculus","text":"<p>The Agda code of a lightweight formalization of the denotational semantics of the untyped lambda-calculus is available on GitHub.</p> <p>The following highlighted listings of the code were generated using Agda.</p> <ul> <li> <p>Modules: hyperlinked web pages of the formalization</p> </li> <li> <p>Library: hyperlinked web pages of imported standard Agda library modules</p> </li> <li> <p>HTML: the hyperlinked HTML pages generated by Agda</p> </li> <li> <p>PDF: a PDF listing of the formalization</p> </li> </ul>"},{"location":"PCF/","title":"PCF (Plotkin 1977)","text":"<p>PCF is a call-by-name simply-typed \u03bb-calculus equipped with one or two base types (usually natural numbers and Booleans) and a fixed point combinator. In essence, PCF is the simplest lazy, purely functional programming language. (PLS Lab)</p> <p>The Agda code of a lightweight formalization of the denotational semantics of PCF is available on GitHub.</p> <p>The following highlighted listings of the code were generated using Agda.</p> <ul> <li> <p>Modules: hyperlinked web pages of the formalization</p> </li> <li> <p>Library: hyperlinked web pages of imported standard Agda library modules</p> </li> <li> <p>HTML: the hyperlinked HTML pages generated by Agda</p> </li> <li> <p>PDF: a PDF listing of the formalization</p> </li> </ul>"},{"location":"PCF/#variants-of-pcf","title":"Variants of PCF","text":"<p>PCF and its denotational semantics were orginally defined by Dana Scott in 1969 (Scott 1993) including combinators (<code>S</code>, <code>K</code>) instead of \u03bb-abstraction. Gordon Plotkin subsequently defined a denotational semantics for PCF including  \u03bb-abstraction (Plotkin 1977).</p> <p>Many authors have defined denotational semantics for PCF (PLS Lab). Recently, Tom de Jong has given a definition in Agda (DomainTheory.ScottModelOfPCF) based on the DomainTheory modules from the TypeTopology library. The syntax follows (Scott 1993) by including combinators instead of \u03bb-abstraction.</p> <p>De Jong's semantics of PCF was extended to PCF with variables and \u03bb-abstraction by Brendan Hart in a final year project supervised by Mart\u00edn Escard\u00f3 and De Jong (Hart 2020).<sup>1</sup> Hart used De Bruin indices for variables.</p> <p>The definitions of the denotations of PCF terms given by De Jong and Hart illustrate the notational overhead that arises in Agda when using the DomainTheory modules, compared to the definitions given by Scott and Plotkin.</p> <ol> <li> <p>Both De Jong and Hart deviate slightly from Scott's original semantics of the predecessor function by defining it to return zero when applied to zero, instead of being undefined.\u00a0\u21a9</p> </li> </ol>"},{"location":"Scm/","title":"A Sublanguage of Scheme","text":"<p>Scm is a particularly basic sublanguage of the core Scheme expressions whose denotational semantics is defined in the Scheme reports.</p> <p>A denotational semantics for Scm is defined in the following paper:</p> <p>Peter D. Mosses. 2025. A Compositional Semantics for <code>eval</code> in Scheme. In Proceedings of the Workshop Dedicated to Olivier Danvy on the Occasion of His 64th Birthday (OLIVIERFEST \u201925), October 12\u201318, 2025, Singapore, Singapore. ACM, New York, NY, USA, 10 pages. DOI</p> <p>The Agda code of a lightweight formalization of the denotational semantics of Scm is available on GitHub.</p> <p>The following highlighted listings of the code were generated using Agda.</p> <ul> <li> <p>Modules: hyperlinked web pages of the formalization</p> </li> <li> <p>Library: hyperlinked web pages of imported standard Agda library modules</p> </li> <li> <p>HTML: the hyperlinked HTML pages generated by Agda</p> </li> <li> <p>PDF: a PDF listing of the formalization</p> </li> </ul>"},{"location":"meta-notation/","title":"Meta-notation","text":"<p>The current examples of denotational semantics given here (untyped lambda-calculus, PCF, and a simple sublanguage Scm of Scheme) use a lightweight shallow embedding of domain theory in Agda.</p> <p>For an introduction to the Agda language, see the Agda docs or the Agda Wikipedia page.</p>"},{"location":"meta-notation/#summary","title":"Summary","text":""},{"location":"meta-notation/#abstract-syntax","title":"Abstract Syntax","text":"<p>The context-free grammars conventionally used to specify abstract syntax in denotational semantics correspond to inductive datatype definitions in Agda, introduced by the keyword <code>data</code>.</p> <p>For mutually-recursive definitions, all the datatypes are declared before declaring their constructors.</p> <p>In Agda, constructors with multiple arguments are curried. Mixfix notation uses underscores to indicate argument positions. However:</p> <ul> <li>layout characters are not allowed in mixfix names;</li> <li>underscores need to be separated by name parts;</li> <li>the characters <code>.;{}()@\"</code> cannot be used at all; and</li> <li>the symbols <code>= | -&gt; \u2192 : ? \\ \u03bb \u2200 .. ...</code> and Agda keywords cannot be used as name parts.</li> </ul> <p>Unicode characters can be used to suggest the terminal symbols of the specified language, e.g., the blank character <code>\u2423</code> for a space, and so-called banana-brackets <code>\u2985 \u2986</code> for parentheses.</p> <p>Agda doesn't allow empty mixfix names: injections between (data)types need to be explicit.</p> <p>In Agda, a value is left unspecified by declaring it either as a postulate or as a module parameter.</p>"},{"location":"meta-notation/#domain-equations","title":"Domain Equations","text":"<p>A flat domain is defined by equating it to a lifted set, which is written <code>S +\u22a5</code> in Agda.</p> <p>Non-recursive groups of domains are defined by equating them to domain terms. The currently available domain constructors are:</p> <ul> <li><code>D \u2192 E</code>, the domain of functions from <code>D</code> to <code>E</code>;</li> <li><code>\ud835\udd43 D</code>, lifting <code>D</code> with a further <code>\u22a5</code>;</li> <li><code>D \u00d7 E</code>, Cartesian product;</li> <li><code>D + E</code>, separated sum;</li> <li><code>D \u22c6</code>, finite sequences.</li> </ul> <p>Most of the above constructors can also be used with predomains; and <code>P \u2192 D</code> is a domain also when <code>P</code> is a predomain.</p> <p>In conventional denotational semantics, (groups of mutually) recursive domains are defined, up to isomorphism, by domain equations. The isomorphisms between domains and their definitions are usually left implicit.</p> <p>In Agda, such isomorphisms need to be specified explicitly -- both when defining domains and when defining elements of domains in \u03bb-notation. See the lambda-calculus semantics for an example of this.</p> <p>When recursively-defined domains involve domain sums, however, the required isomorphisms can be subsumed by postulating projections and injections between domains and their summands. See the Scm semantics for an example.</p> <p>The PCF semantics does not involve recursively-defined domains.</p>"},{"location":"meta-notation/#semantic-functions","title":"Semantic Functions","text":"<p>Declarations and definitions of semantic functions that map abstract syntax to domains of denotations are defined straightforwardly in Agda, by specifying the same 'semantic equations' as in conventional denotational semantics. Mixfix notation (e.g., <code>\u2130\u27e6_\u27e7</code>) supports the use of double square brackets to separate abstract syntax from \u03bb-notation.</p> <p>Compositionality of denotational semantics ensures that the definitions of semantic functions are inductive (primitive recursive). Agda checks that the semantic equations cover all abstract syntax constructors, and warns about any overlapping equations.</p>"},{"location":"meta-notation/#auxiliary-functions","title":"Auxiliary Functions","text":"<p>Conventional denotational semantic definitions often define auxiliary functions for use when defining denotations in semantic equations. These look the same in Agda, except that recursive definitions generally need to be formulated using the fixed-point operator <code>fix</code> to satisfy the Agda termination check.</p> <p>Auxiliary functions need to be declared before they are first used, so their declarations should precede the definitions of semantic functions.</p>"},{"location":"meta-notation/#-notation","title":"\u03bb-Notation","text":"<p>In conventional denotational semantics, functions defined in \u03bb-notation between domains are always continuous. In Agda, it is possible to postulate that all functions are continuous. Some Agda functions (e.g., Boolean negation) clearly have no fixed points, so such postulates are inconsistent with the standard Agda library. However, fixed points of arbitrary functions are not needed when defining denotations in Agda, and it appears that such inconsistent postulates do not affect Agda's type-checker.</p> <p>Denotations can therefore be defined in Agda quite straightforwardly. Apart from the fixed-point operator <code>fix</code>, definitions in \u03bb-notation can also use the introduction and elimination operators associated with the various domain constructors.</p> <p>Regarding lexical structure, the conventional notation for \u03bb-abstractions <code>\u03bbx.y</code> is written <code>\u03bb x \u2192 y</code> in Agda, and adjacent bound variables need to be separated by spaces.</p>"},{"location":"meta-notation/#modules","title":"Modules","text":"<p>Currently, the examples of denotational definitions presented here are independent, and there is some duplication of declarations of notation for domains.</p> <p>In a future version, all the domain notation should be specified in a separate module, with submodules for the various domain constructors.</p>"},{"location":"Library/","title":"Library","text":"<p>Note</p> <p>The Agda library modules imported by non-library modules are automatically included in this section.</p>"},{"location":"md/Agda/Builtin/Bool/","title":"Agda.Builtin.Bool","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Bool where\n\ndata Bool : Set where\n  false true : Bool\n\n{-# BUILTIN BOOL  Bool  #-}\n{-# BUILTIN FALSE false #-}\n{-# BUILTIN TRUE  true  #-}\n\n{-# COMPILE JS Bool  = function (x,v) { return ((x)? v[\"true\"]() : v[\"false\"]()); } #-}\n{-# COMPILE JS false = false #-}\n{-# COMPILE JS true  = true  #-}\n</pre>"},{"location":"md/Agda/Builtin/Char/","title":"Agda.Builtin.Char","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Char where\n\nopen import Agda.Builtin.Nat\nopen import Agda.Builtin.Bool\n\npostulate Char : Set\n{-# BUILTIN CHAR Char #-}\n\nprimitive\n  primIsLower primIsDigit primIsAlpha primIsSpace primIsAscii\n    primIsLatin1 primIsPrint primIsHexDigit : Char \u2192 Bool\n  primToUpper primToLower : Char \u2192 Char\n  primCharToNat : Char \u2192 Nat\n  primNatToChar : Nat \u2192 Char\n  primCharEquality : Char \u2192 Char \u2192 Bool\n</pre>"},{"location":"md/Agda/Builtin/Equality/","title":"Agda.Builtin.Equality","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Equality where\n\ninfix 4 _\u2261_\ndata _\u2261_ {a} {A : Set a} (x : A) : A \u2192 Set a where\n  instance refl : x \u2261 x\n\n{-# BUILTIN EQUALITY _\u2261_ #-}\n</pre>"},{"location":"md/Agda/Builtin/Equality/Rewrite/","title":"Agda.Builtin.Equality.Rewrite","text":"<pre>{-# OPTIONS --cubical-compatible --rewriting --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Equality.Rewrite where\n\nopen import Agda.Builtin.Equality\n\n{-# BUILTIN REWRITE _\u2261_ #-}\n</pre>"},{"location":"md/Agda/Builtin/Int/","title":"Agda.Builtin.Int","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Int where\n\nopen import Agda.Builtin.Nat\nopen import Agda.Builtin.String\n\ninfix 8 pos  -- Standard library uses this as +_\n\ndata Int : Set where\n  pos    : (n : Nat) \u2192 Int\n  negsuc : (n : Nat) \u2192 Int\n\n{-# BUILTIN INTEGER       Int    #-}\n{-# BUILTIN INTEGERPOS    pos    #-}\n{-# BUILTIN INTEGERNEGSUC negsuc #-}\n\nprimitive primShowInteger : Int \u2192 String\n</pre>"},{"location":"md/Agda/Builtin/List/","title":"Agda.Builtin.List","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.List where\n\ninfixr 5 _\u2237_\ndata List {a} (A : Set a) : Set a where\n  []  : List A\n  _\u2237_ : (x : A) (xs : List A) \u2192 List A\n\n{-# BUILTIN LIST List #-}\n\n{-# COMPILE JS  List = function(x,v) {\n  if (x.length &lt; 1) { return v[\"[]\"](); } else { return v[\"_\u2237_\"](x[0], x.slice(1)); }\n} #-}\n{-# COMPILE JS [] = Array() #-}\n{-# COMPILE JS _\u2237_ = function (x) { return function(y) { return Array(x).concat(y); }; } #-}\n</pre>"},{"location":"md/Agda/Builtin/Maybe/","title":"Agda.Builtin.Maybe","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Maybe where\n\ndata Maybe {a} (A : Set a) : Set a where\n  just : A \u2192 Maybe A\n  nothing : Maybe A\n\n{-# BUILTIN MAYBE Maybe #-}\n</pre>"},{"location":"md/Agda/Builtin/Nat/","title":"Agda.Builtin.Nat","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Nat where\n\nopen import Agda.Builtin.Bool\n\ndata Nat : Set where\n  zero : Nat\n  suc  : (n : Nat) \u2192 Nat\n\n{-# BUILTIN NATURAL Nat #-}\n\ninfix  4 _==_ _&lt;_\ninfixl 6 _+_ _-_\ninfixl 7 _*_\n\n_+_ : Nat \u2192 Nat \u2192 Nat\nzero  + m = m\nsuc n + m = suc (n + m)\n\n{-# BUILTIN NATPLUS _+_ #-}\n\n_-_ : Nat \u2192 Nat \u2192 Nat\nn     - zero = n\nzero  - suc m = zero\nsuc n - suc m = n - m\n\n{-# BUILTIN NATMINUS _-_ #-}\n\n_*_ : Nat \u2192 Nat \u2192 Nat\nzero  * m = zero\nsuc n * m = m + n * m\n\n{-# BUILTIN NATTIMES _*_ #-}\n\n_==_ : Nat \u2192 Nat \u2192 Bool\nzero  == zero  = true\nsuc n == suc m = n == m\n_     == _     = false\n\n{-# BUILTIN NATEQUALS _==_ #-}\n\n_&lt;_ : Nat \u2192 Nat \u2192 Bool\n_     &lt; zero  = false\nzero  &lt; suc _ = true\nsuc n &lt; suc m = n &lt; m\n\n{-# BUILTIN NATLESS _&lt;_ #-}\n\n-- Helper function  div-helper  for Euclidean division.\n---------------------------------------------------------------------------\n--\n-- div-helper computes n / 1+m via iteration on n.\n--\n--   n div (suc m) = div-helper 0 m n m\n--\n-- The state of the iterator has two accumulator variables:\n--\n--   k: The quotient, returned once n=0.  Initialized to 0.\n--\n--   j: A counter, initialized to the divisor m, decreased on each iteration step.\n--      Once it reaches 0, the quotient k is increased and j reset to m,\n--      starting the next countdown.\n--\n-- Under the precondition j \u2264 m, the invariant is\n--\n--   div-helper k m n j = k + (n + m - j) div (1 + m)\n\ndiv-helper : (k m n j : Nat) \u2192 Nat\ndiv-helper k m  zero    j      = k\ndiv-helper k m (suc n)  zero   = div-helper (suc k) m n m\ndiv-helper k m (suc n) (suc j) = div-helper k       m n j\n\n{-# BUILTIN NATDIVSUCAUX div-helper #-}\n\n-- Proof of the invariant by induction on n.\n--\n--   clause 1: div-helper k m 0 j\n--           = k                                        by definition\n--           = k + (0 + m - j) div (1 + m)              since m - j &lt; 1 + m\n--\n--   clause 2: div-helper k m (1 + n) 0\n--           = div-helper (1 + k) m n m                 by definition\n--           = 1 + k + (n + m - m) div (1 + m)          by induction hypothesis\n--           = 1 + k +          n  div (1 + m)          by simplification\n--           = k +   (n + (1 + m)) div (1 + m)          by expansion\n--           = k + (1 + n + m - 0) div (1 + m)          by expansion\n--\n--   clause 3: div-helper k m (1 + n) (1 + j)\n--           = div-helper k m n j                       by definition\n--           = k + (n + m - j) div (1 + m)              by induction hypothesis\n--           = k + ((1 + n) + m - (1 + j)) div (1 + m)  by expansion\n--\n-- Q.e.d.\n\n-- Helper function  mod-helper  for the remainder computation.\n---------------------------------------------------------------------------\n--\n-- (Analogous to div-helper.)\n--\n-- mod-helper computes n % 1+m via iteration on n.\n--\n--   n mod (suc m) = mod-helper 0 m n m\n--\n-- The invariant is:\n--\n--   m = k + j  ==&gt;  mod-helper k m n j = (n + k) mod (1 + m).\n\nmod-helper : (k m n j : Nat) \u2192 Nat\nmod-helper k m  zero    j      = k\nmod-helper k m (suc n)  zero   = mod-helper 0       m n m\nmod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j\n\n{-# BUILTIN NATMODSUCAUX mod-helper #-}\n\n-- Proof of the invariant by induction on n.\n--\n--   clause 1: mod-helper k m 0 j\n--           = k                               by definition\n--           = (0 + k) mod (1 + m)             since m = k + j, thus k &lt; m\n--\n--   clause 2: mod-helper k m (1 + n) 0\n--           = mod-helper 0 m n m              by definition\n--           = (n + 0)       mod (1 + m)       by induction hypothesis\n--           = (n + (1 + m)) mod (1 + m)       by expansion\n--           = (1 + n) + k)  mod (1 + m)       since k = m (as l = 0)\n--\n--   clause 3: mod-helper k m (1 + n) (1 + j)\n--           = mod-helper (1 + k) m n j        by definition\n--           = (n + (1 + k)) mod (1 + m)       by induction hypothesis\n--           = ((1 + n) + k) mod (1 + m)       by commutativity\n--\n-- Q.e.d.\n</pre>"},{"location":"md/Agda/Builtin/Sigma/","title":"Agda.Builtin.Sigma","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Sigma where\n\nopen import Agda.Primitive\n\nrecord \u03a3 {a b} (A : Set a) (B : A \u2192 Set b) : Set (a \u2294 b) where\n  constructor _,_\n  field\n    fst : A\n    snd : B fst\n\nopen \u03a3 public\n\ninfixr 4 _,_\n\n{-# BUILTIN SIGMA \u03a3 #-}\n</pre>"},{"location":"md/Agda/Builtin/Strict/","title":"Agda.Builtin.Strict","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Strict where\n\nopen import Agda.Builtin.Equality\n\nprimitive\n  primForce      : \u2200 {a b} {A : Set a} {B : A \u2192 Set b} (x : A) \u2192 (\u2200 x \u2192 B x) \u2192 B x\n  primForceLemma : \u2200 {a b} {A : Set a} {B : A \u2192 Set b} (x : A) (f : \u2200 x \u2192 B x) \u2192 primForce x f \u2261 f x\n</pre>"},{"location":"md/Agda/Builtin/String/","title":"Agda.Builtin.String","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.String where\n\nopen import Agda.Builtin.Bool\nopen import Agda.Builtin.Char\nopen import Agda.Builtin.List\nopen import Agda.Builtin.Maybe\nopen import Agda.Builtin.Nat using (Nat)\nopen import Agda.Builtin.Sigma\n\npostulate String : Set\n{-# BUILTIN STRING String #-}\n\nprimitive\n  primStringUncons   : String \u2192 Maybe (\u03a3 Char (\u03bb _ \u2192 String))\n  primStringToList   : String \u2192 List Char\n  primStringFromList : List Char \u2192 String\n  primStringAppend   : String \u2192 String \u2192 String\n  primStringEquality : String \u2192 String \u2192 Bool\n  primShowChar       : Char \u2192 String\n  primShowString     : String \u2192 String\n  primShowNat        : Nat \u2192 String\n\n{-# COMPILE JS primStringUncons = function(x) {\n   if (x === \"\") { return z_jAgda_Agda_Builtin_Maybe[\"Maybe\"][\"nothing\"]; };\n   return z_jAgda_Agda_Builtin_Maybe[\"Maybe\"][\"just\"](z_jAgda_Agda_Builtin_Sigma[\"_,_\"](x.charAt(0))(x.slice(1)));\n   }\n #-}\n{-# COMPILE JS primStringToList = function(x) { return x.split(\"\"); } #-}\n{-# COMPILE JS primStringFromList = function(x) { return x.join(\"\"); } #-}\n{-# COMPILE JS primStringAppend = function(x) { return function(y) { return x+y; }; } #-}\n{-# COMPILE JS primStringEquality = function(x) { return function(y) { return x===y; }; } #-}\n{-# COMPILE JS primShowChar = function(x) { return JSON.stringify(x); } #-}\n{-# COMPILE JS primShowString = function(x) { return JSON.stringify(x); } #-}\n{-# COMPILE JS primShowNat = function(x) { return x.toString(); } #-}\n</pre>"},{"location":"md/Agda/Builtin/Unit/","title":"Agda.Builtin.Unit","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Unit where\n\nrecord \u22a4 : Set where\n  instance constructor tt\n\n{-# BUILTIN UNIT \u22a4 #-}\n{-# COMPILE GHC \u22a4 = data () (()) #-}\n</pre>"},{"location":"md/Agda/Primitive/","title":"Agda.Primitive","text":"<pre>-- The Agda primitives (preloaded).\n\n{-# OPTIONS --cubical-compatible --no-import-sorts --level-universe #-}\n\nmodule Agda.Primitive where\n\n------------------------------------------------------------------------\n-- Universe levels\n------------------------------------------------------------------------\n\ninfixl 6 _\u2294_\n\n{-# BUILTIN PROP           Prop      #-}\n{-# BUILTIN TYPE           Set       #-}\n{-# BUILTIN STRICTSET      SSet      #-}\n\n{-# BUILTIN PROPOMEGA      Prop\u03c9     #-}\n{-# BUILTIN SETOMEGA       Set\u03c9      #-}\n{-# BUILTIN STRICTSETOMEGA SSet\u03c9     #-}\n\n{-# BUILTIN LEVELUNIV      LevelUniv #-}\n\n-- Level is the first thing we need to define.\n-- The other postulates can only be checked if built-in Level is known.\n\npostulate\n  Level : LevelUniv\n\n-- MAlonzo compiles Level to (). This should be safe, because it is\n-- not possible to pattern match on levels.\n\n{-# BUILTIN LEVEL Level #-}\n\npostulate\n  lzero : Level\n  lsuc  : (\u2113 : Level) \u2192 Level\n  _\u2294_   : (\u2113\u2081 \u2113\u2082 : Level) \u2192 Level\n\n{-# BUILTIN LEVELZERO lzero #-}\n{-# BUILTIN LEVELSUC  lsuc  #-}\n{-# BUILTIN LEVELMAX  _\u2294_   #-}\n</pre>"},{"location":"md/Algebra/","title":"Algebra","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of algebraic structures like monoids and rings\n-- (packed in records together with sets, operations, etc.)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra where\n\nopen import Algebra.Core public\nopen import Algebra.Definitions public\nopen import Algebra.Structures public\nopen import Algebra.Structures.Biased public\nopen import Algebra.Bundles public\n</pre>"},{"location":"md/Algebra/Bundles/","title":"Algebra.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of algebraic structures like monoids and rings\n-- (packed in records together with sets, operations, etc.)\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Bundles where\n\nimport Algebra.Bundles.Raw as Raw\nopen import Algebra.Core\nopen import Algebra.Structures\nopen import Relation.Binary.Core using (Rel)\nopen import Level\n\n------------------------------------------------------------------------\n-- Re-export definitions of 'raw' bundles\n\nopen Raw public\n  using ( RawSuccessorSet; RawMagma; RawMonoid; RawGroup\n        ; RawNearSemiring; RawSemiring\n        ; RawRingWithoutOne; RawRing\n        ; RawQuasigroup; RawLoop; RawKleeneAlgebra)\n\n------------------------------------------------------------------------\n-- Bundles with 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord SuccessorSet c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  4 _\u2248_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\n    suc#             : Op\u2081 Carrier\n    zero#            : Carrier\n    isSuccessorSet   : IsSuccessorSet _\u2248_ suc# zero#\n\n  open IsSuccessorSet isSuccessorSet public\n\n  rawSuccessorSet : RawSuccessorSet _ _\n  rawSuccessorSet = record { _\u2248_ = _\u2248_; suc# = suc#; zero# = zero# }\n\n  open RawSuccessorSet rawSuccessorSet public\n\n------------------------------------------------------------------------\n-- Bundles with 1 binary operation\n------------------------------------------------------------------------\n\nrecord Magma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isMagma : IsMagma _\u2248_ _\u2219_\n\n  open IsMagma isMagma public\n\n  rawMagma : RawMagma _ _\n  rawMagma = record { _\u2248_ = _\u2248_; _\u2219_ = _\u2219_ }\n\n  open RawMagma rawMagma public\n    using (_\u2249_)\n\n\nrecord SelectiveMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\n    _\u2219_              : Op\u2082 Carrier\n    isSelectiveMagma : IsSelectiveMagma _\u2248_ _\u2219_\n\n  open IsSelectiveMagma isSelectiveMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public using (rawMagma)\n\n\nrecord CommutativeMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\n    _\u2219_                : Op\u2082 Carrier\n    isCommutativeMagma : IsCommutativeMagma _\u2248_ _\u2219_\n\n  open IsCommutativeMagma isCommutativeMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public using (rawMagma)\n\nrecord IdempotentMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isIdempotentMagma  : IsIdempotentMagma _\u2248_ _\u2219_\n\n  open IsIdempotentMagma isIdempotentMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (rawMagma)\n\nrecord AlternativeMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isAlternativeMagma  : IsAlternativeMagma _\u2248_ _\u2219_\n\n  open IsAlternativeMagma isAlternativeMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (rawMagma)\n\nrecord FlexibleMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isFlexibleMagma  : IsFlexibleMagma _\u2248_ _\u2219_\n\n  open IsFlexibleMagma isFlexibleMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (rawMagma)\n\nrecord MedialMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isMedialMagma  : IsMedialMagma _\u2248_ _\u2219_\n\n  open IsMedialMagma isMedialMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (rawMagma)\n\nrecord SemimedialMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isSemimedialMagma  : IsSemimedialMagma _\u2248_ _\u2219_\n\n  open IsSemimedialMagma isSemimedialMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (rawMagma)\n\n\nrecord Semigroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier     : Set c\n    _\u2248_         : Rel Carrier \u2113\n    _\u2219_         : Op\u2082 Carrier\n    isSemigroup : IsSemigroup _\u2248_ _\u2219_\n\n  open IsSemigroup isSemigroup public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (_\u2249_; rawMagma)\n\n\nrecord Band c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    isBand  : IsBand _\u2248_ _\u2219_\n\n  open IsBand isBand public\n\n  semigroup : Semigroup c \u2113\n  semigroup = record { isSemigroup = isSemigroup }\n\n  open Semigroup semigroup public\n    using (_\u2249_; magma; rawMagma)\n\n\nrecord CommutativeSemigroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier                 : Set c\n    _\u2248_                     : Rel Carrier \u2113\n    _\u2219_                     : Op\u2082 Carrier\n    isCommutativeSemigroup  : IsCommutativeSemigroup _\u2248_ _\u2219_\n\n  open IsCommutativeSemigroup isCommutativeSemigroup public\n\n  semigroup : Semigroup c \u2113\n  semigroup = record { isSemigroup = isSemigroup }\n\n  open Semigroup semigroup public\n    using (_\u2249_; magma; rawMagma)\n\n  commutativeMagma : CommutativeMagma c \u2113\n  commutativeMagma = record { isCommutativeMagma = isCommutativeMagma }\n\nrecord CommutativeBand c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\n    _\u2219_                : Op\u2082 Carrier\n    isCommutativeBand  : IsCommutativeBand _\u2248_ _\u2219_\n\n  open IsCommutativeBand isCommutativeBand public\n\n  band : Band _ _\n  band = record { isBand = isBand }\n\n  open Band band public\n    using (_\u2249_; magma; rawMagma; semigroup)\n\n  commutativeSemigroup : CommutativeSemigroup c \u2113\n  commutativeSemigroup = record { isCommutativeSemigroup = isCommutativeSemigroup }\n\n  open CommutativeSemigroup commutativeSemigroup public\n    using (commutativeMagma)\n\n\n------------------------------------------------------------------------\n-- Bundles with 1 binary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord UnitalMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier  : Set c\n    _\u2248_      : Rel Carrier \u2113\n    _\u2219_      : Op\u2082 Carrier\n    \u03b5        : Carrier\n    isUnitalMagma : IsUnitalMagma _\u2248_ _\u2219_ \u03b5\n\n  open IsUnitalMagma isUnitalMagma public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (_\u2249_; rawMagma)\n\n\nrecord Monoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier  : Set c\n    _\u2248_      : Rel Carrier \u2113\n    _\u2219_      : Op\u2082 Carrier\n    \u03b5        : Carrier\n    isMonoid : IsMonoid _\u2248_ _\u2219_ \u03b5\n\n  open IsMonoid isMonoid public\n\n  semigroup : Semigroup _ _\n  semigroup = record { isSemigroup = isSemigroup }\n\n  open Semigroup semigroup public\n    using (_\u2249_; rawMagma; magma)\n\n  rawMonoid : RawMonoid _ _\n  rawMonoid = record { _\u2248_ = _\u2248_; _\u2219_ = _\u2219_; \u03b5 = \u03b5}\n\n  unitalMagma : UnitalMagma _ _\n  unitalMagma = record { isUnitalMagma = isUnitalMagma  }\n\n\nrecord CommutativeMonoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier             : Set c\n    _\u2248_                 : Rel Carrier \u2113\n    _\u2219_                 : Op\u2082 Carrier\n    \u03b5                   : Carrier\n    isCommutativeMonoid : IsCommutativeMonoid _\u2248_ _\u2219_ \u03b5\n\n  open IsCommutativeMonoid isCommutativeMonoid public\n\n  monoid : Monoid _ _\n  monoid = record { isMonoid = isMonoid }\n\n  open Monoid monoid public\n    using (_\u2249_; rawMagma; magma; semigroup; unitalMagma; rawMonoid)\n\n  commutativeSemigroup : CommutativeSemigroup _ _\n  commutativeSemigroup = record { isCommutativeSemigroup = isCommutativeSemigroup }\n\n  open CommutativeSemigroup commutativeSemigroup public\n    using (commutativeMagma)\n\nrecord IdempotentMonoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\n    _\u2219_                : Op\u2082 Carrier\n    \u03b5                  : Carrier\n    isIdempotentMonoid : IsIdempotentMonoid _\u2248_ _\u2219_ \u03b5\n\n  open IsIdempotentMonoid isIdempotentMonoid public\n\n  monoid : Monoid _ _\n  monoid = record { isMonoid = isMonoid }\n\n  open Monoid monoid public\n    using (_\u2249_; rawMagma; magma; semigroup; unitalMagma; rawMonoid)\n\n  band : Band _ _\n  band = record { isBand = isBand }\n\n\nrecord IdempotentCommutativeMonoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier                       : Set c\n    _\u2248_                           : Rel Carrier \u2113\n    _\u2219_                           : Op\u2082 Carrier\n    \u03b5                             : Carrier\n    isIdempotentCommutativeMonoid : IsIdempotentCommutativeMonoid _\u2248_ _\u2219_ \u03b5\n\n  open IsIdempotentCommutativeMonoid isIdempotentCommutativeMonoid public\n\n  commutativeMonoid : CommutativeMonoid _ _\n  commutativeMonoid = record { isCommutativeMonoid = isCommutativeMonoid }\n\n  idempotentMonoid : IdempotentMonoid _ _\n  idempotentMonoid = record { isIdempotentMonoid = isIdempotentMonoid }\n\n  commutativeBand : CommutativeBand _ _\n  commutativeBand = record { isCommutativeBand = isCommutativeBand }\n\n  open CommutativeMonoid commutativeMonoid public\n    using\n    ( _\u2249_; rawMagma; magma; unitalMagma; commutativeMagma\n    ; semigroup; commutativeSemigroup\n    ; rawMonoid; monoid\n    )\n\n  open CommutativeBand commutativeBand public\n    using (band)\n\n-- Idempotent commutative monoids are also known as bounded lattices.\n-- Note that the BoundedLattice necessarily uses the notation inherited\n-- from monoids rather than lattices.\n\nBoundedLattice = IdempotentCommutativeMonoid\n\nmodule BoundedLattice {c \u2113} (idemCommMonoid : IdempotentCommutativeMonoid c \u2113) =\n       IdempotentCommutativeMonoid idemCommMonoid\n\n\n------------------------------------------------------------------------\n-- Bundles with 1 binary operation, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord InvertibleMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n    _\u207b\u00b9     : Op\u2081 Carrier\n    isInvertibleMagma : IsInvertibleMagma _\u2248_ _\u2219_ \u03b5 _\u207b\u00b9\n\n  open IsInvertibleMagma isInvertibleMagma public\n\n  magma : Magma _ _\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (_\u2249_; rawMagma)\n\n\nrecord InvertibleUnitalMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier                  : Set c\n    _\u2248_                      : Rel Carrier \u2113\n    _\u2219_                      : Op\u2082 Carrier\n    \u03b5                        : Carrier\n    _\u207b\u00b9                      : Op\u2081 Carrier\n    isInvertibleUnitalMagma  : IsInvertibleUnitalMagma _\u2248_ _\u2219_ \u03b5 _\u207b\u00b9\n\n  open IsInvertibleUnitalMagma isInvertibleUnitalMagma public\n\n  invertibleMagma : InvertibleMagma _ _\n  invertibleMagma = record { isInvertibleMagma = isInvertibleMagma }\n\n  open InvertibleMagma invertibleMagma public\n    using (_\u2249_; rawMagma; magma)\n\nrecord Group c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n    _\u207b\u00b9     : Op\u2081 Carrier\n    isGroup : IsGroup _\u2248_ _\u2219_ \u03b5 _\u207b\u00b9\n\n  open IsGroup isGroup public\n\n  rawGroup : RawGroup _ _\n  rawGroup = record { _\u2248_ = _\u2248_; _\u2219_ = _\u2219_; \u03b5 = \u03b5; _\u207b\u00b9 = _\u207b\u00b9}\n\n  monoid : Monoid _ _\n  monoid = record { isMonoid = isMonoid }\n\n  open Monoid monoid public\n    using (_\u2249_; rawMagma; magma; semigroup; unitalMagma; rawMonoid)\n\n  invertibleMagma : InvertibleMagma c \u2113\n  invertibleMagma = record\n    { isInvertibleMagma = isInvertibleMagma\n    }\n\n  invertibleUnitalMagma : InvertibleUnitalMagma c \u2113\n  invertibleUnitalMagma = record\n    { isInvertibleUnitalMagma = isInvertibleUnitalMagma\n    }\n\nrecord AbelianGroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier        : Set c\n    _\u2248_            : Rel Carrier \u2113\n    _\u2219_            : Op\u2082 Carrier\n    \u03b5              : Carrier\n    _\u207b\u00b9            : Op\u2081 Carrier\n    isAbelianGroup : IsAbelianGroup _\u2248_ _\u2219_ \u03b5 _\u207b\u00b9\n\n  open IsAbelianGroup isAbelianGroup public\n\n  group : Group _ _\n  group = record { isGroup = isGroup }\n\n  open Group group public using\n    (_\u2249_; rawMagma; magma; semigroup\n    ; rawMonoid; monoid; rawGroup; invertibleMagma; invertibleUnitalMagma\n    )\n\n  commutativeMonoid : CommutativeMonoid _ _\n  commutativeMonoid = record { isCommutativeMonoid = isCommutativeMonoid }\n\n  open CommutativeMonoid commutativeMonoid public\n    using (commutativeMagma; commutativeSemigroup)\n\n------------------------------------------------------------------------\n-- Bundles with 2 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord NearSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier        : Set c\n    _\u2248_            : Rel Carrier \u2113\n    _+_            : Op\u2082 Carrier\n    _*_            : Op\u2082 Carrier\n    0#             : Carrier\n    isNearSemiring : IsNearSemiring _\u2248_ _+_ _*_ 0#\n\n  open IsNearSemiring isNearSemiring public\n\n  rawNearSemiring : RawNearSemiring _ _\n  rawNearSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    }\n\n  +-monoid : Monoid _ _\n  +-monoid = record { isMonoid = +-isMonoid }\n\n  open Monoid +-monoid public\n    using (_\u2249_) renaming\n    ( rawMagma    to  +-rawMagma\n    ; magma       to  +-magma\n    ; semigroup   to  +-semigroup\n    ; unitalMagma to  +-unitalMagma\n    ; rawMonoid   to  +-rawMonoid\n    )\n\n  *-semigroup : Semigroup _ _\n  *-semigroup = record { isSemigroup = *-isSemigroup }\n\n  open Semigroup *-semigroup public\n    using () renaming\n    ( rawMagma to *-rawMagma\n    ; magma    to *-magma\n    )\n\n\nrecord SemiringWithoutOne c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier              : Set c\n    _\u2248_                  : Rel Carrier \u2113\n    _+_                  : Op\u2082 Carrier\n    _*_                  : Op\u2082 Carrier\n    0#                   : Carrier\n    isSemiringWithoutOne : IsSemiringWithoutOne _\u2248_ _+_ _*_ 0#\n\n  open IsSemiringWithoutOne isSemiringWithoutOne public\n\n  nearSemiring : NearSemiring _ _\n  nearSemiring = record { isNearSemiring = isNearSemiring }\n\n  open NearSemiring nearSemiring public\n    using\n    ( +-rawMagma; +-magma; +-unitalMagma; +-semigroup\n    ; +-rawMonoid; +-monoid\n    ; *-rawMagma; *-magma; *-semigroup\n    ; rawNearSemiring\n    )\n\n  +-commutativeMonoid : CommutativeMonoid _ _\n  +-commutativeMonoid = record { isCommutativeMonoid = +-isCommutativeMonoid }\n\n  open CommutativeMonoid +-commutativeMonoid public\n    using () renaming\n    ( commutativeMagma     to +-commutativeMagma\n    ; commutativeSemigroup to +-commutativeSemigroup\n    )\n\n\nrecord CommutativeSemiringWithoutOne c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier                         : Set c\n    _\u2248_                             : Rel Carrier \u2113\n    _+_                             : Op\u2082 Carrier\n    _*_                             : Op\u2082 Carrier\n    0#                              : Carrier\n    isCommutativeSemiringWithoutOne :\n      IsCommutativeSemiringWithoutOne _\u2248_ _+_ _*_ 0#\n\n  open IsCommutativeSemiringWithoutOne\n         isCommutativeSemiringWithoutOne public\n\n  semiringWithoutOne : SemiringWithoutOne _ _\n  semiringWithoutOne =\n    record { isSemiringWithoutOne = isSemiringWithoutOne }\n\n  open SemiringWithoutOne semiringWithoutOne public\n    using\n    ( +-rawMagma; +-magma; +-unitalMagma; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-semigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; nearSemiring; rawNearSemiring\n    )\n\n------------------------------------------------------------------------\n-- Bundles with 2 binary operations &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord SemiringWithoutAnnihilatingZero c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier                           : Set c\n    _\u2248_                               : Rel Carrier \u2113\n    _+_                               : Op\u2082 Carrier\n    _*_                               : Op\u2082 Carrier\n    0#                                : Carrier\n    1#                                : Carrier\n    isSemiringWithoutAnnihilatingZero :\n      IsSemiringWithoutAnnihilatingZero _\u2248_ _+_ _*_ 0# 1#\n\n  open IsSemiringWithoutAnnihilatingZero\n         isSemiringWithoutAnnihilatingZero public\n\n  rawSemiring : RawSemiring c \u2113\n  rawSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawSemiring rawSemiring public\n    using (rawNearSemiring)\n\n  +-commutativeMonoid : CommutativeMonoid _ _\n  +-commutativeMonoid =\n    record { isCommutativeMonoid = +-isCommutativeMonoid }\n\n  open CommutativeMonoid +-commutativeMonoid public\n    using (_\u2249_) renaming\n    ( rawMagma             to +-rawMagma\n    ; magma                to +-magma\n    ; unitalMagma          to +-unitalMagma\n    ; commutativeMagma     to +-commutativeMagma\n    ; semigroup            to +-semigroup\n    ; commutativeSemigroup to +-commutativeSemigroup\n    ; rawMonoid            to +-rawMonoid\n    ; monoid               to +-monoid\n    )\n\n  *-monoid : Monoid _ _\n  *-monoid = record { isMonoid = *-isMonoid }\n\n  open Monoid *-monoid public\n    using () renaming\n    ( rawMagma  to *-rawMagma\n    ; magma     to *-magma\n    ; semigroup to *-semigroup\n    ; rawMonoid to *-rawMonoid\n    )\n\n\nrecord Semiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier    : Set c\n    _\u2248_        : Rel Carrier \u2113\n    _+_        : Op\u2082 Carrier\n    _*_        : Op\u2082 Carrier\n    0#         : Carrier\n    1#         : Carrier\n    isSemiring : IsSemiring _\u2248_ _+_ _*_ 0# 1#\n\n  open IsSemiring isSemiring public\n\n  semiringWithoutAnnihilatingZero : SemiringWithoutAnnihilatingZero _ _\n  semiringWithoutAnnihilatingZero = record\n    { isSemiringWithoutAnnihilatingZero =\n        isSemiringWithoutAnnihilatingZero\n    }\n\n  open SemiringWithoutAnnihilatingZero\n         semiringWithoutAnnihilatingZero public\n    using\n    ( _\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma;  *-magma;  *-semigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid\n    ; rawNearSemiring ; rawSemiring\n    )\n\n  semiringWithoutOne : SemiringWithoutOne _ _\n  semiringWithoutOne =\n    record { isSemiringWithoutOne = isSemiringWithoutOne }\n\n  open SemiringWithoutOne semiringWithoutOne public\n    using (nearSemiring)\n\n\nrecord CommutativeSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier               : Set c\n    _\u2248_                   : Rel Carrier \u2113\n    _+_                   : Op\u2082 Carrier\n    _*_                   : Op\u2082 Carrier\n    0#                    : Carrier\n    1#                    : Carrier\n    isCommutativeSemiring : IsCommutativeSemiring _\u2248_ _+_ _*_ 0# 1#\n\n  open IsCommutativeSemiring isCommutativeSemiring public\n\n  semiring : Semiring _ _\n  semiring = record { isSemiring = isSemiring }\n\n  open Semiring semiring public\n    using\n    ( _\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-semigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero\n    ; rawSemiring\n    )\n\n  *-commutativeMonoid : CommutativeMonoid _ _\n  *-commutativeMonoid = record\n    { isCommutativeMonoid = *-isCommutativeMonoid\n    }\n\n  open CommutativeMonoid *-commutativeMonoid public\n    using () renaming\n    ( commutativeMagma     to *-commutativeMagma\n    ; commutativeSemigroup to *-commutativeSemigroup\n    )\n\n  commutativeSemiringWithoutOne : CommutativeSemiringWithoutOne _ _\n  commutativeSemiringWithoutOne = record\n    { isCommutativeSemiringWithoutOne = isCommutativeSemiringWithoutOne\n    }\n\n\nrecord CancellativeCommutativeSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier                           : Set c\n    _\u2248_                               : Rel Carrier \u2113\n    _+_                               : Op\u2082 Carrier\n    _*_                               : Op\u2082 Carrier\n    0#                                : Carrier\n    1#                                : Carrier\n    isCancellativeCommutativeSemiring : IsCancellativeCommutativeSemiring _\u2248_ _+_ _*_ 0# 1#\n\n  open IsCancellativeCommutativeSemiring isCancellativeCommutativeSemiring public\n\n  commutativeSemiring : CommutativeSemiring c \u2113\n  commutativeSemiring = record\n    { isCommutativeSemiring = isCommutativeSemiring\n    }\n\n  open CommutativeSemiring commutativeSemiring public\n    using\n    ( +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-commutativeMagma; *-semigroup; *-commutativeSemigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid; *-commutativeMonoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero\n    ; rawSemiring\n    ; semiring\n    ; _\u2249_\n    )\n\nrecord IdempotentSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier                : Set c\n    _\u2248_                    : Rel Carrier \u2113\n    _+_                    : Op\u2082 Carrier\n    _*_                    : Op\u2082 Carrier\n    0#                     : Carrier\n    1#                     : Carrier\n    isIdempotentSemiring   : IsIdempotentSemiring _\u2248_ _+_ _*_ 0# 1#\n\n  open IsIdempotentSemiring isIdempotentSemiring public\n\n  semiring : Semiring _ _\n  semiring = record { isSemiring = isSemiring }\n\n  open Semiring semiring public\n    using\n    ( _\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-semigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero\n    ; rawSemiring\n    )\n\n  +-idempotentCommutativeMonoid : IdempotentCommutativeMonoid _ _\n  +-idempotentCommutativeMonoid = record { isIdempotentCommutativeMonoid = +-isIdempotentCommutativeMonoid }\n\n  open IdempotentCommutativeMonoid +-idempotentCommutativeMonoid public\n    using ()\n    renaming ( band to +-band\n             ; commutativeBand to +-commutativeBand\n             ; idempotentMonoid to +-idempotentMonoid\n             )\n\nrecord KleeneAlgebra c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u22c6\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier               : Set c\n    _\u2248_                   : Rel Carrier \u2113\n    _+_                   : Op\u2082 Carrier\n    _*_                   : Op\u2082 Carrier\n    _\u22c6                    : Op\u2081 Carrier\n    0#                    : Carrier\n    1#                    : Carrier\n    isKleeneAlgebra       : IsKleeneAlgebra _\u2248_ _+_ _*_ _\u22c6 0# 1#\n\n  open IsKleeneAlgebra isKleeneAlgebra public\n\n  idempotentSemiring : IdempotentSemiring _ _\n  idempotentSemiring = record { isIdempotentSemiring = isIdempotentSemiring }\n\n  open IdempotentSemiring idempotentSemiring public\n    using\n    ( _\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-semigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero\n    ; rawSemiring; semiring\n    )\n\n  rawKleeneAlgebra : RawKleeneAlgebra _ _\n  rawKleeneAlgebra = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; _\u22c6  = _\u22c6\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\nrecord Quasiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier       : Set c\n    _\u2248_           : Rel Carrier \u2113\n    _+_           : Op\u2082 Carrier\n    _*_           : Op\u2082 Carrier\n    0#            : Carrier\n    1#            : Carrier\n    isQuasiring   : IsQuasiring _\u2248_ _+_ _*_ 0# 1#\n\n  open IsQuasiring isQuasiring public\n\n  +-monoid : Monoid _ _\n  +-monoid = record { isMonoid = +-isMonoid }\n\n  open Monoid +-monoid public\n    using (_\u2249_) renaming\n    ( rawMagma    to  +-rawMagma\n    ; magma       to  +-magma\n    ; semigroup   to  +-semigroup\n    ; unitalMagma to  +-unitalMagma\n    ; rawMonoid   to  +-rawMonoid\n    )\n\n  *-monoid : Monoid _ _\n  *-monoid = record { isMonoid = *-isMonoid }\n\n  open Monoid *-monoid public\n    using () renaming\n    ( rawMagma  to *-rawMagma\n    ; magma     to *-magma\n    ; semigroup to *-semigroup\n    ; rawMonoid to *-rawMonoid\n    )\n\n------------------------------------------------------------------------\n-- Bundles with 2 binary operations, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RingWithoutOne c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\n    _+_               : Op\u2082 Carrier\n    _*_               : Op\u2082 Carrier\n    -_                : Op\u2081 Carrier\n    0#                : Carrier\n    isRingWithoutOne  : IsRingWithoutOne _\u2248_ _+_ _*_ -_ 0#\n\n  open IsRingWithoutOne isRingWithoutOne public\n\n  nearSemiring : NearSemiring _ _\n  nearSemiring = record { isNearSemiring = isNearSemiring }\n\n  open NearSemiring nearSemiring public\n    using (*-semigroup; *-magma)\n\n  +-abelianGroup : AbelianGroup _ _\n  +-abelianGroup = record { isAbelianGroup = +-isAbelianGroup }\n\n  open AbelianGroup +-abelianGroup public\n    using ()\n    renaming (group to +-group;\n      invertibleMagma to +-invertibleMagma;\n      invertibleUnitalMagma to +-invertibleUnitalMagma)\n\n  rawRingWithoutOne : RawRingWithoutOne _ _\n  rawRingWithoutOne = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; -_  = -_\n    ; 0#  = 0#\n    }\n\n  open RawRingWithoutOne rawRingWithoutOne public\n    using (+-rawGroup; *-rawMagma; rawNearSemiring)\n\n\n------------------------------------------------------------------------\n-- Bundles with 2 binary operations, 1 unary operation &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord NonAssociativeRing c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier               : Set c\n    _\u2248_                   : Rel Carrier \u2113\n    _+_                   : Op\u2082 Carrier\n    _*_                   : Op\u2082 Carrier\n    -_                    : Op\u2081 Carrier\n    0#                    : Carrier\n    1#                    : Carrier\n    isNonAssociativeRing  : IsNonAssociativeRing _\u2248_ _+_ _*_ -_ 0# 1#\n\n  open IsNonAssociativeRing isNonAssociativeRing public\n\n  +-abelianGroup : AbelianGroup _ _\n  +-abelianGroup = record { isAbelianGroup = +-isAbelianGroup }\n\n  open AbelianGroup +-abelianGroup public\n    using () renaming (group to +-group; invertibleMagma to +-invertibleMagma; invertibleUnitalMagma to +-invertibleUnitalMagma)\n\n  *-unitalMagma : UnitalMagma _ _\n  *-unitalMagma = record { isUnitalMagma = *-isUnitalMagma}\n\n  open UnitalMagma *-unitalMagma public\n    using () renaming (magma to *-magma; identity to *-identity)\n\nrecord Nearring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier       : Set c\n    _\u2248_           : Rel Carrier \u2113\n    _+_           : Op\u2082 Carrier\n    _*_           : Op\u2082 Carrier\n    -_            : Op\u2081 Carrier\n    0#            : Carrier\n    1#            : Carrier\n    isNearring    : IsNearring _\u2248_ _+_ _*_ 0# 1# -_\n\n  open IsNearring isNearring public\n\n  quasiring : Quasiring _ _\n  quasiring = record { isQuasiring = isQuasiring }\n\n  open Quasiring quasiring public\n    using\n    (_\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-semigroup; +-monoid; +-rawMonoid\n    ;*-rawMagma; *-magma; *-semigroup; *-monoid\n    )\n\n\nrecord Ring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    -_      : Op\u2081 Carrier\n    0#      : Carrier\n    1#      : Carrier\n    isRing  : IsRing _\u2248_ _+_ _*_ -_ 0# 1#\n\n  open IsRing isRing public\n\n  +-abelianGroup : AbelianGroup _ _\n  +-abelianGroup = record { isAbelianGroup = +-isAbelianGroup }\n\n  ringWithoutOne : RingWithoutOne _ _\n  ringWithoutOne = record { isRingWithoutOne = isRingWithoutOne }\n\n  semiring : Semiring _ _\n  semiring = record { isSemiring = isSemiring }\n\n  open Semiring semiring public\n    using\n    ( _\u2249_; +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-semigroup\n    ; +-rawMonoid; +-monoid ; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero\n    )\n\n  open NearSemiring nearSemiring public\n    using (rawNearSemiring)\n\n  open AbelianGroup +-abelianGroup public\n    using () renaming (group to +-group; invertibleMagma to +-invertibleMagma; invertibleUnitalMagma to +-invertibleUnitalMagma)\n\n  rawRing : RawRing _ _\n  rawRing = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; -_  = -_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawRing rawRing public\n    using (rawRingWithoutOne; +-rawGroup)\n\n\nrecord CommutativeRing c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\n    _+_               : Op\u2082 Carrier\n    _*_               : Op\u2082 Carrier\n    -_                : Op\u2081 Carrier\n    0#                : Carrier\n    1#                : Carrier\n    isCommutativeRing : IsCommutativeRing _\u2248_ _+_ _*_ -_ 0# 1#\n\n  open IsCommutativeRing isCommutativeRing public\n\n  ring : Ring _ _\n  ring = record { isRing = isRing }\n\n  open Ring ring public using (_\u2249_; rawRing; +-invertibleMagma; +-invertibleUnitalMagma; +-group; +-abelianGroup)\n\n  commutativeSemiring : CommutativeSemiring _ _\n  commutativeSemiring =\n    record { isCommutativeSemiring = isCommutativeSemiring }\n\n  open CommutativeSemiring commutativeSemiring public\n    using\n    ( +-rawMagma; +-magma; +-unitalMagma; +-commutativeMagma\n    ; +-semigroup; +-commutativeSemigroup\n    ; *-rawMagma; *-magma; *-commutativeMagma; *-semigroup; *-commutativeSemigroup\n    ; +-rawMonoid; +-monoid; +-commutativeMonoid\n    ; *-rawMonoid; *-monoid; *-commutativeMonoid\n    ; nearSemiring; semiringWithoutOne\n    ; semiringWithoutAnnihilatingZero; semiring\n    ; commutativeSemiringWithoutOne\n    )\n\n------------------------------------------------------------------------\n-- Bundles with 3 binary operations\n------------------------------------------------------------------------\n\nrecord Quasigroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier      : Set c\n    _\u2248_          : Rel Carrier \u2113\n    _\u2219_          : Op\u2082 Carrier\n    _\\\\_         : Op\u2082 Carrier\n    _//_         : Op\u2082 Carrier\n    isQuasigroup : IsQuasigroup  _\u2248_ _\u2219_ _\\\\_ _//_\n\n  open IsQuasigroup isQuasigroup public\n\n  magma : Magma c \u2113\n  magma = record { isMagma = isMagma }\n\n  open Magma magma public\n    using (_\u2249_; rawMagma)\n\n  rawQuasigroup : RawQuasigroup c \u2113\n  rawQuasigroup = record\n    { _\u2248_  = _\u2248_\n    ; _\u2219_  = _\u2219_\n    ; _\\\\_  = _\\\\_\n    ; _//_  = _//_\n    }\n\n  open RawQuasigroup rawQuasigroup public\n    using (//-rawMagma; \\\\-rawMagma; \u2219-rawMagma)\n\nrecord Loop  c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n    isLoop  : IsLoop  _\u2248_ _\u2219_ _\\\\_ _//_ \u03b5\n\n  open IsLoop isLoop public\n\n  rawLoop : RawLoop c \u2113\n  rawLoop = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    ; _\\\\_ = _\\\\_\n    ; _//_ = _//_\n    ; \u03b5 = \u03b5\n    }\n\n  quasigroup : Quasigroup _ _\n  quasigroup = record { isQuasigroup = isQuasigroup }\n\n  open Quasigroup quasigroup public\n    using (_\u2249_; \u2219-rawMagma; \\\\-rawMagma; //-rawMagma)\n\nrecord LeftBolLoop c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n    isLeftBolLoop : IsLeftBolLoop  _\u2248_ _\u2219_ _\\\\_ _//_ \u03b5\n\n  open IsLeftBolLoop isLeftBolLoop public\n\n  loop : Loop _ _\n  loop = record { isLoop = isLoop }\n\n  open Loop loop public\n    using (quasigroup)\n\nrecord RightBolLoop c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n    isRightBolLoop : IsRightBolLoop  _\u2248_ _\u2219_ _\\\\_ _//_ \u03b5\n\n  open IsRightBolLoop isRightBolLoop public\n\n  loop : Loop _ _\n  loop = record { isLoop = isLoop }\n\n  open Loop loop public\n    using (quasigroup)\n\nrecord MoufangLoop c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n    isMoufangLoop : IsMoufangLoop  _\u2248_ _\u2219_ _\\\\_ _//_ \u03b5\n\n  open IsMoufangLoop isMoufangLoop public\n\n  leftBolLoop : LeftBolLoop _ _\n  leftBolLoop = record { isLeftBolLoop = isLeftBolLoop }\n\n  open LeftBolLoop leftBolLoop public\n    using (loop)\n\nrecord MiddleBolLoop c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\n    _\u2219_             : Op\u2082 Carrier\n    _\\\\_            : Op\u2082 Carrier\n    _//_            : Op\u2082 Carrier\n    \u03b5               : Carrier\n    isMiddleBolLoop : IsMiddleBolLoop  _\u2248_ _\u2219_ _\\\\_ _//_ \u03b5\n\n  open IsMiddleBolLoop isMiddleBolLoop public\n\n  loop : Loop _ _\n  loop = record { isLoop = isLoop }\n\n  open Loop loop public\n    using (quasigroup)\n\n</pre>"},{"location":"md/Algebra/Bundles/Raw/","title":"Algebra.Bundles.Raw","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of 'raw' bundles\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Bundles.Raw where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles.Raw using (RawSetoid)\nopen import Level using (suc; _\u2294_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\n-- A raw SuccessorSet is a SuccessorSet without any laws.\n\nrecord RawSuccessorSet c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    suc#    : Op\u2081 Carrier\n    zero#   : Carrier\n\n  rawSetoid : RawSetoid c \u2113\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation\n------------------------------------------------------------------------\n\nrecord RawMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n\n  rawSetoid : RawSetoid c \u2113\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public using (_\u2249_)\n\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation &amp; 1 element\n------------------------------------------------------------------------\n\n-- A raw monoid is a monoid without any laws.\n\nrecord RawMonoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n\n  rawMagma : RawMagma c \u2113\n  rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    }\n\n  open RawMagma rawMagma public\n    using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawGroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n    _\u207b\u00b9     : Op\u2081 Carrier\n\n  rawMonoid : RawMonoid c \u2113\n  rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    ; \u03b5   = \u03b5\n    }\n\n  open RawMonoid rawMonoid public\n    using (_\u2249_; rawMagma)\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawNearSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    0#      : Carrier\n\n  +-rawMonoid : RawMonoid c \u2113\n  +-rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _+_\n    ;  \u03b5  = 0#\n    }\n\n  open RawMonoid +-rawMonoid public\n    using (_\u2249_) renaming (rawMagma to +-rawMagma)\n\n  *-rawMagma : RawMagma c \u2113\n  *-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _*_\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord RawSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawNearSemiring : RawNearSemiring c \u2113\n  rawNearSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    }\n\n  open RawNearSemiring rawNearSemiring public\n    using (_\u2249_; +-rawMonoid; +-rawMagma; *-rawMagma)\n\n  *-rawMonoid : RawMonoid c \u2113\n  *-rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _*_\n    ; \u03b5   = 1#\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawRingWithoutOne c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    -_      : Op\u2081 Carrier\n    0#      : Carrier\n\n  rawNearSemiring : RawNearSemiring c \u2113\n  rawNearSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    }\n\n  open RawNearSemiring rawNearSemiring public\n    using (_\u2249_; *-rawMagma; +-rawMagma; +-rawMonoid)\n\n  +-rawGroup : RawGroup c \u2113\n  +-rawGroup = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _+_\n    ; \u03b5   = 0#\n    ; _\u207b\u00b9 = -_\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations, 1 unary operation &amp; 2 elements\n------------------------------------------------------------------------\n\n-- A raw ring is a ring without any laws.\n\nrecord RawRing c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    -_      : Op\u2081 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawSemiring : RawSemiring c \u2113\n  rawSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawSemiring rawSemiring public\n    using\n    ( _\u2249_\n    ; +-rawMagma; +-rawMonoid\n    ; *-rawMagma; *-rawMonoid\n    )\n\n  rawRingWithoutOne : RawRingWithoutOne c \u2113\n  rawRingWithoutOne = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; -_ = -_\n    ; 0# = 0#\n    }\n\n  open RawRingWithoutOne rawRingWithoutOne public\n    using (+-rawGroup)\n\n------------------------------------------------------------------------\n-- Raw bundles with 3 binary operations\n------------------------------------------------------------------------\n\nrecord RawQuasigroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n\n  \u2219-rawMagma : RawMagma c \u2113\n  \u2219-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    }\n\n  \\\\-rawMagma : RawMagma c \u2113\n  \\\\-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\\\\_\n    }\n\n  //-rawMagma : RawMagma c \u2113\n  //-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _//_\n    }\n\n  open RawMagma \\\\-rawMagma public\n    using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 3 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawLoop  c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n\n  rawQuasigroup : RawQuasigroup c \u2113\n  rawQuasigroup = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    ; _\\\\_ = _\\\\_\n    ; _//_ = _//_\n    }\n\n  open RawQuasigroup rawQuasigroup public\n    using (_\u2249_ ; \u2219-rawMagma; \\\\-rawMagma; //-rawMagma)\n\nrecord RawKleeneAlgebra c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u22c6\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    _\u22c6      : Op\u2081 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawSemiring : RawSemiring c \u2113\n  rawSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawSemiring rawSemiring public\n    using\n    ( _\u2249_\n    ; +-rawMagma; +-rawMonoid\n    ; *-rawMagma; *-rawMonoid\n    )\n</pre>"},{"location":"md/Algebra/Consequences/Base/","title":"Algebra.Consequences.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lemmas relating algebraic definitions (such as associativity and\n-- commutativity) that don't require the equality relation to be a setoid.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Consequences.Base\n  {a} {A : Set a} where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nimport Algebra.Definitions as Definitions\n  using (Congruent\u2082; LeftCongruent; RightCongruent\n        ; Selective; Idempotent; SelfInverse; Involutive)\nopen import Data.Sum.Base using (_\u228e_; reduce)\nopen import Relation.Binary.Consequences\n  using (mono\u2082\u21d2mono\u02e1; mono\u2082\u21d2mono\u02b3)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Definitions using (Reflexive)\n\nmodule Congruence {\u2113} {_\u2219_ : Op\u2082 A} (_\u2248_ : Rel A \u2113) (open Definitions _\u2248_)\n                  (cong : Congruent\u2082 _\u2219_) (refl : Reflexive _\u2248_)\n  where\n\n  \u2219-cong\u02e1 : LeftCongruent _\u2219_\n  \u2219-cong\u02e1 {x} = mono\u2082\u21d2mono\u02e1 _ _\u2248_ _\u2248_ (refl {x = x}) cong x\n\n  \u2219-cong\u02b3 : RightCongruent _\u2219_\n  \u2219-cong\u02b3 {x} = mono\u2082\u21d2mono\u02b3 _\u2248_ _ _\u2248_ (refl {x = x}) cong x\n\nmodule _ {\u2113} {_\u2219_ : Op\u2082 A} (_\u2248_ : Rel A \u2113) (open Definitions _\u2248_) where\n\n  sel\u21d2idem : Selective _\u2219_ \u2192 Idempotent _\u2219_\n  sel\u21d2idem sel x = reduce (sel x x)\n\nmodule _ {\u2113} {f : Op\u2081 A} (_\u2248_ : Rel A \u2113) (open Definitions _\u2248_) where\n\n  reflexive\u2227selfInverse\u21d2involutive : Reflexive _\u2248_ \u2192\n                                     SelfInverse f \u2192\n                                     Involutive f\n  reflexive\u2227selfInverse\u21d2involutive refl inv _ = inv refl\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nreflexive+selfInverse\u21d2involutive = reflexive\u2227selfInverse\u21d2involutive\n{-# WARNING_ON_USAGE reflexive+selfInverse\u21d2involutive\n\"Warning: reflexive+selfInverse\u21d2involutive was deprecated in v2.0.\nPlease use reflexive\u2227selfInverse\u21d2involutive instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Consequences/Propositional/","title":"Algebra.Consequences.Propositional","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relations between properties of functions, such as associativity and\n-- commutativity (specialised to propositional equality)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Consequences.Propositional\n  {a} {A : Set a} where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Definitions using (Symmetric; Total)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; cong\u2082; subst)\nopen import Relation.Binary.PropositionalEquality.Properties\n  using (setoid)\nopen import Relation.Unary using (Pred)\n\nopen import Algebra.Definitions {A = A} _\u2261_\nimport Algebra.Consequences.Setoid (setoid A) as Base\n\n------------------------------------------------------------------------\n-- Re-export all proofs that don't require congruence or substitutivity\n\nopen Base public\n  hiding\n  ( comm\u2227assoc\u21d2middleFour\n  ; identity\u2227middleFour\u21d2assoc\n  ; identity\u2227middleFour\u21d2comm\n  ; assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1\n  ; assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3\n  ; assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique\n  ; assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique\n  ; comm\u2227distr\u02e1\u21d2distr\u02b3\n  ; comm\u2227distr\u02b3\u21d2distr\u02e1\n  ; comm\u21d2sym[distrib\u02e1]\n  ; subst\u2227comm\u21d2sym\n  ; wlog\n  ; sel\u21d2idem\n-- plus all the deprecated versions of the above\n  ; comm+assoc\u21d2middleFour\n  ; identity+middleFour\u21d2assoc\n  ; identity+middleFour\u21d2comm\n  ; assoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1\n  ; assoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3\n  ; assoc+id+inv\u02b3\u21d2inv\u02e1-unique\n  ; assoc+id+inv\u02e1\u21d2inv\u02b3-unique\n  ; comm+distr\u02e1\u21d2distr\u02b3\n  ; comm+distr\u02b3\u21d2distr\u02e1\n  ; subst+comm\u21d2sym\n  )\n\n------------------------------------------------------------------------\n-- Group-like structures\n\nmodule _ {_\u2219_ _\u207b\u00b9 \u03b5} where\n\n  assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique : Associative _\u2219_ \u2192 Identity \u03b5 _\u2219_ \u2192\n                              RightInverse \u03b5 _\u207b\u00b9 _\u2219_ \u2192\n                              \u2200 x y \u2192 (x \u2219 y) \u2261 \u03b5 \u2192 x \u2261 (y \u207b\u00b9)\n  assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique = Base.assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique (cong\u2082 _)\n\n  assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique : Associative _\u2219_ \u2192 Identity \u03b5 _\u2219_ \u2192\n                              LeftInverse \u03b5 _\u207b\u00b9 _\u2219_ \u2192\n                              \u2200 x y \u2192 (x \u2219 y) \u2261 \u03b5 \u2192 y \u2261 (x \u207b\u00b9)\n  assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique = Base.assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique (cong\u2082 _)\n\n------------------------------------------------------------------------\n-- Ring-like structures\n\nmodule _ {_+_ _*_ -_ 0#} where\n\n  assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 : Associative _+_ \u2192 _*_ DistributesOver\u02b3 _+_ \u2192\n                                RightIdentity 0# _+_ \u2192 RightInverse 0# -_ _+_ \u2192\n                                LeftZero 0# _*_\n  assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 =\n    Base.assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 (cong\u2082 _+_) (cong\u2082 _*_)\n\n  assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 : Associative _+_ \u2192 _*_ DistributesOver\u02e1 _+_ \u2192\n                                RightIdentity 0# _+_ \u2192 RightInverse 0# -_ _+_ \u2192\n                                RightZero 0# _*_\n  assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 =\n    Base.assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 (cong\u2082 _+_) (cong\u2082 _*_)\n\n------------------------------------------------------------------------\n-- Bisemigroup-like structures\n\nmodule _ {_\u2219_ _\u25e6_ : Op\u2082 A} (\u2219-comm : Commutative _\u2219_) where\n\n  comm\u2227distr\u02e1\u21d2distr\u02b3 : _\u2219_ DistributesOver\u02e1 _\u25e6_ \u2192 _\u2219_ DistributesOver\u02b3 _\u25e6_\n  comm\u2227distr\u02e1\u21d2distr\u02b3 = Base.comm+distr\u02e1\u21d2distr\u02b3 (cong\u2082 _) \u2219-comm\n\n  comm\u2227distr\u02b3\u21d2distr\u02e1 : _\u2219_ DistributesOver\u02b3 _\u25e6_ \u2192 _\u2219_ DistributesOver\u02e1 _\u25e6_\n  comm\u2227distr\u02b3\u21d2distr\u02e1 = Base.comm\u2227distr\u02b3\u21d2distr\u02e1 (cong\u2082 _) \u2219-comm\n\n  comm\u21d2sym[distrib\u02e1] : \u2200 x \u2192 Symmetric (\u03bb y z \u2192 (x \u25e6 (y \u2219 z)) \u2261 ((x \u25e6 y) \u2219 (x \u25e6 z)))\n  comm\u21d2sym[distrib\u02e1] = Base.comm\u21d2sym[distrib\u02e1] (cong\u2082 _\u25e6_) \u2219-comm\n\n------------------------------------------------------------------------\n-- Selectivity\n\nmodule _ {_\u2219_ : Op\u2082 A} where\n\n  sel\u21d2idem : Selective _\u2219_ \u2192 Idempotent _\u2219_\n  sel\u21d2idem = Base.sel\u21d2idem _\u2261_\n\n------------------------------------------------------------------------\n-- Middle-Four Exchange\n\nmodule _ {_\u2219_ : Op\u2082 A} where\n\n  comm\u2227assoc\u21d2middleFour : Commutative _\u2219_ \u2192 Associative _\u2219_ \u2192\n                          _\u2219_ MiddleFourExchange _\u2219_\n  comm\u2227assoc\u21d2middleFour = Base.comm\u2227assoc\u21d2middleFour (cong\u2082 _\u2219_)\n\n  identity\u2227middleFour\u21d2assoc : {e : A} \u2192 Identity e _\u2219_ \u2192\n                              _\u2219_ MiddleFourExchange _\u2219_ \u2192\n                              Associative _\u2219_\n  identity\u2227middleFour\u21d2assoc = Base.identity\u2227middleFour\u21d2assoc (cong\u2082 _\u2219_)\n\n  identity\u2227middleFour\u21d2comm : {_+_ : Op\u2082 A} {e : A} \u2192 Identity e _+_ \u2192\n                             _\u2219_ MiddleFourExchange _+_ \u2192\n                             Commutative _\u2219_\n  identity\u2227middleFour\u21d2comm = Base.identity\u2227middleFour\u21d2comm (cong\u2082 _\u2219_)\n\n------------------------------------------------------------------------\n-- Without Loss of Generality\n\nmodule _ {p} {P : Pred A p} where\n\n  subst\u2227comm\u21d2sym : \u2200 {f} (f-comm : Commutative f) \u2192\n                   Symmetric (\u03bb a b \u2192 P (f a b))\n  subst\u2227comm\u21d2sym = Base.subst\u2227comm\u21d2sym {P = P} subst\n\n  wlog : \u2200 {f} (f-comm : Commutative f) \u2192\n         \u2200 {r} {_R_ : Rel _ r} \u2192 Total _R_ \u2192\n         (\u2200 a b \u2192 a R b \u2192 P (f a b)) \u2192\n         \u2200 a b \u2192 P (f a b)\n  wlog = Base.wlog {P = P} subst\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\ncomm+assoc\u21d2middleFour = comm\u2227assoc\u21d2middleFour\n{-# WARNING_ON_USAGE comm+assoc\u21d2middleFour\n\"Warning: comm+assoc\u21d2middleFour was deprecated in v2.0.\nPlease use comm\u2227assoc\u21d2middleFour instead.\"\n#-}\nidentity+middleFour\u21d2assoc = identity\u2227middleFour\u21d2assoc\n{-# WARNING_ON_USAGE identity+middleFour\u21d2assoc\n\"Warning: identity+middleFour\u21d2assoc was deprecated in v2.0.\nPlease use identity\u2227middleFour\u21d2assoc instead.\"\n#-}\nidentity+middleFour\u21d2comm = identity\u2227middleFour\u21d2comm\n{-# WARNING_ON_USAGE identity+middleFour\u21d2comm\n\"Warning: identity+middleFour\u21d2comm was deprecated in v2.0.\nPlease use identity\u2227middleFour\u21d2comm instead.\"\n#-}\ncomm+distr\u02e1\u21d2distr\u02b3 = comm\u2227distr\u02e1\u21d2distr\u02b3\n{-# WARNING_ON_USAGE comm+distr\u02e1\u21d2distr\u02b3\n\"Warning: comm+distr\u02e1\u21d2distr\u02b3 was deprecated in v2.0.\nPlease use comm\u2227distr\u02e1\u21d2distr\u02b3 instead.\"\n#-}\ncomm+distr\u02b3\u21d2distr\u02e1 = comm\u2227distr\u02b3\u21d2distr\u02e1\n{-# WARNING_ON_USAGE comm+distr\u02b3\u21d2distr\u02e1\n\"Warning: comm+distr\u02b3\u21d2distr\u02e1 was deprecated in v2.0.\nPlease use comm\u2227distr\u02b3\u21d2distr\u02e1 instead.\"\n#-}\nassoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1 = assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1\n{-# WARNING_ON_USAGE assoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1\n\"Warning: assoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1 was deprecated in v2.0.\nPlease use assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 instead.\"\n#-}\nassoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3 = assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3\n{-# WARNING_ON_USAGE assoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3\n\"Warning: assoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3 was deprecated in v2.0.\nPlease use assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 instead.\"\n#-}\nassoc+id+inv\u02b3\u21d2inv\u02e1-unique = assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique\n{-# WARNING_ON_USAGE assoc+id+inv\u02b3\u21d2inv\u02e1-unique\n\"Warning: assoc+id+inv\u02b3\u21d2inv\u02e1-unique was deprecated in v2.0.\nPlease use assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique instead.\"\n#-}\nassoc+id+inv\u02e1\u21d2inv\u02b3-unique = assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique\n{-# WARNING_ON_USAGE assoc+id+inv\u02e1\u21d2inv\u02b3-unique\n\"Warning: assoc+id+inv\u02e1\u21d2inv\u02b3-unique was deprecated in v2.0.\nPlease use assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique instead.\"\n#-}\nsubst+comm\u21d2sym = subst\u2227comm\u21d2sym\n{-# WARNING_ON_USAGE subst+comm\u21d2sym\n\"Warning: subst+comm\u21d2sym was deprecated in v2.0.\nPlease use subst\u2227comm\u21d2sym instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Consequences/Setoid/","title":"Algebra.Consequences.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relations between properties of functions, such as associativity and\n-- commutativity, when the underlying relation is a setoid\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Definitions\n  using (Substitutive; Symmetric; Total)\n\nmodule Algebra.Consequences.Setoid {a \u2113} (S : Setoid a \u2113) where\n\nimport Algebra.Consequences.Base as Base\nopen import Algebra.Core\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (_$_; id; _\u2218_)\nopen import Function.Definitions\nimport Relation.Binary.Consequences as Bin\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Unary using (Pred)\n\nopen Setoid S renaming (Carrier to A)\nopen import Algebra.Definitions _\u2248_\nopen import Relation.Binary.Reasoning.Setoid S\n\n------------------------------------------------------------------------\n-- Re-exports\n\n-- Export base lemmas that don't require the setoid\n\nopen Base public\n  hiding (module Congruence)\n\n-- Export congruence lemmas using reflexivity\n\nmodule Congruence {_\u2219_ : Op\u2082 A} (cong : Congruent\u2082 _\u2219_) where\n\n  open Base.Congruence _\u2248_ cong refl public\n\n------------------------------------------------------------------------\n-- MiddleFourExchange\n\nmodule _ {_\u2219_ : Op\u2082 A} (cong : Congruent\u2082 _\u2219_) where\n\n  open Congruence cong\n\n  comm\u2227assoc\u21d2middleFour : Commutative _\u2219_ \u2192 Associative _\u2219_ \u2192\n                          _\u2219_ MiddleFourExchange _\u2219_\n  comm\u2227assoc\u21d2middleFour comm assoc w x y z = begin\n    (w \u2219 x) \u2219 (y \u2219 z) \u2248\u27e8 assoc w x (y \u2219 z) \u27e9\n    w \u2219 (x \u2219 (y \u2219 z)) \u2248\u27e8 \u2219-cong\u02e1 (assoc x y z) \u27e8\n    w \u2219 ((x \u2219 y) \u2219 z) \u2248\u27e8 \u2219-cong\u02e1 (\u2219-cong\u02b3 (comm x y)) \u27e9\n    w \u2219 ((y \u2219 x) \u2219 z) \u2248\u27e8 \u2219-cong\u02e1 (assoc y x z) \u27e9\n    w \u2219 (y \u2219 (x \u2219 z)) \u2248\u27e8 assoc w y (x \u2219 z) \u27e8\n    (w \u2219 y) \u2219 (x \u2219 z) \u220e\n\n  identity\u2227middleFour\u21d2assoc : {e : A} \u2192 Identity e _\u2219_ \u2192\n                              _\u2219_ MiddleFourExchange _\u2219_ \u2192\n                              Associative _\u2219_\n  identity\u2227middleFour\u21d2assoc {e} (identity\u02e1 , identity\u02b3) middleFour x y z = begin\n    (x \u2219 y) \u2219 z       \u2248\u27e8 \u2219-cong\u02e1 (identity\u02e1 z) \u27e8\n    (x \u2219 y) \u2219 (e \u2219 z) \u2248\u27e8 middleFour x y e z \u27e9\n    (x \u2219 e) \u2219 (y \u2219 z) \u2248\u27e8 \u2219-cong\u02b3 (identity\u02b3 x) \u27e9\n    x \u2219 (y \u2219 z)       \u220e\n\n  identity\u2227middleFour\u21d2comm : {_+_ : Op\u2082 A} {e : A} \u2192 Identity e _+_ \u2192\n                             _\u2219_ MiddleFourExchange _+_ \u2192\n                             Commutative _\u2219_\n  identity\u2227middleFour\u21d2comm {_+_} {e} (identity\u02e1 , identity\u02b3) middleFour x y\n    = begin\n    x \u2219 y             \u2248\u27e8 cong (identity\u02e1 x) (identity\u02b3 y) \u27e8\n    (e + x) \u2219 (y + e) \u2248\u27e8 middleFour e x y e \u27e9\n    (e + y) \u2219 (x + e) \u2248\u27e8 cong (identity\u02e1 y) (identity\u02b3 x) \u27e9\n    y \u2219 x             \u220e\n\n------------------------------------------------------------------------\n-- SelfInverse\n\nmodule _ {f : Op\u2081 A} (self : SelfInverse f) where\n\n  selfInverse\u21d2involutive : Involutive f\n  selfInverse\u21d2involutive = reflexive\u2227selfInverse\u21d2involutive _\u2248_ refl self\n\n  selfInverse\u21d2congruent : Congruent _\u2248_ _\u2248_ f\n  selfInverse\u21d2congruent {x} {y} x\u2248y = sym (self (begin\n    f (f x) \u2248\u27e8 selfInverse\u21d2involutive x \u27e9\n    x       \u2248\u27e8 x\u2248y \u27e9\n    y       \u220e))\n\n  selfInverse\u21d2inverse\u1d47 : Inverse\u1d47 _\u2248_ _\u2248_ f f\n  selfInverse\u21d2inverse\u1d47 = self \u2218 sym , self \u2218 sym\n\n  selfInverse\u21d2surjective : Surjective _\u2248_ _\u2248_ f\n  selfInverse\u21d2surjective y = f y , self \u2218 sym\n\n  selfInverse\u21d2injective : Injective _\u2248_ _\u2248_ f\n  selfInverse\u21d2injective {x} {y} x\u2248y = begin\n    x       \u2248\u27e8 self x\u2248y \u27e8\n    f (f y) \u2248\u27e8 selfInverse\u21d2involutive y \u27e9\n    y       \u220e\n\n  selfInverse\u21d2bijective : Bijective _\u2248_ _\u2248_ f\n  selfInverse\u21d2bijective = selfInverse\u21d2injective , selfInverse\u21d2surjective\n\n------------------------------------------------------------------------\n-- Magma-like structures\n\nmodule _ {_\u2219_ : Op\u2082 A} (comm : Commutative _\u2219_) where\n\n  comm\u2227cancel\u02e1\u21d2cancel\u02b3 : LeftCancellative _\u2219_ \u2192 RightCancellative _\u2219_\n  comm\u2227cancel\u02e1\u21d2cancel\u02b3 cancel\u02e1 x y z eq = cancel\u02e1 x y z $ begin\n    x \u2219 y \u2248\u27e8 comm x y \u27e9\n    y \u2219 x \u2248\u27e8 eq \u27e9\n    z \u2219 x \u2248\u27e8 comm z x \u27e9\n    x \u2219 z \u220e\n\n  comm\u2227cancel\u02b3\u21d2cancel\u02e1 : RightCancellative _\u2219_ \u2192 LeftCancellative _\u2219_\n  comm\u2227cancel\u02b3\u21d2cancel\u02e1 cancel\u02b3 x y z eq = cancel\u02b3 x y z $ begin\n    y \u2219 x \u2248\u27e8 comm y x \u27e9\n    x \u2219 y \u2248\u27e8 eq \u27e9\n    x \u2219 z \u2248\u27e8 comm x z \u27e9\n    z \u2219 x \u220e\n\n------------------------------------------------------------------------\n-- Monoid-like structures\n\nmodule _ {_\u2219_ : Op\u2082 A} (comm : Commutative _\u2219_) {e : A} where\n\n  comm\u2227id\u02e1\u21d2id\u02b3 : LeftIdentity e _\u2219_ \u2192 RightIdentity e _\u2219_\n  comm\u2227id\u02e1\u21d2id\u02b3 id\u02e1 x = begin\n    x \u2219 e \u2248\u27e8 comm x e \u27e9\n    e \u2219 x \u2248\u27e8 id\u02e1 x \u27e9\n    x     \u220e\n\n  comm\u2227id\u02b3\u21d2id\u02e1 : RightIdentity e _\u2219_ \u2192 LeftIdentity e _\u2219_\n  comm\u2227id\u02b3\u21d2id\u02e1 id\u02b3 x = begin\n    e \u2219 x \u2248\u27e8 comm e x \u27e9\n    x \u2219 e \u2248\u27e8 id\u02b3 x \u27e9\n    x     \u220e\n\n  comm\u2227id\u02e1\u21d2id : LeftIdentity e _\u2219_ \u2192 Identity e _\u2219_\n  comm\u2227id\u02e1\u21d2id id\u02e1 = id\u02e1 , comm\u2227id\u02e1\u21d2id\u02b3 id\u02e1\n\n  comm\u2227id\u02b3\u21d2id : RightIdentity e _\u2219_ \u2192 Identity e _\u2219_\n  comm\u2227id\u02b3\u21d2id id\u02b3 = comm\u2227id\u02b3\u21d2id\u02e1 id\u02b3 , id\u02b3\n\n  comm\u2227ze\u02e1\u21d2ze\u02b3 : LeftZero e _\u2219_ \u2192 RightZero e _\u2219_\n  comm\u2227ze\u02e1\u21d2ze\u02b3 ze\u02e1 x = begin\n    x \u2219 e \u2248\u27e8 comm x e \u27e9\n    e \u2219 x \u2248\u27e8 ze\u02e1 x \u27e9\n    e     \u220e\n\n  comm\u2227ze\u02b3\u21d2ze\u02e1 : RightZero e _\u2219_ \u2192 LeftZero e _\u2219_\n  comm\u2227ze\u02b3\u21d2ze\u02e1 ze\u02b3 x = begin\n    e \u2219 x \u2248\u27e8 comm e x \u27e9\n    x \u2219 e \u2248\u27e8 ze\u02b3 x \u27e9\n    e     \u220e\n\n  comm\u2227ze\u02e1\u21d2ze : LeftZero e _\u2219_ \u2192 Zero e _\u2219_\n  comm\u2227ze\u02e1\u21d2ze ze\u02e1 = ze\u02e1 , comm\u2227ze\u02e1\u21d2ze\u02b3 ze\u02e1\n\n  comm\u2227ze\u02b3\u21d2ze : RightZero e _\u2219_ \u2192 Zero e _\u2219_\n  comm\u2227ze\u02b3\u21d2ze ze\u02b3 = comm\u2227ze\u02b3\u21d2ze\u02e1 ze\u02b3 , ze\u02b3\n\n  comm\u2227almostCancel\u02e1\u21d2almostCancel\u02b3 : AlmostLeftCancellative e _\u2219_ \u2192\n                                     AlmostRightCancellative e _\u2219_\n  comm\u2227almostCancel\u02e1\u21d2almostCancel\u02b3 cancel\u02e1-nonZero x y z x\u2249e yx\u2248zx =\n    cancel\u02e1-nonZero x y z x\u2249e $ begin\n      x \u2219 y \u2248\u27e8 comm x y \u27e9\n      y \u2219 x \u2248\u27e8 yx\u2248zx \u27e9\n      z \u2219 x \u2248\u27e8 comm z x \u27e9\n      x \u2219 z \u220e\n\n  comm\u2227almostCancel\u02b3\u21d2almostCancel\u02e1 : AlmostRightCancellative e _\u2219_ \u2192\n                                     AlmostLeftCancellative e _\u2219_\n  comm\u2227almostCancel\u02b3\u21d2almostCancel\u02e1 cancel\u02b3-nonZero x y z x\u2249e xy\u2248xz =\n    cancel\u02b3-nonZero x y z x\u2249e $ begin\n      y \u2219 x \u2248\u27e8 comm y x \u27e9\n      x \u2219 y \u2248\u27e8 xy\u2248xz \u27e9\n      x \u2219 z \u2248\u27e8 comm x z \u27e9\n      z \u2219 x \u220e\n\n------------------------------------------------------------------------\n-- Group-like structures\n\nmodule _ {_\u2219_ : Op\u2082 A} {_\u207b\u00b9 : Op\u2081 A} {e} (comm : Commutative _\u2219_) where\n\n  comm\u2227inv\u02e1\u21d2inv\u02b3 : LeftInverse e _\u207b\u00b9 _\u2219_ \u2192 RightInverse e _\u207b\u00b9 _\u2219_\n  comm\u2227inv\u02e1\u21d2inv\u02b3 inv\u02e1 x = begin\n    x \u2219 (x \u207b\u00b9) \u2248\u27e8 comm x (x \u207b\u00b9) \u27e9\n    (x \u207b\u00b9) \u2219 x \u2248\u27e8 inv\u02e1 x \u27e9\n    e          \u220e\n\n  comm\u2227inv\u02e1\u21d2inv : LeftInverse e _\u207b\u00b9 _\u2219_ \u2192 Inverse e _\u207b\u00b9 _\u2219_\n  comm\u2227inv\u02e1\u21d2inv inv\u02e1 = inv\u02e1 , comm\u2227inv\u02e1\u21d2inv\u02b3 inv\u02e1\n\n  comm\u2227inv\u02b3\u21d2inv\u02e1 : RightInverse e _\u207b\u00b9 _\u2219_ \u2192 LeftInverse e _\u207b\u00b9 _\u2219_\n  comm\u2227inv\u02b3\u21d2inv\u02e1 inv\u02b3 x = begin\n    (x \u207b\u00b9) \u2219 x \u2248\u27e8 comm (x \u207b\u00b9) x \u27e9\n    x \u2219 (x \u207b\u00b9) \u2248\u27e8 inv\u02b3 x \u27e9\n    e          \u220e\n\n  comm\u2227inv\u02b3\u21d2inv : RightInverse e _\u207b\u00b9 _\u2219_ \u2192 Inverse e _\u207b\u00b9 _\u2219_\n  comm\u2227inv\u02b3\u21d2inv inv\u02b3 = comm\u2227inv\u02b3\u21d2inv\u02e1 inv\u02b3 , inv\u02b3\n\nmodule _ {_\u2219_ : Op\u2082 A} {_\u207b\u00b9 : Op\u2081 A} {e} (cong : Congruent\u2082 _\u2219_) where\n\n  open Congruence cong\n\n  assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique : Associative _\u2219_ \u2192\n                              Identity e _\u2219_ \u2192 RightInverse e _\u207b\u00b9 _\u2219_ \u2192\n                              \u2200 x y \u2192 (x \u2219 y) \u2248 e \u2192 x \u2248 (y \u207b\u00b9)\n  assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique assoc (id\u02e1 , id\u02b3) inv\u02b3 x y eq = begin\n    x                \u2248\u27e8 id\u02b3 x \u27e8\n    x \u2219 e            \u2248\u27e8 \u2219-cong\u02e1 (inv\u02b3 y) \u27e8\n    x \u2219 (y \u2219 (y \u207b\u00b9)) \u2248\u27e8 assoc x y (y \u207b\u00b9) \u27e8\n    (x \u2219 y) \u2219 (y \u207b\u00b9) \u2248\u27e8 \u2219-cong\u02b3 eq \u27e9\n    e \u2219 (y \u207b\u00b9)       \u2248\u27e8 id\u02e1 (y \u207b\u00b9) \u27e9\n    y \u207b\u00b9             \u220e\n\n  assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique : Associative _\u2219_ \u2192\n                              Identity e _\u2219_ \u2192 LeftInverse e _\u207b\u00b9 _\u2219_ \u2192\n                              \u2200 x y \u2192 (x \u2219 y) \u2248 e \u2192 y \u2248 (x \u207b\u00b9)\n  assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique assoc (id\u02e1 , id\u02b3) inv\u02e1 x y eq = begin\n    y                \u2248\u27e8 id\u02e1 y \u27e8\n    e \u2219 y            \u2248\u27e8 \u2219-cong\u02b3 (inv\u02e1 x) \u27e8\n    ((x \u207b\u00b9) \u2219 x) \u2219 y \u2248\u27e8 assoc (x \u207b\u00b9) x y \u27e9\n    (x \u207b\u00b9) \u2219 (x \u2219 y) \u2248\u27e8 \u2219-cong\u02e1 eq \u27e9\n    (x \u207b\u00b9) \u2219 e       \u2248\u27e8 id\u02b3 (x \u207b\u00b9) \u27e9\n    x \u207b\u00b9             \u220e\n\n------------------------------------------------------------------------\n-- Bisemigroup-like structures\n\nmodule _ {_\u2219_ _\u25e6_ : Op\u2082 A}\n         (\u25e6-cong : Congruent\u2082 _\u25e6_)\n         (\u2219-comm : Commutative _\u2219_)\n         where\n\n  open Congruence \u25e6-cong renaming (\u2219-cong\u02e1 to \u25e6-cong\u02e1)\n\n  comm\u2227distr\u02e1\u21d2distr\u02b3 :  _\u2219_ DistributesOver\u02e1 _\u25e6_ \u2192 _\u2219_ DistributesOver\u02b3 _\u25e6_\n  comm\u2227distr\u02e1\u21d2distr\u02b3 distr\u02e1 x y z = begin\n    (y \u25e6 z) \u2219 x       \u2248\u27e8 \u2219-comm (y \u25e6 z) x \u27e9\n    x \u2219 (y \u25e6 z)       \u2248\u27e8 distr\u02e1 x y z \u27e9\n    (x \u2219 y) \u25e6 (x \u2219 z) \u2248\u27e8 \u25e6-cong (\u2219-comm x y) (\u2219-comm x z) \u27e9\n    (y \u2219 x) \u25e6 (z \u2219 x) \u220e\n\n  comm\u2227distr\u02b3\u21d2distr\u02e1 : _\u2219_ DistributesOver\u02b3 _\u25e6_ \u2192 _\u2219_ DistributesOver\u02e1 _\u25e6_\n  comm\u2227distr\u02b3\u21d2distr\u02e1 distr\u02e1 x y z = begin\n    x \u2219 (y \u25e6 z)       \u2248\u27e8 \u2219-comm x (y \u25e6 z) \u27e9\n    (y \u25e6 z) \u2219 x       \u2248\u27e8 distr\u02e1 x y z \u27e9\n    (y \u2219 x) \u25e6 (z \u2219 x) \u2248\u27e8 \u25e6-cong (\u2219-comm y x) (\u2219-comm z x) \u27e9\n    (x \u2219 y) \u25e6 (x \u2219 z) \u220e\n\n  comm\u2227distr\u02e1\u21d2distr :  _\u2219_ DistributesOver\u02e1 _\u25e6_ \u2192 _\u2219_ DistributesOver _\u25e6_\n  comm\u2227distr\u02e1\u21d2distr distr\u02e1 = distr\u02e1 , comm\u2227distr\u02e1\u21d2distr\u02b3 distr\u02e1\n\n  comm\u2227distr\u02b3\u21d2distr :  _\u2219_ DistributesOver\u02b3 _\u25e6_ \u2192 _\u2219_ DistributesOver _\u25e6_\n  comm\u2227distr\u02b3\u21d2distr distr\u02b3 = comm\u2227distr\u02b3\u21d2distr\u02e1 distr\u02b3 , distr\u02b3\n\n  comm\u21d2sym[distrib\u02e1] : \u2200 x \u2192 Symmetric (\u03bb y z \u2192 (x \u25e6 (y \u2219 z)) \u2248 ((x \u25e6 y) \u2219 (x \u25e6 z)))\n  comm\u21d2sym[distrib\u02e1] x {y} {z} prf = begin\n    x \u25e6 (z \u2219 y)       \u2248\u27e8 \u25e6-cong\u02e1 (\u2219-comm z y) \u27e9\n    x \u25e6 (y \u2219 z)       \u2248\u27e8 prf \u27e9\n    (x \u25e6 y) \u2219 (x \u25e6 z) \u2248\u27e8 \u2219-comm (x \u25e6 y) (x \u25e6 z) \u27e9\n    (x \u25e6 z) \u2219 (x \u25e6 y) \u220e\n\n\nmodule _ {_\u2219_ _\u25e6_ : Op\u2082 A}\n         (\u2219-cong  : Congruent\u2082 _\u2219_)\n         (\u2219-assoc : Associative _\u2219_)\n         (\u25e6-comm  : Commutative _\u25e6_)\n         where\n\n  open Congruence \u2219-cong\n\n  distrib\u2227absorbs\u21d2distrib\u02e1 : _\u2219_ Absorbs _\u25e6_ \u2192\n                             _\u25e6_ Absorbs _\u2219_ \u2192\n                             _\u25e6_ DistributesOver _\u2219_ \u2192\n                             _\u2219_ DistributesOver\u02e1 _\u25e6_\n  distrib\u2227absorbs\u21d2distrib\u02e1 \u2219-absorbs-\u25e6 \u25e6-absorbs-\u2219 (\u25e6-distrib\u02e1-\u2219 , \u25e6-distrib\u02b3-\u2219) x y z = begin\n    x \u2219 (y \u25e6 z)                    \u2248\u27e8 \u2219-cong\u02b3 (\u2219-absorbs-\u25e6 _ _) \u27e8\n    (x \u2219 (x \u25e6 y)) \u2219 (y \u25e6 z)        \u2248\u27e8  \u2219-cong\u02b3 (\u2219-cong\u02e1 (\u25e6-comm _ _)) \u27e9\n    (x \u2219 (y \u25e6 x)) \u2219 (y \u25e6 z)        \u2248\u27e8  \u2219-assoc _ _ _ \u27e9\n    x \u2219 ((y \u25e6 x) \u2219 (y \u25e6 z))        \u2248\u27e8 \u2219-cong\u02e1 (\u25e6-distrib\u02e1-\u2219 _ _ _) \u27e8\n    x \u2219 (y \u25e6 (x \u2219 z))              \u2248\u27e8 \u2219-cong\u02b3 (\u25e6-absorbs-\u2219 _ _) \u27e8\n    (x \u25e6 (x \u2219 z)) \u2219 (y \u25e6 (x \u2219 z))  \u2248\u27e8 \u25e6-distrib\u02b3-\u2219 _ _ _ \u27e8\n    (x \u2219 y) \u25e6 (x \u2219 z)              \u220e\n\n------------------------------------------------------------------------\n-- Ring-like structures\n\nmodule _ {_+_ _*_ : Op\u2082 A}\n         {_\u207b\u00b9 : Op\u2081 A} {0# : A}\n         (+-cong : Congruent\u2082 _+_)\n         (*-cong : Congruent\u2082 _*_)\n         where\n\n  open Congruence +-cong renaming (\u2219-cong\u02e1 to +-cong\u02e1; \u2219-cong\u02b3 to +-cong\u02b3)\n\n  open Congruence *-cong renaming (\u2219-cong\u02e1 to *-cong\u02e1; \u2219-cong\u02b3 to *-cong\u02b3)\n\n  assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 : Associative _+_ \u2192 _*_ DistributesOver\u02b3 _+_ \u2192\n                                RightIdentity 0# _+_ \u2192 RightInverse 0# _\u207b\u00b9 _+_ \u2192\n                                LeftZero 0# _*_\n  assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 +-assoc distrib\u02b3 id\u02b3 inv\u02b3  x = begin\n    0# * x                                 \u2248\u27e8 id\u02b3 _ \u27e8\n    (0# * x) + 0#                          \u2248\u27e8 +-cong\u02e1 (inv\u02b3 _) \u27e8\n    (0# * x) + ((0# * x)  + ((0# * x)\u207b\u00b9))  \u2248\u27e8 +-assoc _ _ _ \u27e8\n    ((0# * x) +  (0# * x)) + ((0# * x)\u207b\u00b9)  \u2248\u27e8 +-cong\u02b3 (distrib\u02b3 _ _ _) \u27e8\n    ((0# + 0#) * x) + ((0# * x)\u207b\u00b9)         \u2248\u27e8 +-cong\u02b3 (*-cong\u02b3 (id\u02b3 _)) \u27e9\n    (0# * x) + ((0# * x)\u207b\u00b9)                \u2248\u27e8 inv\u02b3 _ \u27e9\n    0#                                     \u220e\n\n  assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 : Associative _+_ \u2192 _*_ DistributesOver\u02e1 _+_ \u2192\n                                RightIdentity 0# _+_ \u2192 RightInverse 0# _\u207b\u00b9 _+_ \u2192\n                                RightZero 0# _*_\n  assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 +-assoc distrib\u02e1 id\u02b3 inv\u02b3  x = begin\n     x * 0#                                \u2248\u27e8 id\u02b3 _ \u27e8\n     (x * 0#) + 0#                         \u2248\u27e8 +-cong\u02e1 (inv\u02b3 _) \u27e8\n     (x * 0#) + ((x * 0#) + ((x * 0#)\u207b\u00b9))  \u2248\u27e8 +-assoc _ _ _ \u27e8\n     ((x * 0#) + (x * 0#)) + ((x * 0#)\u207b\u00b9)  \u2248\u27e8 +-cong\u02b3 (distrib\u02e1 _ _ _) \u27e8\n     (x * (0# + 0#)) + ((x * 0#)\u207b\u00b9)        \u2248\u27e8 +-cong\u02b3 (*-cong\u02e1 (id\u02b3 _)) \u27e9\n     ((x * 0#) + ((x * 0#)\u207b\u00b9))             \u2248\u27e8 inv\u02b3 _ \u27e9\n     0#                                    \u220e\n\n------------------------------------------------------------------------\n-- Without Loss of Generality\n\nmodule _ {p} {f : Op\u2082 A} {P : Pred A p}\n         (\u2248-subst : Substitutive _\u2248_ p)\n         (comm : Commutative f)\n         where\n\n  subst\u2227comm\u21d2sym : Symmetric (\u03bb a b \u2192 P (f a b))\n  subst\u2227comm\u21d2sym = \u2248-subst P (comm _ _)\n\n  wlog : \u2200 {r} {_R_ : Rel _ r} \u2192 Total _R_ \u2192\n         (\u2200 a b \u2192 a R b \u2192 P (f a b)) \u2192\n         \u2200 a b \u2192 P (f a b)\n  wlog r-total = Bin.wlog r-total subst\u2227comm\u21d2sym\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\ncomm+assoc\u21d2middleFour = comm\u2227assoc\u21d2middleFour\n{-# WARNING_ON_USAGE comm+assoc\u21d2middleFour\n\"Warning: comm+assoc\u21d2middleFour was deprecated in v2.0.\nPlease use comm\u2227assoc\u21d2middleFour instead.\"\n#-}\nidentity+middleFour\u21d2assoc = identity\u2227middleFour\u21d2assoc\n{-# WARNING_ON_USAGE identity+middleFour\u21d2assoc\n\"Warning: identity+middleFour\u21d2assoc was deprecated in v2.0.\nPlease use identity\u2227middleFour\u21d2assoc instead.\"\n#-}\nidentity+middleFour\u21d2comm = identity\u2227middleFour\u21d2comm\n{-# WARNING_ON_USAGE identity+middleFour\u21d2comm\n\"Warning: identity+middleFour\u21d2comm was deprecated in v2.0.\nPlease use identity\u2227middleFour\u21d2comm instead.\"\n#-}\ncomm+cancel\u02e1\u21d2cancel\u02b3 = comm\u2227cancel\u02e1\u21d2cancel\u02b3\n{-# WARNING_ON_USAGE comm+cancel\u02e1\u21d2cancel\u02b3\n\"Warning: comm+cancel\u02e1\u21d2cancel\u02b3 was deprecated in v2.0.\nPlease use comm\u2227cancel\u02e1\u21d2cancel\u02b3 instead.\"\n#-}\ncomm+cancel\u02b3\u21d2cancel\u02e1 = comm\u2227cancel\u02b3\u21d2cancel\u02e1\n{-# WARNING_ON_USAGE comm+cancel\u02b3\u21d2cancel\u02e1\n\"Warning: comm+cancel\u02b3\u21d2cancel\u02e1 was deprecated in v2.0.\nPlease use comm\u2227cancel\u02b3\u21d2cancel\u02e1 instead.\"\n#-}\ncomm+id\u02e1\u21d2id\u02b3 = comm\u2227id\u02e1\u21d2id\u02b3\n{-# WARNING_ON_USAGE comm+id\u02e1\u21d2id\u02b3\n\"Warning: comm+id\u02e1\u21d2id\u02b3 was deprecated in v2.0.\nPlease use comm\u2227id\u02e1\u21d2id\u02b3 instead.\"\n#-}\ncomm+id\u02b3\u21d2id\u02e1 = comm\u2227id\u02b3\u21d2id\u02e1\n{-# WARNING_ON_USAGE comm+id\u02b3\u21d2id\u02e1\n\"Warning: comm+id\u02b3\u21d2id\u02e1 was deprecated in v2.0.\nPlease use comm\u2227id\u02b3\u21d2id\u02e1 instead.\"\n#-}\ncomm+ze\u02e1\u21d2ze\u02b3 = comm\u2227ze\u02e1\u21d2ze\u02b3\n{-# WARNING_ON_USAGE comm+ze\u02e1\u21d2ze\u02b3\n\"Warning: comm+ze\u02e1\u21d2ze\u02b3 was deprecated in v2.0.\nPlease use comm\u2227ze\u02e1\u21d2ze\u02b3 instead.\"\n#-}\ncomm+ze\u02b3\u21d2ze\u02e1 = comm\u2227ze\u02b3\u21d2ze\u02e1\n{-# WARNING_ON_USAGE comm+ze\u02b3\u21d2ze\u02e1\n\"Warning: comm+ze\u02b3\u21d2ze\u02e1 was deprecated in v2.0.\nPlease use comm\u2227ze\u02b3\u21d2ze\u02e1 instead.\"\n#-}\ncomm+almostCancel\u02e1\u21d2almostCancel\u02b3 = comm\u2227almostCancel\u02e1\u21d2almostCancel\u02b3\n{-# WARNING_ON_USAGE comm+almostCancel\u02e1\u21d2almostCancel\u02b3\n\"Warning: comm+almostCancel\u02e1\u21d2almostCancel\u02b3 was deprecated in v2.0.\nPlease use comm\u2227almostCancel\u02e1\u21d2almostCancel\u02b3 instead.\"\n#-}\ncomm+almostCancel\u02b3\u21d2almostCancel\u02e1 = comm\u2227almostCancel\u02b3\u21d2almostCancel\u02e1\n{-# WARNING_ON_USAGE comm+almostCancel\u02b3\u21d2almostCancel\u02e1\n\"Warning: comm+almostCancel\u02b3\u21d2almostCancel\u02e1 was deprecated in v2.0.\nPlease use comm\u2227almostCancel\u02b3\u21d2almostCancel\u02e1 instead.\"\n#-}\ncomm+inv\u02e1\u21d2inv\u02b3 = comm\u2227inv\u02e1\u21d2inv\u02b3\n{-# WARNING_ON_USAGE comm+inv\u02e1\u21d2inv\u02b3\n\"Warning: comm+inv\u02e1\u21d2inv\u02b3 was deprecated in v2.0.\nPlease use comm\u2227inv\u02e1\u21d2inv\u02b3 instead.\"\n#-}\ncomm+inv\u02b3\u21d2inv\u02e1 = comm\u2227inv\u02b3\u21d2inv\u02e1\n{-# WARNING_ON_USAGE comm+inv\u02b3\u21d2inv\u02e1\n\"Warning: comm+inv\u02b3\u21d2inv\u02e1 was deprecated in v2.0.\nPlease use comm\u2227inv\u02b3\u21d2inv\u02e1 instead.\"\n#-}\ncomm+inv\u02e1\u21d2inv = comm\u2227inv\u02e1\u21d2inv\n{-# WARNING_ON_USAGE comm+inv\u02e1\u21d2inv\n\"Warning: comm+inv\u02e1\u21d2inv was deprecated in v2.0.\nPlease use comm\u2227inv\u02e1\u21d2inv instead.\"\n#-}\ncomm+inv\u02b3\u21d2inv = comm\u2227inv\u02b3\u21d2inv\n{-# WARNING_ON_USAGE comm+inv\u02b3\u21d2inv\n\"Warning: comm+inv\u02b3\u21d2inv was deprecated in v2.0.\nPlease use comm\u2227inv\u02b3\u21d2inv instead.\"\n#-}\ncomm+distr\u02e1\u21d2distr\u02b3 = comm\u2227distr\u02e1\u21d2distr\u02b3\n{-# WARNING_ON_USAGE comm+distr\u02e1\u21d2distr\u02b3\n\"Warning: comm+distr\u02e1\u21d2distr\u02b3 was deprecated in v2.0.\nPlease use comm\u2227distr\u02e1\u21d2distr\u02b3 instead.\"\n#-}\ncomm+distr\u02b3\u21d2distr\u02e1 = comm\u2227distr\u02b3\u21d2distr\u02e1\n{-# WARNING_ON_USAGE comm+distr\u02b3\u21d2distr\u02e1\n\"Warning: comm+distr\u02b3\u21d2distr\u02e1 was deprecated in v2.0.\nPlease use comm\u2227distr\u02b3\u21d2distr\u02e1 instead.\"\n#-}\nassoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1 = assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1\n{-# WARNING_ON_USAGE assoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1\n\"Warning: assoc+distrib\u02b3+id\u02b3+inv\u02b3\u21d2ze\u02e1 was deprecated in v2.0.\nPlease use assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 instead.\"\n#-}\nassoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3 = assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3\n{-# WARNING_ON_USAGE assoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3\n\"Warning: assoc+distrib\u02e1+id\u02b3+inv\u02b3\u21d2ze\u02b3 was deprecated in v2.0.\nPlease use assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 instead.\"\n#-}\nassoc+id+inv\u02b3\u21d2inv\u02e1-unique = assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique\n{-# WARNING_ON_USAGE assoc+id+inv\u02b3\u21d2inv\u02e1-unique\n\"Warning: assoc+id+inv\u02b3\u21d2inv\u02e1-unique was deprecated in v2.0.\nPlease use assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique instead.\"\n#-}\nassoc+id+inv\u02e1\u21d2inv\u02b3-unique = assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique\n{-# WARNING_ON_USAGE assoc+id+inv\u02e1\u21d2inv\u02b3-unique\n\"Warning: assoc+id+inv\u02e1\u21d2inv\u02b3-unique was deprecated in v2.0.\nPlease use assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique instead.\"\n#-}\nsubst+comm\u21d2sym = subst\u2227comm\u21d2sym\n{-# WARNING_ON_USAGE subst+comm\u21d2sym\n\"Warning: subst+comm\u21d2sym was deprecated in v2.0.\nPlease use subst\u2227comm\u21d2sym instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Construct/NaturalChoice/Base/","title":"Algebra.Construct.NaturalChoice.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definition of an operator that computes the min/max value\n-- with respect to a total preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Core using (Op\u2082)\nopen import Level as L hiding (_\u2294_)\nopen import Function.Base using (flip)\nopen import Relation.Binary.Bundles using (TotalPreorder)\nopen import Relation.Binary.Construct.Flip.EqAndOrd using ()\n  renaming (totalPreorder to flipOrder)\nimport Relation.Binary.Properties.TotalOrder as TotalOrderProperties\n\nmodule Algebra.Construct.NaturalChoice.Base where\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 : Level\n    O : TotalPreorder a \u2113\u2081 \u2113\u2082\n\n------------------------------------------------------------------------\n-- Definition\n\nmodule _ (O : TotalPreorder a \u2113\u2081 \u2113\u2082) where\n  open TotalPreorder O renaming (_\u2272_ to _\u2264_)\n  private _\u2265_ = flip _\u2264_\n\n  record MinOperator : Set (a L.\u2294 \u2113\u2081 L.\u2294 \u2113\u2082) where\n    infixl 7 _\u2293_\n    field\n      _\u2293_       : Op\u2082 Carrier\n      x\u2264y\u21d2x\u2293y\u2248x : \u2200 {x y} \u2192 x \u2264 y \u2192 x \u2293 y \u2248 x\n      x\u2265y\u21d2x\u2293y\u2248y : \u2200 {x y} \u2192 x \u2265 y \u2192 x \u2293 y \u2248 y\n\n  record MaxOperator : Set (a L.\u2294 \u2113\u2081 L.\u2294 \u2113\u2082) where\n    infixl 6 _\u2294_\n    field\n      _\u2294_       : Op\u2082 Carrier\n      x\u2264y\u21d2x\u2294y\u2248y : \u2200 {x y} \u2192 x \u2264 y \u2192 x \u2294 y \u2248 y\n      x\u2265y\u21d2x\u2294y\u2248x : \u2200 {x y} \u2192 x \u2265 y \u2192 x \u2294 y \u2248 x\n\n------------------------------------------------------------------------\n-- Properties\n\nMinOp\u21d2MaxOp : MinOperator O \u2192 MaxOperator (flipOrder O)\nMinOp\u21d2MaxOp minOp = record\n  { _\u2294_       = _\u2293_\n  ; x\u2264y\u21d2x\u2294y\u2248y = x\u2265y\u21d2x\u2293y\u2248y\n  ; x\u2265y\u21d2x\u2294y\u2248x = x\u2264y\u21d2x\u2293y\u2248x\n  } where open MinOperator minOp\n\nMaxOp\u21d2MinOp : MaxOperator O \u2192 MinOperator (flipOrder O)\nMaxOp\u21d2MinOp maxOp = record\n  { _\u2293_       = _\u2294_\n  ; x\u2264y\u21d2x\u2293y\u2248x = x\u2265y\u21d2x\u2294y\u2248x\n  ; x\u2265y\u21d2x\u2293y\u2248y = x\u2264y\u21d2x\u2294y\u2248y\n  } where open MaxOperator maxOp\n</pre>"},{"location":"md/Algebra/Construct/NaturalChoice/MaxOp/","title":"Algebra.Construct.NaturalChoice.MaxOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of a max operator derived from a spec over a total\n-- preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Construct.NaturalChoice.Base using (MaxOperator; MaxOp\u21d2MinOp)\nopen import Relation.Binary.Bundles using (TotalPreorder)\n\nmodule Algebra.Construct.NaturalChoice.MaxOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082} (maxOp : MaxOperator O)\n  where\n\nimport Algebra.Construct.NaturalChoice.MinOp as MinOp\nopen import Algebra.Core using (Op\u2082)\nopen import Function.Base using (flip)\nopen MaxOperator maxOp\nopen import Relation.Binary.Core using (_Preserves_\u27f6_)\nopen import Relation.Binary.Construct.Flip.EqAndOrd using ()\n  renaming (totalPreorder to flipOrder)\nopen TotalPreorder O renaming (Carrier to A; _\u2272_ to _\u2264_)\n\n-- Max is just min with a flipped order\n\nprivate\n  module Min = MinOp (MaxOp\u21d2MinOp maxOp)\n\nopen Min public\n  using ()\n  renaming\n  ( \u2293-cong       to  \u2294-cong\n  ; \u2293-cong\u02b3      to  \u2294-cong\u02b3\n  ; \u2293-cong\u02e1      to  \u2294-cong\u02e1\n  ; \u2293-idem       to  \u2294-idem\n  ; \u2293-sel        to  \u2294-sel\n  ; \u2293-assoc      to  \u2294-assoc\n  ; \u2293-comm       to  \u2294-comm\n\n  ; \u2293-identity\u02e1  to  \u2294-identity\u02e1\n  ; \u2293-identity\u02b3  to  \u2294-identity\u02b3\n  ; \u2293-identity   to  \u2294-identity\n  ; \u2293-zero\u02e1      to  \u2294-zero\u02e1\n  ; \u2293-zero\u02b3      to  \u2294-zero\u02b3\n  ; \u2293-zero       to  \u2294-zero\n\n  ; \u2293-isMagma                 to  \u2294-isMagma\n  ; \u2293-isSemigroup             to  \u2294-isSemigroup\n  ; \u2293-isCommutativeSemigroup  to  \u2294-isCommutativeSemigroup\n  ; \u2293-isBand                  to  \u2294-isBand\n  ; \u2293-isMonoid                to  \u2294-isMonoid\n  ; \u2293-isSelectiveMagma        to  \u2294-isSelectiveMagma\n\n  ; \u2293-magma                   to  \u2294-magma\n  ; \u2293-semigroup               to  \u2294-semigroup\n  ; \u2293-commutativeSemigroup    to  \u2294-commutativeSemigroup\n  ; \u2293-band                    to  \u2294-band\n  ; \u2293-monoid                  to  \u2294-monoid\n  ; \u2293-selectiveMagma          to  \u2294-selectiveMagma\n\n  ; x\u2293y\u2248y\u21d2y\u2264x  to x\u2294y\u2248y\u21d2x\u2264y\n  ; x\u2293y\u2248x\u21d2x\u2264y  to x\u2294y\u2248x\u21d2y\u2264x\n  ; x\u2293y\u2264x      to x\u2264x\u2294y\n  ; x\u2293y\u2264y      to x\u2264y\u2294x\n  ; x\u2264y\u21d2x\u2293z\u2264y  to x\u2264y\u21d2x\u2264y\u2294z\n  ; x\u2264y\u21d2z\u2293x\u2264y  to x\u2264y\u21d2x\u2264z\u2294y\n  ; x\u2264y\u2293z\u21d2x\u2264y  to x\u2294y\u2264z\u21d2x\u2264z\n  ; x\u2264y\u2293z\u21d2x\u2264z  to x\u2294y\u2264z\u21d2y\u2264z\n\n  ; \u2293-glb              to  \u2294-lub\n  ; \u2293-triangulate      to  \u2294-triangulate\n  ; \u2293-mono-\u2264           to  \u2294-mono-\u2264\n  ; \u2293-mono\u02e1-\u2264          to  \u2294-mono\u02e1-\u2264\n  ; \u2293-mono\u02b3-\u2264          to  \u2294-mono\u02b3-\u2264\n  )\n\nmono-\u2264-distrib-\u2294 : \u2200 {f} \u2192 f Preserves _\u2248_ \u27f6 _\u2248_ \u2192 f Preserves _\u2264_ \u27f6 _\u2264_ \u2192\n                   \u2200 x y \u2192 f (x \u2294 y) \u2248 f x \u2294 f y\nmono-\u2264-distrib-\u2294 cong pres = Min.mono-\u2264-distrib-\u2293 cong pres\n</pre>"},{"location":"md/Algebra/Construct/NaturalChoice/MinMaxOp/","title":"Algebra.Construct.NaturalChoice.MinMaxOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of min and max operators specified over a total\n-- preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Construct.NaturalChoice.Base using (MinOperator; MaxOperator)\nopen import Relation.Binary.Bundles using (TotalPreorder)\n\nmodule Algebra.Construct.NaturalChoice.MinMaxOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082}\n  (minOp : MinOperator O)\n  (maxOp : MaxOperator O)\n  where\n\nopen import Data.Sum.Base as Sum using (inj\u2081; inj\u2082; [_,_])\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (id; _\u2218_; flip)\nopen import Relation.Binary.Core using (_Preserves_\u27f6_)\n\nopen TotalPreorder O renaming\n  ( Carrier   to A\n  ; _\u2272_       to _\u2264_\n  ; \u2272-resp-\u2248  to \u2264-resp-\u2248\n  ; \u2272-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n  ; \u2272-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n  )\nopen MinOperator minOp\nopen MaxOperator maxOp\n\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Structures _\u2248_\nopen import Algebra.Consequences.Setoid Eq.setoid\nopen import Relation.Binary.Reasoning.Preorder preorder\n\n------------------------------------------------------------------------\n-- Re-export properties of individual operators\n\nopen import Algebra.Construct.NaturalChoice.MinOp minOp public\nopen import Algebra.Construct.NaturalChoice.MaxOp maxOp public\n\n------------------------------------------------------------------------\n-- Joint algebraic structures\n\n\u2293-distrib\u02e1-\u2294 : _\u2293_ DistributesOver\u02e1 _\u2294_\n\u2293-distrib\u02e1-\u2294 x y z with total y z\n... | inj\u2081 y\u2264z = begin-equality\n  x \u2293 (y \u2294 z)       \u2248\u27e8  \u2293-cong\u02e1 x (x\u2264y\u21d2x\u2294y\u2248y y\u2264z) \u27e9\n  x \u2293 z             \u2248\u27e8 x\u2264y\u21d2x\u2294y\u2248y (\u2293-mono\u02b3-\u2264 x y\u2264z) \u27e8\n  (x \u2293 y) \u2294 (x \u2293 z) \u220e\n... | inj\u2082 y\u2265z = begin-equality\n  x \u2293 (y \u2294 z)       \u2248\u27e8  \u2293-cong\u02e1 x (x\u2265y\u21d2x\u2294y\u2248x y\u2265z) \u27e9\n  x \u2293 y             \u2248\u27e8 x\u2265y\u21d2x\u2294y\u2248x (\u2293-mono\u02b3-\u2264 x y\u2265z) \u27e8\n  (x \u2293 y) \u2294 (x \u2293 z) \u220e\n\n\u2293-distrib\u02b3-\u2294 : _\u2293_ DistributesOver\u02b3 _\u2294_\n\u2293-distrib\u02b3-\u2294 = comm\u2227distr\u02e1\u21d2distr\u02b3 \u2294-cong \u2293-comm \u2293-distrib\u02e1-\u2294\n\n\u2293-distrib-\u2294 : _\u2293_ DistributesOver _\u2294_\n\u2293-distrib-\u2294 = \u2293-distrib\u02e1-\u2294 , \u2293-distrib\u02b3-\u2294\n\n\u2294-distrib\u02e1-\u2293 : _\u2294_ DistributesOver\u02e1 _\u2293_\n\u2294-distrib\u02e1-\u2293 x y z with total y z\n... | inj\u2081 y\u2264z = begin-equality\n  x \u2294 (y \u2293 z)       \u2248\u27e8  \u2294-cong\u02e1 x (x\u2264y\u21d2x\u2293y\u2248x y\u2264z) \u27e9\n  x \u2294 y             \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x (\u2294-mono\u02b3-\u2264 x y\u2264z) \u27e8\n  (x \u2294 y) \u2293 (x \u2294 z) \u220e\n... | inj\u2082 y\u2265z = begin-equality\n  x \u2294 (y \u2293 z)       \u2248\u27e8  \u2294-cong\u02e1 x (x\u2265y\u21d2x\u2293y\u2248y y\u2265z) \u27e9\n  x \u2294 z             \u2248\u27e8 x\u2265y\u21d2x\u2293y\u2248y (\u2294-mono\u02b3-\u2264 x y\u2265z) \u27e8\n  (x \u2294 y) \u2293 (x \u2294 z) \u220e\n\n\u2294-distrib\u02b3-\u2293 : _\u2294_ DistributesOver\u02b3 _\u2293_\n\u2294-distrib\u02b3-\u2293 = comm\u2227distr\u02e1\u21d2distr\u02b3 \u2293-cong \u2294-comm \u2294-distrib\u02e1-\u2293\n\n\u2294-distrib-\u2293 : _\u2294_ DistributesOver _\u2293_\n\u2294-distrib-\u2293 = \u2294-distrib\u02e1-\u2293 , \u2294-distrib\u02b3-\u2293\n\n\u2293-absorbs-\u2294 : _\u2293_ Absorbs _\u2294_\n\u2293-absorbs-\u2294 x y with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  x \u2293 (x \u2294 y)  \u2248\u27e8 \u2293-cong\u02e1 x (x\u2264y\u21d2x\u2294y\u2248y x\u2264y) \u27e9\n  x \u2293 y        \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x x\u2264y \u27e9\n  x            \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  x \u2293 (x \u2294 y)  \u2248\u27e8 \u2293-cong\u02e1 x (x\u2265y\u21d2x\u2294y\u2248x y\u2264x) \u27e9\n  x \u2293 x        \u2248\u27e8 \u2293-idem x \u27e9\n  x            \u220e\n\n\u2294-absorbs-\u2293 : _\u2294_ Absorbs _\u2293_\n\u2294-absorbs-\u2293 x y with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  x \u2294 (x \u2293 y)  \u2248\u27e8 \u2294-cong\u02e1 x (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) \u27e9\n  x \u2294 x        \u2248\u27e8 \u2294-idem x \u27e9\n  x            \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  x \u2294 (x \u2293 y)  \u2248\u27e8 \u2294-cong\u02e1 x (x\u2265y\u21d2x\u2293y\u2248y y\u2264x) \u27e9\n  x \u2294 y        \u2248\u27e8 x\u2265y\u21d2x\u2294y\u2248x y\u2264x \u27e9\n  x            \u220e\n\n\u2294-\u2293-absorptive : Absorptive _\u2294_ _\u2293_\n\u2294-\u2293-absorptive = \u2294-absorbs-\u2293 , \u2293-absorbs-\u2294\n\n\u2293-\u2294-absorptive : Absorptive _\u2293_ _\u2294_\n\u2293-\u2294-absorptive = \u2293-absorbs-\u2294 , \u2294-absorbs-\u2293\n\n------------------------------------------------------------------------\n-- Other joint properties\n\nprivate _\u2265_ = flip _\u2264_\n\nantimono-\u2264-distrib-\u2293 : \u2200 {f} \u2192 f Preserves _\u2248_ \u27f6 _\u2248_ \u2192 f Preserves _\u2264_ \u27f6 _\u2265_ \u2192\n                       \u2200 x y \u2192 f (x \u2293 y) \u2248 f x \u2294 f y\nantimono-\u2264-distrib-\u2293 {f} cong antimono x y with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  f (x \u2293 y)  \u2248\u27e8 cong (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) \u27e9\n  f x        \u2248\u27e8 x\u2265y\u21d2x\u2294y\u2248x (antimono x\u2264y) \u27e8\n  f x \u2294 f y  \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  f (x \u2293 y)  \u2248\u27e8 cong (x\u2265y\u21d2x\u2293y\u2248y y\u2264x) \u27e9\n  f y        \u2248\u27e8 x\u2264y\u21d2x\u2294y\u2248y (antimono y\u2264x) \u27e8\n  f x \u2294 f y  \u220e\n\nantimono-\u2264-distrib-\u2294 : \u2200 {f} \u2192 f Preserves _\u2248_ \u27f6 _\u2248_ \u2192 f Preserves _\u2264_ \u27f6 _\u2265_ \u2192\n                       \u2200 x y \u2192 f (x \u2294 y) \u2248 f x \u2293 f y\nantimono-\u2264-distrib-\u2294 {f} cong antimono x y with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  f (x \u2294 y)  \u2248\u27e8 cong (x\u2264y\u21d2x\u2294y\u2248y x\u2264y) \u27e9\n  f y        \u2248\u27e8 x\u2265y\u21d2x\u2293y\u2248y (antimono x\u2264y) \u27e8\n  f x \u2293 f y  \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  f (x \u2294 y)  \u2248\u27e8 cong (x\u2265y\u21d2x\u2294y\u2248x y\u2264x) \u27e9\n  f x        \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x (antimono y\u2264x) \u27e8\n  f x \u2293 f y  \u220e\n\nx\u2293y\u2264x\u2294y : \u2200 x y \u2192 x \u2293 y \u2264 x \u2294 y\nx\u2293y\u2264x\u2294y x y = begin\n  x \u2293 y \u223c\u27e8 x\u2293y\u2264x x y \u27e9\n  x     \u223c\u27e8 x\u2264x\u2294y x y \u27e9\n  x \u2294 y \u220e\n</pre>"},{"location":"md/Algebra/Construct/NaturalChoice/MinOp/","title":"Algebra.Construct.NaturalChoice.MinOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of a min operator derived from a spec over a total\n-- preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (TotalPreorder)\nopen import Algebra.Construct.NaturalChoice.Base using (MinOperator; MinOp\u21d2MaxOp)\n\nmodule Algebra.Construct.NaturalChoice.MinOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082} (minOp : MinOperator O) where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Algebra.Bundles\n  using (RawMagma; Magma; Semigroup; Band; CommutativeSemigroup; SelectiveMagma; Monoid)\nopen import Data.Sum.Base as Sum using (inj\u2081; inj\u2082; [_,_])\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (id; _\u2218_)\nopen import Relation.Binary.Core using (_Preserves_\u27f6_; _Preserves\u2082_\u27f6_\u27f6_)\nopen import Relation.Binary.Definitions using (Maximum; Minimum)\n\nopen TotalPreorder O renaming\n  ( Carrier   to A\n  ; _\u2272_       to _\u2264_\n  ; \u2272-resp-\u2248  to \u2264-resp-\u2248\n  ; \u2272-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n  ; \u2272-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n  )\nopen MinOperator minOp\n\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Structures _\u2248_\nopen import Relation.Binary.Reasoning.Preorder preorder\n\n------------------------------------------------------------------------\n-- Helpful properties\n\nx\u2293y\u2264x : \u2200 x y \u2192 x \u2293 y \u2264 x\nx\u2293y\u2264x x y with total x y\n... | inj\u2081 x\u2264y = reflexive (x\u2264y\u21d2x\u2293y\u2248x x\u2264y)\n... | inj\u2082 y\u2264x = \u2264-resp\u02e1-\u2248 (Eq.sym (x\u2265y\u21d2x\u2293y\u2248y y\u2264x)) y\u2264x\n\nx\u2293y\u2264y : \u2200 x y \u2192 x \u2293 y \u2264 y\nx\u2293y\u2264y x y with total x y\n... | inj\u2081 x\u2264y = \u2264-resp\u02e1-\u2248 (Eq.sym (x\u2264y\u21d2x\u2293y\u2248x x\u2264y)) x\u2264y\n... | inj\u2082 y\u2264x = reflexive (x\u2265y\u21d2x\u2293y\u2248y y\u2264x)\n\n------------------------------------------------------------------------\n-- Algebraic properties\n\n\u2293-comm : Commutative _\u2293_\n\u2293-comm x y with total x y\n... | inj\u2081 x\u2264y = Eq.trans (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) (Eq.sym (x\u2265y\u21d2x\u2293y\u2248y x\u2264y))\n... | inj\u2082 y\u2264x = Eq.trans (x\u2265y\u21d2x\u2293y\u2248y y\u2264x) (Eq.sym (x\u2264y\u21d2x\u2293y\u2248x y\u2264x))\n\n\u2293-cong\u02e1 : \u2200 x \u2192 Congruent\u2081 (x \u2293_)\n\u2293-cong\u02e1 x {y} {r} y\u2248r with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  x \u2293 y  \u2248\u27e8  x\u2264y\u21d2x\u2293y\u2248x x\u2264y \u27e9\n  x      \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x (\u2264-resp\u02b3-\u2248 y\u2248r x\u2264y) \u27e8\n  x \u2293 r  \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  x \u2293 y  \u2248\u27e8  x\u2265y\u21d2x\u2293y\u2248y y\u2264x \u27e9\n  y      \u2248\u27e8  y\u2248r \u27e9\n  r      \u2248\u27e8 x\u2265y\u21d2x\u2293y\u2248y (\u2264-resp\u02e1-\u2248 y\u2248r y\u2264x) \u27e8\n  x \u2293 r  \u220e\n\n\u2293-cong\u02b3 : \u2200 x \u2192 Congruent\u2081 (_\u2293 x)\n\u2293-cong\u02b3 x {y\u2081} {y\u2082} y\u2081\u2248y\u2082 = begin-equality\n  y\u2081 \u2293 x  \u2248\u27e8 \u2293-comm x y\u2081 \u27e8\n  x  \u2293 y\u2081 \u2248\u27e8  \u2293-cong\u02e1 x y\u2081\u2248y\u2082 \u27e9\n  x  \u2293 y\u2082 \u2248\u27e8  \u2293-comm x y\u2082 \u27e9\n  y\u2082 \u2293 x  \u220e\n\n\u2293-cong : Congruent\u2082 _\u2293_\n\u2293-cong {x\u2081} {x\u2082} {y\u2081} {y\u2082} x\u2081\u2248x\u2082 y\u2081\u2248y\u2082 = Eq.trans (\u2293-cong\u02e1 x\u2081 y\u2081\u2248y\u2082) (\u2293-cong\u02b3 y\u2082 x\u2081\u2248x\u2082)\n\n\u2293-assoc : Associative _\u2293_\n\u2293-assoc x y r with total x y | total y r\n\u2293-assoc x y r | inj\u2081 x\u2264y | inj\u2081 y\u2264r = begin-equality\n  (x \u2293 y) \u2293 r  \u2248\u27e8 \u2293-cong\u02b3 r (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) \u27e9\n  x \u2293 r        \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x (trans x\u2264y y\u2264r) \u27e9\n  x            \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x x\u2264y \u27e8\n  x \u2293 y        \u2248\u27e8 \u2293-cong\u02e1 x (x\u2264y\u21d2x\u2293y\u2248x y\u2264r) \u27e8\n  x \u2293 (y \u2293 r)  \u220e\n\u2293-assoc x y r | inj\u2081 x\u2264y | inj\u2082 r\u2264y = begin-equality\n  (x \u2293 y) \u2293 r  \u2248\u27e8 \u2293-cong\u02b3 r (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) \u27e9\n  x \u2293 r        \u2248\u27e8 \u2293-cong\u02e1 x (x\u2265y\u21d2x\u2293y\u2248y r\u2264y) \u27e8\n  x \u2293 (y \u2293 r)  \u220e\n\u2293-assoc x y r | inj\u2082 y\u2264x | _ = begin-equality\n  (x \u2293 y) \u2293 r  \u2248\u27e8 \u2293-cong\u02b3 r (x\u2265y\u21d2x\u2293y\u2248y y\u2264x) \u27e9\n  y \u2293 r        \u2248\u27e8 x\u2265y\u21d2x\u2293y\u2248y (trans (x\u2293y\u2264x y r) y\u2264x) \u27e8\n  x \u2293 (y \u2293 r)  \u220e\n\n\u2293-idem : Idempotent _\u2293_\n\u2293-idem x = x\u2264y\u21d2x\u2293y\u2248x (refl {x})\n\n\u2293-sel : Selective _\u2293_\n\u2293-sel x y = Sum.map x\u2264y\u21d2x\u2293y\u2248x x\u2265y\u21d2x\u2293y\u2248y (total x y)\n\n\u2293-identity\u02e1 : \u2200 {\u22a4} \u2192 Maximum _\u2264_ \u22a4 \u2192 LeftIdentity \u22a4 _\u2293_\n\u2293-identity\u02e1 max = x\u2265y\u21d2x\u2293y\u2248y \u2218 max\n\n\u2293-identity\u02b3 : \u2200 {\u22a4} \u2192 Maximum _\u2264_ \u22a4 \u2192 RightIdentity \u22a4 _\u2293_\n\u2293-identity\u02b3 max = x\u2264y\u21d2x\u2293y\u2248x \u2218 max\n\n\u2293-identity : \u2200 {\u22a4} \u2192 Maximum _\u2264_ \u22a4 \u2192 Identity \u22a4 _\u2293_\n\u2293-identity max = \u2293-identity\u02e1 max , \u2293-identity\u02b3 max\n\n\u2293-zero\u02e1 : \u2200 {\u22a5} \u2192 Minimum _\u2264_ \u22a5 \u2192 LeftZero \u22a5 _\u2293_\n\u2293-zero\u02e1 min = x\u2264y\u21d2x\u2293y\u2248x \u2218 min\n\n\u2293-zero\u02b3 : \u2200 {\u22a5} \u2192 Minimum _\u2264_ \u22a5 \u2192 RightZero \u22a5 _\u2293_\n\u2293-zero\u02b3 min = x\u2265y\u21d2x\u2293y\u2248y \u2218 min\n\n\u2293-zero : \u2200 {\u22a5} \u2192 Minimum _\u2264_ \u22a5 \u2192 Zero \u22a5 _\u2293_\n\u2293-zero min = \u2293-zero\u02e1 min , \u2293-zero\u02b3 min\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2293-isMagma : IsMagma _\u2293_\n\u2293-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = \u2293-cong\n  }\n\n\u2293-isSemigroup : IsSemigroup _\u2293_\n\u2293-isSemigroup = record\n  { isMagma = \u2293-isMagma\n  ; assoc   = \u2293-assoc\n  }\n\n\u2293-isBand : IsBand _\u2293_\n\u2293-isBand = record\n  { isSemigroup = \u2293-isSemigroup\n  ; idem        = \u2293-idem\n  }\n\n\u2293-isCommutativeSemigroup : IsCommutativeSemigroup _\u2293_\n\u2293-isCommutativeSemigroup = record\n  { isSemigroup = \u2293-isSemigroup\n  ; comm        = \u2293-comm\n  }\n\n\u2293-isSelectiveMagma : IsSelectiveMagma _\u2293_\n\u2293-isSelectiveMagma = record\n  { isMagma = \u2293-isMagma\n  ; sel     = \u2293-sel\n  }\n\n\u2293-isMonoid : \u2200 {\u22a4} \u2192 Maximum _\u2264_ \u22a4 \u2192 IsMonoid _\u2293_ \u22a4\n\u2293-isMonoid max = record\n  { isSemigroup = \u2293-isSemigroup\n  ; identity    = \u2293-identity max\n  }\n\n------------------------------------------------------------------------\n-- Raw bundles\n\n\u2293-rawMagma : RawMagma _ _\n\u2293-rawMagma = record { _\u2248_ = _\u2248_ ; _\u2219_ = _\u2293_ }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2293-magma : Magma _ _\n\u2293-magma = record\n  { isMagma = \u2293-isMagma\n  }\n\n\u2293-semigroup : Semigroup _ _\n\u2293-semigroup = record\n  { isSemigroup = \u2293-isSemigroup\n  }\n\n\u2293-band : Band _ _\n\u2293-band = record\n  { isBand = \u2293-isBand\n  }\n\n\u2293-commutativeSemigroup : CommutativeSemigroup _ _\n\u2293-commutativeSemigroup = record\n  { isCommutativeSemigroup = \u2293-isCommutativeSemigroup\n  }\n\n\u2293-selectiveMagma : SelectiveMagma _ _\n\u2293-selectiveMagma = record\n  { isSelectiveMagma = \u2293-isSelectiveMagma\n  }\n\n\u2293-monoid : \u2200 {\u22a4} \u2192 Maximum _\u2264_ \u22a4 \u2192 Monoid a \u2113\u2081\n\u2293-monoid max = record\n  { isMonoid = \u2293-isMonoid max\n  }\n\n------------------------------------------------------------------------\n-- Other properties\n\nx\u2293y\u2248x\u21d2x\u2264y : \u2200 {x y} \u2192 x \u2293 y \u2248 x \u2192 x \u2264 y\nx\u2293y\u2248x\u21d2x\u2264y {x} {y} x\u2293y\u2248x with total x y\n... | inj\u2081 x\u2264y = x\u2264y\n... | inj\u2082 y\u2264x = reflexive (Eq.trans (Eq.sym x\u2293y\u2248x) (x\u2265y\u21d2x\u2293y\u2248y y\u2264x))\n\nx\u2293y\u2248y\u21d2y\u2264x : \u2200 {x y} \u2192 x \u2293 y \u2248 y \u2192 y \u2264 x\nx\u2293y\u2248y\u21d2y\u2264x {x} {y} x\u2293y\u2248y = x\u2293y\u2248x\u21d2x\u2264y (begin-equality\n  y \u2293 x  \u2248\u27e8 \u2293-comm y x \u27e9\n  x \u2293 y  \u2248\u27e8 x\u2293y\u2248y \u27e9\n  y      \u220e)\n\nmono-\u2264-distrib-\u2293 : \u2200 {f} \u2192 f Preserves _\u2248_ \u27f6 _\u2248_ \u2192 f Preserves _\u2264_ \u27f6 _\u2264_ \u2192\n                   \u2200 x y \u2192 f (x \u2293 y) \u2248 f x \u2293 f y\nmono-\u2264-distrib-\u2293 {f} cong mono x y with total x y\n... | inj\u2081 x\u2264y = begin-equality\n  f (x \u2293 y)  \u2248\u27e8 cong (x\u2264y\u21d2x\u2293y\u2248x x\u2264y) \u27e9\n  f x        \u2248\u27e8 x\u2264y\u21d2x\u2293y\u2248x (mono x\u2264y) \u27e8\n  f x \u2293 f y  \u220e\n... | inj\u2082 y\u2264x = begin-equality\n  f (x \u2293 y)  \u2248\u27e8 cong (x\u2265y\u21d2x\u2293y\u2248y y\u2264x) \u27e9\n  f y        \u2248\u27e8 x\u2265y\u21d2x\u2293y\u2248y (mono y\u2264x) \u27e8\n  f x \u2293 f y  \u220e\n\nx\u2264y\u21d2x\u2293z\u2264y : \u2200 {x y} z \u2192 x \u2264 y \u2192 x \u2293 z \u2264 y\nx\u2264y\u21d2x\u2293z\u2264y z x\u2264y = trans (x\u2293y\u2264x _ z) x\u2264y\n\nx\u2264y\u21d2z\u2293x\u2264y : \u2200 {x y} z \u2192 x \u2264 y \u2192 z \u2293 x \u2264 y\nx\u2264y\u21d2z\u2293x\u2264y y x\u2264y = trans (x\u2293y\u2264y y _) x\u2264y\n\nx\u2264y\u2293z\u21d2x\u2264y : \u2200 {x} y z \u2192 x \u2264 y \u2293 z \u2192 x \u2264 y\nx\u2264y\u2293z\u21d2x\u2264y y z x\u2264y\u2293z = trans x\u2264y\u2293z (x\u2293y\u2264x y z)\n\nx\u2264y\u2293z\u21d2x\u2264z : \u2200 {x} y z \u2192 x \u2264 y \u2293 z \u2192 x \u2264 z\nx\u2264y\u2293z\u21d2x\u2264z y z x\u2264y\u2293z = trans x\u2264y\u2293z (x\u2293y\u2264y y z)\n\n\u2293-mono-\u2264 : _\u2293_ Preserves\u2082 _\u2264_ \u27f6 _\u2264_ \u27f6 _\u2264_\n\u2293-mono-\u2264 {x} {y} {u} {v} x\u2264y u\u2264v with \u2293-sel y v\n... | inj\u2081 y\u2293v\u2248y = \u2264-resp\u02b3-\u2248 (Eq.sym y\u2293v\u2248y) (trans (x\u2293y\u2264x x u) x\u2264y)\n... | inj\u2082 y\u2293v\u2248v = \u2264-resp\u02b3-\u2248 (Eq.sym y\u2293v\u2248v) (trans (x\u2293y\u2264y x u) u\u2264v)\n\n\u2293-mono\u02e1-\u2264 : \u2200 x \u2192 (_\u2293 x) Preserves _\u2264_ \u27f6 _\u2264_\n\u2293-mono\u02e1-\u2264 x y\u2264z = \u2293-mono-\u2264 y\u2264z (refl {x})\n\n\u2293-mono\u02b3-\u2264 : \u2200 x \u2192 (x \u2293_) Preserves _\u2264_ \u27f6 _\u2264_\n\u2293-mono\u02b3-\u2264 x y\u2264z = \u2293-mono-\u2264 (refl {x}) y\u2264z\n\n\u2293-glb : \u2200 {x y z} \u2192 x \u2264 y \u2192 x \u2264 z \u2192 x \u2264 y \u2293 z\n\u2293-glb {x} x\u2264y x\u2264z = \u2264-resp\u02e1-\u2248 (\u2293-idem x) (\u2293-mono-\u2264 x\u2264y x\u2264z)\n\n\u2293-triangulate : \u2200 x y z \u2192 x \u2293 y \u2293 z \u2248 (x \u2293 y) \u2293 (y \u2293 z)\n\u2293-triangulate x y z = begin-equality\n  x \u2293 y \u2293 z           \u2248\u27e8 \u2293-cong\u02b3 z (\u2293-cong\u02e1 x (\u2293-idem y)) \u27e8\n  x \u2293 (y \u2293 y) \u2293 z     \u2248\u27e8  \u2293-assoc x _ _ \u27e9\n  x \u2293 ((y \u2293 y) \u2293 z)   \u2248\u27e8  \u2293-cong\u02e1 x (\u2293-assoc y y z) \u27e9\n  x \u2293 (y \u2293 (y \u2293 z))   \u2248\u27e8 \u2293-assoc x y (y \u2293 z) \u27e8\n  (x \u2293 y) \u2293 (y \u2293 z)   \u220e\n</pre>"},{"location":"md/Algebra/Core/","title":"Algebra.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core algebraic definitions\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Core where\n\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Unary and binary operations\n\nOp\u2081 : \u2200 {\u2113} \u2192 Set \u2113 \u2192 Set \u2113\nOp\u2081 A = A \u2192 A\n\nOp\u2082 : \u2200 {\u2113} \u2192 Set \u2113 \u2192 Set \u2113\nOp\u2082 A = A \u2192 A \u2192 A\n</pre>"},{"location":"md/Algebra/Definitions/","title":"Algebra.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of functions, such as associativity and commutativity\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra`, unless\n-- you want to parameterise it via the equality relation.\n\n-- Note that very few of the element arguments are made implicit here,\n-- as we do not assume that the Agda can infer either the right or left\n-- argument of the binary operators. This is despite the fact that the\n-- library defines most of its concrete operators (e.g. in\n-- `Data.Nat.Base`) as being left-biased.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\n\nmodule Algebra.Definitions\n  {a \u2113} {A : Set a}   -- The underlying set\n  (_\u2248_ : Rel A \u2113)     -- The underlying equality\n  where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Data.Product.Base using (_\u00d7_; \u2203-syntax)\nopen import Data.Sum.Base using (_\u228e_)\nopen import Relation.Binary.Definitions using (Monotonic\u2081; Monotonic\u2082)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\n\n------------------------------------------------------------------------\n-- Properties of operations\n\nCongruent\u2081 : Op\u2081 A \u2192 Set _\nCongruent\u2081 = Monotonic\u2081 _\u2248_ _\u2248_\n\nCongruent\u2082 : Op\u2082 A \u2192 Set _\nCongruent\u2082 = Monotonic\u2082 _\u2248_ _\u2248_ _\u2248_\n\nLeftCongruent : Op\u2082 A \u2192 Set _\nLeftCongruent _\u2219_ = \u2200 {x} \u2192 Congruent\u2081 (x \u2219_)\n\nRightCongruent : Op\u2082 A \u2192 Set _\nRightCongruent _\u2219_ = \u2200 {x} \u2192 Congruent\u2081 (_\u2219 x)\n\nAssociative : Op\u2082 A \u2192 Set _\nAssociative _\u2219_ = \u2200 x y z \u2192 ((x \u2219 y) \u2219 z) \u2248 (x \u2219 (y \u2219 z))\n\nCommutative : Op\u2082 A \u2192 Set _\nCommutative _\u2219_ = \u2200 x y \u2192 (x \u2219 y) \u2248 (y \u2219 x)\n\nLeftIdentity : A \u2192 Op\u2082 A \u2192 Set _\nLeftIdentity e _\u2219_ = \u2200 x \u2192 (e \u2219 x) \u2248 x\n\nRightIdentity : A \u2192 Op\u2082 A \u2192 Set _\nRightIdentity e _\u2219_ = \u2200 x \u2192 (x \u2219 e) \u2248 x\n\nIdentity : A \u2192 Op\u2082 A \u2192 Set _\nIdentity e \u2219 = (LeftIdentity e \u2219) \u00d7 (RightIdentity e \u2219)\n\nLeftZero : A \u2192 Op\u2082 A \u2192 Set _\nLeftZero z _\u2219_ = \u2200 x \u2192 (z \u2219 x) \u2248 z\n\nRightZero : A \u2192 Op\u2082 A \u2192 Set _\nRightZero z _\u2219_ = \u2200 x \u2192 (x \u2219 z) \u2248 z\n\nZero : A \u2192 Op\u2082 A \u2192 Set _\nZero z \u2219 = (LeftZero z \u2219) \u00d7 (RightZero z \u2219)\n\nLeftInverse : A \u2192 Op\u2081 A \u2192 Op\u2082 A \u2192 Set _\nLeftInverse e _\u207b\u00b9 _\u2219_ = \u2200 x \u2192 ((x \u207b\u00b9) \u2219 x) \u2248 e\n\nRightInverse : A \u2192 Op\u2081 A \u2192 Op\u2082 A \u2192 Set _\nRightInverse e _\u207b\u00b9 _\u2219_ = \u2200 x \u2192 (x \u2219 (x \u207b\u00b9)) \u2248 e\n\nInverse : A \u2192 Op\u2081 A \u2192 Op\u2082 A \u2192 Set _\nInverse e \u207b\u00b9 \u2219 = (LeftInverse e \u207b\u00b9) \u2219 \u00d7 (RightInverse e \u207b\u00b9 \u2219)\n\n-- For structures in which not every element has an inverse (e.g. Fields)\nLeftInvertible : A \u2192 Op\u2082 A \u2192 A \u2192 Set _\nLeftInvertible e _\u2219_ x = \u2203[ x\u207b\u00b9 ] (x\u207b\u00b9 \u2219 x) \u2248 e\n\nRightInvertible : A \u2192 Op\u2082 A \u2192 A \u2192 Set _\nRightInvertible e _\u2219_ x = \u2203[ x\u207b\u00b9 ] (x \u2219 x\u207b\u00b9) \u2248 e\n\n-- NB: this is not quite the same as\n-- LeftInvertible e \u2219 x \u00d7 RightInvertible e \u2219 x\n-- since the left and right inverses have to coincide.\nInvertible : A \u2192 Op\u2082 A \u2192 A \u2192 Set _\nInvertible e _\u2219_ x = \u2203[ x\u207b\u00b9 ] (x\u207b\u00b9 \u2219 x) \u2248 e \u00d7 (x \u2219 x\u207b\u00b9) \u2248 e\n\nLeftConical : A \u2192 Op\u2082 A \u2192 Set _\nLeftConical e _\u2219_ = \u2200 x y \u2192 (x \u2219 y) \u2248 e \u2192 x \u2248 e\n\nRightConical : A \u2192 Op\u2082 A \u2192 Set _\nRightConical e _\u2219_ = \u2200 x y \u2192 (x \u2219 y) \u2248 e \u2192 y \u2248 e\n\nConical : A \u2192 Op\u2082 A \u2192 Set _\nConical e \u2219 = (LeftConical e \u2219) \u00d7 (RightConical e \u2219)\n\ninfix 4 _DistributesOver\u02e1_ _DistributesOver\u02b3_ _DistributesOver_\n\n_DistributesOver\u02e1_ : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\n_*_ DistributesOver\u02e1 _+_ =\n  \u2200 x y z \u2192 (x * (y + z)) \u2248 ((x * y) + (x * z))\n\n_DistributesOver\u02b3_ : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\n_*_ DistributesOver\u02b3 _+_ =\n  \u2200 x y z \u2192 ((y + z) * x) \u2248 ((y * x) + (z * x))\n\n_DistributesOver_ : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\n* DistributesOver + = (* DistributesOver\u02e1 +) \u00d7 (* DistributesOver\u02b3 +)\n\ninfix 4 _MiddleFourExchange_ _IdempotentOn_ _Absorbs_\n\n_MiddleFourExchange_ : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\n_*_ MiddleFourExchange _+_ =\n  \u2200 w x y z \u2192 ((w + x) * (y + z)) \u2248 ((w + y) * (x + z))\n\n_IdempotentOn_ : Op\u2082 A \u2192 A \u2192 Set _\n_\u2219_ IdempotentOn x = (x \u2219 x) \u2248 x\n\nIdempotent : Op\u2082 A \u2192 Set _\nIdempotent \u2219 = \u2200 x \u2192 \u2219 IdempotentOn x\n\nIdempotentFun : Op\u2081 A \u2192 Set _\nIdempotentFun f = \u2200 x \u2192 f (f x) \u2248 f x\n\nSelective : Op\u2082 A \u2192 Set _\nSelective _\u2219_ = \u2200 x y \u2192 (x \u2219 y) \u2248 x \u228e (x \u2219 y) \u2248 y\n\n_Absorbs_ : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\n_\u2219_ Absorbs _\u2218_ = \u2200 x y \u2192 (x \u2219 (x \u2218 y)) \u2248 x\n\nAbsorptive : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nAbsorptive \u2219 \u2218 = (\u2219 Absorbs \u2218) \u00d7 (\u2218 Absorbs \u2219)\n\nSelfInverse : Op\u2081 A \u2192 Set _\nSelfInverse f = \u2200 {x y} \u2192 f x \u2248 y \u2192 f y \u2248 x\n\nInvolutive : Op\u2081 A \u2192 Set _\nInvolutive f = \u2200 x \u2192 f (f x) \u2248 x\n\nLeftCancellative : Op\u2082 A \u2192 Set _\nLeftCancellative _\u2022_ = \u2200 x y z \u2192 (x \u2022 y) \u2248 (x \u2022 z) \u2192 y \u2248 z\n\nRightCancellative : Op\u2082 A \u2192 Set _\nRightCancellative _\u2022_ = \u2200 x y z \u2192 (y \u2022 x) \u2248 (z \u2022 x) \u2192 y \u2248 z\n\nCancellative : Op\u2082 A \u2192 Set _\nCancellative _\u2022_ = (LeftCancellative _\u2022_) \u00d7 (RightCancellative _\u2022_)\n\nAlmostLeftCancellative : A \u2192 Op\u2082 A \u2192 Set _\nAlmostLeftCancellative e _\u2022_ = \u2200 x y z \u2192 \u00ac x \u2248 e \u2192 (x \u2022 y) \u2248 (x \u2022 z) \u2192 y \u2248 z\n\nAlmostRightCancellative : A \u2192 Op\u2082 A \u2192 Set _\nAlmostRightCancellative e _\u2022_ = \u2200 x y z \u2192 \u00ac x \u2248 e \u2192 (y \u2022 x) \u2248 (z \u2022 x) \u2192 y \u2248 z\n\nAlmostCancellative : A \u2192 Op\u2082 A \u2192 Set _\nAlmostCancellative e _\u2022_ = AlmostLeftCancellative e _\u2022_ \u00d7 AlmostRightCancellative e _\u2022_\n\nInterchangable : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nInterchangable _\u2218_ _\u2219_ = \u2200 w x y z \u2192 ((w \u2219 x) \u2218 (y \u2219 z)) \u2248 ((w \u2218 y) \u2219 (x \u2218 z))\n\nLeftDivides\u02e1 : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nLeftDivides\u02e1 _\u2219_  _\\\\_ = \u2200 x y \u2192 (x \u2219 (x \\\\ y)) \u2248 y\n\nLeftDivides\u02b3 : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nLeftDivides\u02b3 _\u2219_ _\\\\_ = \u2200 x y \u2192 (x \\\\ (x \u2219 y)) \u2248 y\n\nRightDivides\u02e1 : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nRightDivides\u02e1 _\u2219_ _//_ = \u2200 x y \u2192 ((y // x) \u2219 x) \u2248 y\n\nRightDivides\u02b3 : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nRightDivides\u02b3 _\u2219_ _//_ = \u2200 x y \u2192 ((y \u2219 x) // x) \u2248 y\n\nLeftDivides : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nLeftDivides \u2219 \\\\ = (LeftDivides\u02e1 \u2219 \\\\) \u00d7 (LeftDivides\u02b3 \u2219 \\\\)\n\nRightDivides : Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nRightDivides \u2219 // = (RightDivides\u02e1 \u2219 //) \u00d7 (RightDivides\u02b3 \u2219 //)\n\nStarRightExpansive : A \u2192 Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarRightExpansive e _+_ _\u2219_ _* = \u2200 x \u2192 (e + (x \u2219 (x *))) \u2248 (x *)\n\nStarLeftExpansive : A \u2192 Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarLeftExpansive e _+_ _\u2219_ _* = \u2200 x \u2192  (e + ((x *) \u2219 x)) \u2248 (x *)\n\nStarExpansive : A \u2192 Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarExpansive e _+_ _\u2219_ _* = (StarLeftExpansive e _+_ _\u2219_ _*) \u00d7 (StarRightExpansive e _+_ _\u2219_ _*)\n\nStarLeftDestructive : Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarLeftDestructive _+_ _\u2219_ _* = \u2200 a b x \u2192 (b + (a \u2219 x)) \u2248 x \u2192 ((a *) \u2219 b) \u2248 x\n\nStarRightDestructive : Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarRightDestructive _+_ _\u2219_ _* = \u2200 a b x \u2192 (b + (x \u2219 a)) \u2248 x \u2192 (b \u2219 (a *)) \u2248 x\n\nStarDestructive : Op\u2082 A \u2192 Op\u2082 A \u2192 Op\u2081 A \u2192 Set _\nStarDestructive _+_ _\u2219_ _* = (StarLeftDestructive _+_ _\u2219_ _*) \u00d7 (StarRightDestructive _+_ _\u2219_ _*)\n\nLeftAlternative : Op\u2082 A \u2192 Set _\nLeftAlternative _\u2219_ = \u2200 x y  \u2192  ((x \u2219 x) \u2219 y) \u2248 (x \u2219 (x \u2219 y))\n\nRightAlternative : Op\u2082 A \u2192 Set _\nRightAlternative _\u2219_ = \u2200 x y \u2192 (x \u2219 (y \u2219 y)) \u2248 ((x \u2219 y) \u2219 y)\n\nAlternative : Op\u2082 A \u2192 Set _\nAlternative _\u2219_ = (LeftAlternative _\u2219_ ) \u00d7 (RightAlternative _\u2219_)\n\nFlexible : Op\u2082 A \u2192 Set _\nFlexible _\u2219_ = \u2200 x y \u2192 ((x \u2219 y) \u2219 x) \u2248 (x \u2219 (y \u2219 x))\n\nMedial : Op\u2082 A \u2192 Set _\nMedial _\u2219_ = \u2200 x y u z \u2192 ((x \u2219 y) \u2219 (u \u2219 z)) \u2248 ((x \u2219 u) \u2219 (y \u2219 z))\n\nLeftSemimedial : Op\u2082 A \u2192 Set _\nLeftSemimedial _\u2219_ = \u2200 x y z \u2192 ((x \u2219 x) \u2219 (y \u2219 z)) \u2248 ((x \u2219 y) \u2219 (x \u2219 z))\n\nRightSemimedial : Op\u2082 A \u2192 Set _\nRightSemimedial _\u2219_ = \u2200 x y z \u2192 ((y \u2219 z) \u2219 (x \u2219 x)) \u2248 ((y \u2219 x) \u2219 (z \u2219 x))\n\nSemimedial : Op\u2082 A \u2192 Set _\nSemimedial _\u2219_ = (LeftSemimedial _\u2219_) \u00d7 (RightSemimedial _\u2219_)\n\nLeftBol : Op\u2082 A \u2192 Set _\nLeftBol _\u2219_ = \u2200 x y z \u2192 (x \u2219 (y \u2219 (x \u2219 z))) \u2248 ((x \u2219 (y \u2219 x)) \u2219 z )\n\nRightBol : Op\u2082 A \u2192 Set _\nRightBol _\u2219_ = \u2200 x y z \u2192 (((z \u2219 x) \u2219 y) \u2219 x) \u2248 (z \u2219 ((x \u2219 y) \u2219 x))\n\nMiddleBol : Op\u2082 A \u2192 Op\u2082 A  \u2192 Op\u2082 A  \u2192 Set _\nMiddleBol _\u2219_ _\\\\_ _//_ = \u2200 x y z \u2192 (x \u2219 ((y \u2219 z) \\\\ x)) \u2248 ((x // z) \u2219 (y \\\\ x))\n\nIdentical : Op\u2082 A \u2192 Set _\nIdentical _\u2219_ = \u2200 x y z \u2192 ((z \u2219 x) \u2219 (y \u2219 z)) \u2248 (z \u2219 ((x \u2219 y) \u2219 z))\n</pre>"},{"location":"md/Algebra/Definitions/RawMagma/","title":"Algebra.Definitions.RawMagma","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic auxiliary definitions for magma-like structures\n------------------------------------------------------------------------\n\n-- You're unlikely to want to use this module directly. Instead you\n-- probably want to be importing the appropriate module from\n-- `Algebra.Properties.(Magma/Semigroup/...).Divisibility`\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Bundles.Raw using (RawMagma)\nopen import Data.Product.Base using (_\u00d7_)\nopen import Level using (_\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nmodule Algebra.Definitions.RawMagma\n  {a \u2113} (M : RawMagma a \u2113)\n  where\n\nopen RawMagma M renaming (Carrier to A)\n\n------------------------------------------------------------------------\n-- Divisibility\n\ninfixr 4 _,_\ninfix 5 _\u2223\u02e1_ _\u2224\u02e1_ _\u2223\u02b3_ _\u2224\u02b3_ _\u2223_ _\u2224_ _\u2225_ _\u2226_\n\n-- Divisibility from the left.\n--\n-- This and, the definition of right divisibility below, are defined as\n-- records rather than in terms of the base product type in order to\n-- make the use of pattern synonyms more ergonomic (see #2216 for\n-- further details). The record field names are not designed to be\n-- used explicitly and indeed aren't re-exported publicly by\n-- `Algebra.Properties.X.Divisibility` modules.\n\nrecord _\u2223\u02e1_ (x y : A) : Set (a \u2294 \u2113) where\n  constructor _,_\n  field\n    quotient : A\n    equality : x \u2219 quotient \u2248 y\n\n_\u2224\u02e1_ : Rel A (a \u2294 \u2113)\nx \u2224\u02e1 y = \u00ac x \u2223\u02e1 y\n\n-- Divisibility from the right\n\nrecord _\u2223\u02b3_ (x y : A) : Set (a \u2294 \u2113) where\n  constructor _,_\n  field\n    quotient : A\n    equality : quotient \u2219 x \u2248 y\n\n_\u2224\u02b3_ : Rel A (a \u2294 \u2113)\nx \u2224\u02b3 y = \u00ac x \u2223\u02b3 y\n\n-- General divisibility\n\n-- The relations _\u2223\u02e1_ and _\u2223\u02b3_ are only equivalent when _\u2219_ is\n-- commutative. When that is not the case we take `_\u2223\u02b3_` to be the\n-- primary one.\n\n_\u2223_ : Rel A (a \u2294 \u2113)\n_\u2223_ = _\u2223\u02b3_\n\n_\u2224_ : Rel A (a \u2294 \u2113)\nx \u2224 y = \u00ac x \u2223 y\n\n------------------------------------------------------------------------\n-- Mutual divisibility.\n\n-- In a  monoid, this is an equivalence relation extending _\u2248_.\n-- When in a cancellative monoid,  elements related by _\u2223\u2223_ are called\n-- associated, and `x \u2223\u2223 y` means that `x` and `y` differ by some\n-- invertible factor.\n\n-- Example: for \u2115  this is equivalent to x \u2261 y,\n--          for \u2124  this is equivalent to (x \u2261 y or x \u2261 - y).\n\n_\u2225_ : Rel A (a \u2294 \u2113)\nx \u2225 y = x \u2223 y \u00d7 y \u2223 x\n\n_\u2226_ : Rel A (a \u2294 \u2113)\nx \u2226 y = \u00ac x \u2225 y\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.3\n\n_\u2223\u2223_ = _\u2225_\n{-# WARNING_ON_USAGE _\u2223\u2223_\n\"Warning: _\u2223\u2223_ was deprecated in v2.3.\nPlease use _\u2225_ instead.\"\n#-}\n_\u2224\u2224_ = _\u2226_\n{-# WARNING_ON_USAGE _\u2224\u2224_\n\"Warning: _\u2224\u2224_ was deprecated in v2.3.\nPlease use _\u2226_ instead.\"\n#-}\n\n</pre>"},{"location":"md/Algebra/Lattice/Bundles/","title":"Algebra.Lattice.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of algebraic structures like semilattices and lattices\n-- (packed in records together with sets, operations, etc.), defined via\n-- meet/join operations and their properties\n--\n-- For lattices defined via an order relation, see\n-- Relation.Binary.Lattice.\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra.Lattice`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Lattice.Bundles where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Algebra.Bundles using (Band)\nimport Algebra.Lattice.Bundles.Raw as Raw\nopen import Algebra.Lattice.Structures\n  using ( IsSemilattice; IsMeetSemilattice; IsJoinSemilattice\n        ; IsBoundedSemilattice; IsBoundedMeetSemilattice\n        ; IsBoundedJoinSemilattice; IsLattice; IsDistributiveLattice\n        ; IsBooleanAlgebra)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Core using (Rel)\n\n------------------------------------------------------------------------\n-- Re-export definitions of 'raw' bundles\n\nopen Raw public\n  using (RawLattice)\n\n------------------------------------------------------------------------\n-- Bundles\n------------------------------------------------------------------------\n\nrecord Semilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier       : Set c\n    _\u2248_           : Rel Carrier \u2113\n    _\u2219_           : Op\u2082 Carrier\n    isSemilattice : IsSemilattice _\u2248_ _\u2219_\n\n  open IsSemilattice _\u2248_ isSemilattice public\n\n  band : Band c \u2113\n  band = record { isBand = isBand }\n\n  open Band band public\n    using (_\u2249_; rawMagma; magma; isMagma; semigroup; isSemigroup; isBand)\n\n\nrecord MeetSemilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2227_\n  infix  4 _\u2248_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\n    _\u2227_               : Op\u2082 Carrier\n    isMeetSemilattice : IsSemilattice _\u2248_ _\u2227_\n\n  open IsMeetSemilattice _\u2248_ isMeetSemilattice public\n\n  semilattice : Semilattice c \u2113\n  semilattice = record { isSemilattice = isMeetSemilattice }\n\n  open Semilattice semilattice public\n    using (rawMagma; magma; semigroup; band)\n\n\nrecord JoinSemilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\n    _\u2228_               : Op\u2082 Carrier\n    isJoinSemilattice : IsSemilattice _\u2248_ _\u2228_\n\n  open IsJoinSemilattice _\u2248_ isJoinSemilattice public\n\n  semilattice : Semilattice c \u2113\n  semilattice = record { isSemilattice = isJoinSemilattice }\n\n  open Semilattice semilattice public\n    using (rawMagma; magma; semigroup; band)\n\n\nrecord BoundedSemilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier              : Set c\n    _\u2248_                  : Rel Carrier \u2113\n    _\u2219_                  : Op\u2082 Carrier\n    \u03b5                    : Carrier\n    isBoundedSemilattice : IsBoundedSemilattice _\u2248_ _\u2219_ \u03b5\n\n  open IsBoundedSemilattice _\u2248_ isBoundedSemilattice public\n\n  semilattice : Semilattice c \u2113\n  semilattice = record { isSemilattice = isSemilattice }\n\n  open Semilattice semilattice public using (rawMagma; magma; semigroup; band)\n\n\nrecord BoundedMeetSemilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2227_\n  infix  4 _\u2248_\n  field\n    Carrier                  : Set c\n    _\u2248_                      : Rel Carrier \u2113\n    _\u2227_                      : Op\u2082 Carrier\n    \u22a4                        : Carrier\n    isBoundedMeetSemilattice : IsBoundedSemilattice _\u2248_ _\u2227_ \u22a4\n\n  open IsBoundedMeetSemilattice _\u2248_ isBoundedMeetSemilattice public\n\n  boundedSemilattice : BoundedSemilattice c \u2113\n  boundedSemilattice = record\n    { isBoundedSemilattice = isBoundedMeetSemilattice }\n\n  open BoundedSemilattice boundedSemilattice public\n    using (rawMagma; magma; semigroup; band; semilattice)\n\n\nrecord BoundedJoinSemilattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier                  : Set c\n    _\u2248_                      : Rel Carrier \u2113\n    _\u2228_                      : Op\u2082 Carrier\n    \u22a5                        : Carrier\n    isBoundedJoinSemilattice : IsBoundedSemilattice _\u2248_ _\u2228_ \u22a5\n\n  open IsBoundedJoinSemilattice _\u2248_ isBoundedJoinSemilattice public\n\n  boundedSemilattice : BoundedSemilattice c \u2113\n  boundedSemilattice = record\n    { isBoundedSemilattice = isBoundedJoinSemilattice }\n\n  open BoundedSemilattice boundedSemilattice public\n    using (rawMagma; magma; semigroup; band; semilattice)\n\n\nrecord Lattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2227_\n  infixr 6 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier   : Set c\n    _\u2248_       : Rel Carrier \u2113\n    _\u2228_       : Op\u2082 Carrier\n    _\u2227_       : Op\u2082 Carrier\n    isLattice : IsLattice _\u2248_ _\u2228_ _\u2227_\n\n  open IsLattice isLattice public\n\n  rawLattice : RawLattice c \u2113\n  rawLattice = record\n    { _\u2248_  = _\u2248_\n    ; _\u2227_  = _\u2227_\n    ; _\u2228_  = _\u2228_\n    }\n\n  open RawLattice rawLattice public\n    using (\u2228-rawMagma; \u2227-rawMagma)\n\n  setoid : Setoid c \u2113\n  setoid = record { isEquivalence = isEquivalence }\n\n  open Setoid setoid public\n    using (_\u2249_)\n\n\nrecord DistributiveLattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2227_\n  infixr 6 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier               : Set c\n    _\u2248_                   : Rel Carrier \u2113\n    _\u2228_                   : Op\u2082 Carrier\n    _\u2227_                   : Op\u2082 Carrier\n    isDistributiveLattice : IsDistributiveLattice _\u2248_ _\u2228_ _\u2227_\n\n  open IsDistributiveLattice isDistributiveLattice public\n\n  lattice : Lattice _ _\n  lattice = record { isLattice = isLattice }\n\n  open Lattice lattice public\n    using\n    ( _\u2249_; setoid; rawLattice\n    ; \u2228-rawMagma; \u2227-rawMagma\n    )\n\n\nrecord BooleanAlgebra c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 \u00ac_\n  infixr 7 _\u2227_\n  infixr 6 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\n    _\u2228_              : Op\u2082 Carrier\n    _\u2227_              : Op\u2082 Carrier\n    \u00ac_               : Op\u2081 Carrier\n    \u22a4                : Carrier\n    \u22a5                : Carrier\n    isBooleanAlgebra : IsBooleanAlgebra _\u2248_ _\u2228_ _\u2227_ \u00ac_ \u22a4 \u22a5\n\n  open IsBooleanAlgebra isBooleanAlgebra public\n\n  distributiveLattice : DistributiveLattice _ _\n  distributiveLattice = record\n    { isDistributiveLattice = isDistributiveLattice\n    }\n\n  open DistributiveLattice distributiveLattice public\n    using\n    ( _\u2249_; setoid; rawLattice\n    ; \u2228-rawMagma; \u2227-rawMagma\n    ; lattice\n    )\n</pre>"},{"location":"md/Algebra/Lattice/Bundles/Raw/","title":"Algebra.Lattice.Bundles.Raw","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of 'raw' bundles\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Lattice.Bundles.Raw where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Algebra.Bundles.Raw using (RawMagma)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\n\nrecord RawLattice c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixr 7 _\u2227_\n  infixr 6 _\u2228_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2227_     : Op\u2082 Carrier\n    _\u2228_     : Op\u2082 Carrier\n\n  \u2228-rawMagma : RawMagma c \u2113\n  \u2228-rawMagma = record { _\u2248_ = _\u2248_; _\u2219_ = _\u2228_ }\n\n  \u2227-rawMagma : RawMagma c \u2113\n  \u2227-rawMagma = record { _\u2248_ = _\u2248_; _\u2219_ = _\u2227_ }\n\n  open RawMagma \u2228-rawMagma public\n    using (_\u2249_)\n</pre>"},{"location":"md/Algebra/Lattice/Construct/NaturalChoice/MaxOp/","title":"Algebra.Lattice.Construct.NaturalChoice.MaxOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of a max operator derived from a spec over a total\n-- preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Construct.NaturalChoice.Base\n  using (MaxOperator; MaxOp\u21d2MinOp)\nopen import Relation.Binary.Bundles using (TotalPreorder)\n\nmodule Algebra.Lattice.Construct.NaturalChoice.MaxOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082} (maxOp : MaxOperator O)\n  where\n\nimport Algebra.Lattice.Construct.NaturalChoice.MinOp as MinOp\n\nprivate\n  module Min = MinOp (MaxOp\u21d2MinOp maxOp)\n\nopen Min public\n  using ()\n  renaming\n  ( \u2293-isSemilattice           to  \u2294-isSemilattice\n  ; \u2293-semilattice             to  \u2294-semilattice\n  )\n</pre>"},{"location":"md/Algebra/Lattice/Construct/NaturalChoice/MinMaxOp/","title":"Algebra.Lattice.Construct.NaturalChoice.MinMaxOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of min and max operators specified over a total preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Construct.NaturalChoice.Base using (MinOperator; MaxOperator)\nopen import Relation.Binary.Bundles using (TotalPreorder)\n\nmodule Algebra.Lattice.Construct.NaturalChoice.MinMaxOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082}\n  (minOp : MinOperator O)\n  (maxOp : MaxOperator O)\n  where\n\nopen TotalPreorder O\nopen MinOperator minOp\nopen MaxOperator maxOp\n\nopen import Algebra.Lattice.Structures _\u2248_\nopen import Algebra.Construct.NaturalChoice.MinMaxOp minOp maxOp\nopen import Algebra.Lattice.Bundles using (Lattice; DistributiveLattice)\nopen import Relation.Binary.Reasoning.Preorder preorder\n\n------------------------------------------------------------------------\n-- Re-export properties of individual operators\n\nopen import Algebra.Lattice.Construct.NaturalChoice.MinOp minOp public\nopen import Algebra.Lattice.Construct.NaturalChoice.MaxOp maxOp public\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2294-\u2293-isLattice : IsLattice _\u2294_ _\u2293_\n\u2294-\u2293-isLattice = record\n  { isEquivalence = isEquivalence\n  ; \u2228-comm        = \u2294-comm\n  ; \u2228-assoc       = \u2294-assoc\n  ; \u2228-cong        = \u2294-cong\n  ; \u2227-comm        = \u2293-comm\n  ; \u2227-assoc       = \u2293-assoc\n  ; \u2227-cong        = \u2293-cong\n  ; absorptive    = \u2294-\u2293-absorptive\n  }\n\n\u2293-\u2294-isLattice : IsLattice _\u2293_ _\u2294_\n\u2293-\u2294-isLattice = record\n  { isEquivalence = isEquivalence\n  ; \u2228-comm        = \u2293-comm\n  ; \u2228-assoc       = \u2293-assoc\n  ; \u2228-cong        = \u2293-cong\n  ; \u2227-comm        = \u2294-comm\n  ; \u2227-assoc       = \u2294-assoc\n  ; \u2227-cong        = \u2294-cong\n  ; absorptive    = \u2293-\u2294-absorptive\n  }\n\n\u2293-\u2294-isDistributiveLattice : IsDistributiveLattice _\u2293_ _\u2294_\n\u2293-\u2294-isDistributiveLattice = record\n  { isLattice    = \u2293-\u2294-isLattice\n  ; \u2228-distrib-\u2227  = \u2293-distrib-\u2294\n  ; \u2227-distrib-\u2228  = \u2294-distrib-\u2293\n  }\n\n\u2294-\u2293-isDistributiveLattice : IsDistributiveLattice _\u2294_ _\u2293_\n\u2294-\u2293-isDistributiveLattice = record\n  { isLattice    = \u2294-\u2293-isLattice\n  ; \u2228-distrib-\u2227  = \u2294-distrib-\u2293\n  ; \u2227-distrib-\u2228  = \u2293-distrib-\u2294\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2294-\u2293-lattice : Lattice _ _\n\u2294-\u2293-lattice = record\n  { isLattice = \u2294-\u2293-isLattice\n  }\n\n\u2293-\u2294-lattice : Lattice _ _\n\u2293-\u2294-lattice = record\n  { isLattice = \u2293-\u2294-isLattice\n  }\n\n\u2294-\u2293-distributiveLattice : DistributiveLattice _ _\n\u2294-\u2293-distributiveLattice = record\n  { isDistributiveLattice = \u2294-\u2293-isDistributiveLattice\n  }\n\n\u2293-\u2294-distributiveLattice : DistributiveLattice _ _\n\u2293-\u2294-distributiveLattice = record\n  { isDistributiveLattice = \u2293-\u2294-isDistributiveLattice\n  }\n</pre>"},{"location":"md/Algebra/Lattice/Construct/NaturalChoice/MinOp/","title":"Algebra.Lattice.Construct.NaturalChoice.MinOp","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of a min operator derived from a spec over a total\n-- preorder.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Construct.NaturalChoice.Base using (MinOperator)\nopen import Relation.Binary.Bundles using (TotalPreorder)\n\nmodule Algebra.Lattice.Construct.NaturalChoice.MinOp\n  {a \u2113\u2081 \u2113\u2082} {O : TotalPreorder a \u2113\u2081 \u2113\u2082} (minOp : MinOperator O) where\n\nopen TotalPreorder O\nopen MinOperator minOp\n\nopen import Algebra.Construct.NaturalChoice.MinOp minOp\nopen import Algebra.Lattice.Bundles using (Semilattice)\nopen import Algebra.Lattice.Structures _\u2248_\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2293-isSemilattice : IsSemilattice _\u2293_\n\u2293-isSemilattice = record\n  { isBand = \u2293-isBand\n  ; comm   = \u2293-comm\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2293-semilattice : Semilattice _ _\n\u2293-semilattice = record\n  { isSemilattice = \u2293-isSemilattice\n  }\n</pre>"},{"location":"md/Algebra/Lattice/Properties/BooleanAlgebra/","title":"Algebra.Lattice.Properties.BooleanAlgebra","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some derivable properties of Boolean algebras\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Lattice.Bundles\n\nmodule Algebra.Lattice.Properties.BooleanAlgebra\n  {b\u2081 b\u2082} (B : BooleanAlgebra b\u2081 b\u2082)\n  where\n\nopen BooleanAlgebra B\n\nimport Algebra.Lattice.Properties.DistributiveLattice as DistribLatticeProperties\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Algebra.Structures _\u2248_\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Consequences.Setoid setoid\nopen import Algebra.Bundles using (CommutativeSemiring; CommutativeRing)\nopen import Algebra.Lattice.Structures _\u2248_\nopen import Relation.Binary.Reasoning.Setoid setoid\nopen import Function.Base using (id; _$_; _\u27e8_\u27e9_)\nopen import Function.Bundles using (_\u21d4_; module Equivalence)\nopen import Data.Product.Base using (_,_)\n\n------------------------------------------------------------------------\n-- Export properties from distributive lattices\n\nopen DistribLatticeProperties distributiveLattice public\n\n------------------------------------------------------------------------\n-- The dual construction is also a boolean algebra\n\n\u2227-\u2228-isBooleanAlgebra : IsBooleanAlgebra _\u2227_ _\u2228_ \u00ac_ \u22a5 \u22a4\n\u2227-\u2228-isBooleanAlgebra = record\n  { isDistributiveLattice = \u2227-\u2228-isDistributiveLattice\n  ; \u2228-complement          = \u2227-complement\n  ; \u2227-complement          = \u2228-complement\n  ; \u00ac-cong                = \u00ac-cong\n  }\n\n\u2227-\u2228-booleanAlgebra : BooleanAlgebra _ _\n\u2227-\u2228-booleanAlgebra = record\n  { isBooleanAlgebra = \u2227-\u2228-isBooleanAlgebra\n  }\n\n------------------------------------------------------------------------\n-- (\u2228, \u2227, \u22a5, \u22a4) and (\u2227, \u2228, \u22a4, \u22a5) are commutative semirings\n\n\u2227-identity\u02b3 : RightIdentity \u22a4 _\u2227_\n\u2227-identity\u02b3 x = begin\n  x \u2227 \u22a4          \u2248\u27e8 \u2227-cong\u02e1 (sym (\u2228-complement\u02b3 _)) \u27e9\n  x \u2227 (x \u2228 \u00ac x)  \u2248\u27e8 \u2227-absorbs-\u2228 _ _ \u27e9\n  x              \u220e\n\n\u2227-identity\u02e1 : LeftIdentity \u22a4 _\u2227_\n\u2227-identity\u02e1 = comm\u2227id\u02b3\u21d2id\u02e1 \u2227-comm \u2227-identity\u02b3\n\n\u2227-identity : Identity \u22a4 _\u2227_\n\u2227-identity = \u2227-identity\u02e1 , \u2227-identity\u02b3\n\n\u2228-identity\u02b3 : RightIdentity \u22a5 _\u2228_\n\u2228-identity\u02b3 x = begin\n  x \u2228 \u22a5          \u2248\u27e8 \u2228-cong\u02e1 $ sym (\u2227-complement\u02b3 _) \u27e9\n  x \u2228 x \u2227 \u00ac x    \u2248\u27e8 \u2228-absorbs-\u2227 _ _ \u27e9\n  x              \u220e\n\n\u2228-identity\u02e1 : LeftIdentity \u22a5 _\u2228_\n\u2228-identity\u02e1 = comm\u2227id\u02b3\u21d2id\u02e1 \u2228-comm \u2228-identity\u02b3\n\n\u2228-identity : Identity \u22a5 _\u2228_\n\u2228-identity = \u2228-identity\u02e1 , \u2228-identity\u02b3\n\n\u2227-zero\u02b3 : RightZero \u22a5 _\u2227_\n\u2227-zero\u02b3 x = begin\n  x \u2227 \u22a5          \u2248\u27e8 \u2227-cong\u02e1 (\u2227-complement\u02b3 x) \u27e8\n  x \u2227  x  \u2227 \u00ac x  \u2248\u27e8 \u2227-assoc x x (\u00ac x) \u27e8\n  (x \u2227 x) \u2227 \u00ac x  \u2248\u27e8  \u2227-cong\u02b3 (\u2227-idem x) \u27e9\n  x       \u2227 \u00ac x  \u2248\u27e8  \u2227-complement\u02b3 x \u27e9\n  \u22a5              \u220e\n\n\u2227-zero\u02e1 : LeftZero \u22a5 _\u2227_\n\u2227-zero\u02e1 = comm\u2227ze\u02b3\u21d2ze\u02e1 \u2227-comm \u2227-zero\u02b3\n\n\u2227-zero : Zero \u22a5 _\u2227_\n\u2227-zero = \u2227-zero\u02e1 , \u2227-zero\u02b3\n\n\u2228-zero\u02b3 : \u2200 x \u2192 x \u2228 \u22a4 \u2248 \u22a4\n\u2228-zero\u02b3 x = begin\n  x \u2228 \u22a4          \u2248\u27e8 \u2228-cong\u02e1 (\u2228-complement\u02b3 x) \u27e8\n  x \u2228  x  \u2228 \u00ac x  \u2248\u27e8 \u2228-assoc x x (\u00ac x) \u27e8\n  (x \u2228 x) \u2228 \u00ac x  \u2248\u27e8 \u2228-cong\u02b3 (\u2228-idem x) \u27e9\n  x       \u2228 \u00ac x  \u2248\u27e8 \u2228-complement\u02b3 x \u27e9\n  \u22a4              \u220e\n\n\u2228-zero\u02e1 : LeftZero \u22a4 _\u2228_\n\u2228-zero\u02e1 = comm\u2227ze\u02b3\u21d2ze\u02e1 \u2228-comm \u2228-zero\u02b3\n\n\u2228-zero : Zero \u22a4 _\u2228_\n\u2228-zero = \u2228-zero\u02e1 , \u2228-zero\u02b3\n\n\u2228-\u22a5-isMonoid : IsMonoid _\u2228_ \u22a5\n\u2228-\u22a5-isMonoid = record\n  { isSemigroup = \u2228-isSemigroup\n  ; identity    = \u2228-identity\n  }\n\n\u2227-\u22a4-isMonoid : IsMonoid _\u2227_ \u22a4\n\u2227-\u22a4-isMonoid = record\n  { isSemigroup = \u2227-isSemigroup\n  ; identity    = \u2227-identity\n  }\n\n\u2228-\u22a5-isCommutativeMonoid : IsCommutativeMonoid _\u2228_ \u22a5\n\u2228-\u22a5-isCommutativeMonoid = record\n  { isMonoid = \u2228-\u22a5-isMonoid\n  ; comm     = \u2228-comm\n  }\n\n\u2227-\u22a4-isCommutativeMonoid : IsCommutativeMonoid _\u2227_ \u22a4\n\u2227-\u22a4-isCommutativeMonoid = record\n  { isMonoid = \u2227-\u22a4-isMonoid\n  ; comm     = \u2227-comm\n  }\n\n\u2228-\u2227-isSemiring : IsSemiring _\u2228_ _\u2227_ \u22a5 \u22a4\n\u2228-\u2227-isSemiring = record\n  { isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = \u2228-\u22a5-isCommutativeMonoid\n    ; *-cong = \u2227-cong\n    ; *-assoc = \u2227-assoc\n    ; *-identity = \u2227-identity\n    ; distrib = \u2227-distrib-\u2228\n    }\n  ; zero = \u2227-zero\n  }\n\n\u2227-\u2228-isSemiring : IsSemiring _\u2227_ _\u2228_ \u22a4 \u22a5\n\u2227-\u2228-isSemiring = record\n  { isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = \u2227-\u22a4-isCommutativeMonoid\n    ; *-cong = \u2228-cong\n    ; *-assoc = \u2228-assoc\n    ; *-identity = \u2228-identity\n    ; distrib = \u2228-distrib-\u2227\n    }\n  ; zero = \u2228-zero\n  }\n\n\u2228-\u2227-isCommutativeSemiring : IsCommutativeSemiring _\u2228_ _\u2227_ \u22a5 \u22a4\n\u2228-\u2227-isCommutativeSemiring = record\n  { isSemiring = \u2228-\u2227-isSemiring\n  ; *-comm = \u2227-comm\n  }\n\n\u2227-\u2228-isCommutativeSemiring : IsCommutativeSemiring _\u2227_ _\u2228_ \u22a4 \u22a5\n\u2227-\u2228-isCommutativeSemiring = record\n  { isSemiring = \u2227-\u2228-isSemiring\n  ; *-comm = \u2228-comm\n  }\n\n\u2228-\u2227-commutativeSemiring : CommutativeSemiring _ _\n\u2228-\u2227-commutativeSemiring = record\n  { isCommutativeSemiring = \u2228-\u2227-isCommutativeSemiring\n  }\n\n\u2227-\u2228-commutativeSemiring : CommutativeSemiring _ _\n\u2227-\u2228-commutativeSemiring = record\n  { isCommutativeSemiring = \u2227-\u2228-isCommutativeSemiring\n  }\n\n------------------------------------------------------------------------\n-- Some other properties\n\n-- I took the statement of this lemma (called Uniqueness of\n-- Complements) from some course notes, \"Boolean Algebra\", written\n-- by Gert Smolka.\n\nprivate\n  lemma : \u2200 x y \u2192 x \u2227 y \u2248 \u22a5 \u2192 x \u2228 y \u2248 \u22a4 \u2192 \u00ac x \u2248 y\n  lemma x y x\u2227y=\u22a5 x\u2228y=\u22a4 = begin\n    \u00ac x                \u2248\u27e8 \u2227-identity\u02b3 _ \u27e8\n    \u00ac x \u2227 \u22a4            \u2248\u27e8 \u2227-cong\u02e1 x\u2228y=\u22a4 \u27e8\n    \u00ac x \u2227 (x \u2228 y)      \u2248\u27e8  \u2227-distrib\u02e1-\u2228 _ _ _ \u27e9\n    \u00ac x \u2227 x \u2228 \u00ac x \u2227 y  \u2248\u27e8  \u2228-cong\u02b3 $ \u2227-complement\u02e1 _ \u27e9\n    \u22a5 \u2228 \u00ac x \u2227 y        \u2248\u27e8 \u2228-cong\u02b3 x\u2227y=\u22a5 \u27e8\n    x \u2227 y \u2228 \u00ac x \u2227 y    \u2248\u27e8 \u2227-distrib\u02b3-\u2228 _ _ _ \u27e8\n    (x \u2228 \u00ac x) \u2227 y      \u2248\u27e8  \u2227-cong\u02b3 $ \u2228-complement\u02b3 _ \u27e9\n    \u22a4 \u2227 y              \u2248\u27e8  \u2227-identity\u02e1 _ \u27e9\n    y                  \u220e\n\n\u00ac\u22a5\u2248\u22a4 : \u00ac \u22a5 \u2248 \u22a4\n\u00ac\u22a5\u2248\u22a4 = lemma \u22a5 \u22a4 (\u2227-identity\u02b3 _) (\u2228-zero\u02b3 _)\n\n\u00ac\u22a4\u2248\u22a5 : \u00ac \u22a4 \u2248 \u22a5\n\u00ac\u22a4\u2248\u22a5 = lemma \u22a4 \u22a5 (\u2227-zero\u02b3 _) (\u2228-identity\u02b3 _)\n\n\u00ac-involutive : Involutive \u00ac_\n\u00ac-involutive x = lemma (\u00ac x) x (\u2227-complement\u02e1 _) (\u2228-complement\u02e1 _)\n\ndeMorgan\u2081 : \u2200 x y \u2192 \u00ac (x \u2227 y) \u2248 \u00ac x \u2228 \u00ac y\ndeMorgan\u2081 x y = lemma (x \u2227 y) (\u00ac x \u2228 \u00ac y) lem\u2081 lem\u2082\n  where\n  lem\u2081 = begin\n    (x \u2227 y) \u2227 (\u00ac x \u2228 \u00ac y)          \u2248\u27e8 \u2227-distrib\u02e1-\u2228 _ _ _ \u27e9\n    (x \u2227 y) \u2227 \u00ac x \u2228 (x \u2227 y) \u2227 \u00ac y  \u2248\u27e8 \u2228-cong\u02b3 $ \u2227-cong\u02b3 $ \u2227-comm _ _ \u27e9\n    (y \u2227 x) \u2227 \u00ac x \u2228 (x \u2227 y) \u2227 \u00ac y  \u2248\u27e8 \u2227-assoc _ _ _ \u27e8 \u2228-cong \u27e9 \u2227-assoc _ _ _ \u27e9\n    y \u2227 (x \u2227 \u00ac x) \u2228 x \u2227 (y \u2227 \u00ac y)  \u2248\u27e8 (\u2227-cong\u02e1 $ \u2227-complement\u02b3 _) \u27e8 \u2228-cong \u27e9\n                                      (\u2227-cong\u02e1 $ \u2227-complement\u02b3 _) \u27e9\n    (y \u2227 \u22a5) \u2228 (x \u2227 \u22a5)              \u2248\u27e8 \u2227-zero\u02b3 _ \u27e8 \u2228-cong \u27e9 \u2227-zero\u02b3 _ \u27e9\n    \u22a5 \u2228 \u22a5                          \u2248\u27e8 \u2228-identity\u02b3 _ \u27e9\n    \u22a5                              \u220e\n\n  lem\u2083 = begin\n    (x \u2227 y) \u2228 \u00ac x          \u2248\u27e8 \u2228-distrib\u02b3-\u2227 _ _ _ \u27e9\n    (x \u2228 \u00ac x) \u2227 (y \u2228 \u00ac x)  \u2248\u27e8 \u2227-cong\u02b3 $ \u2228-complement\u02b3 _ \u27e9\n    \u22a4 \u2227 (y \u2228 \u00ac x)          \u2248\u27e8 \u2227-identity\u02e1 _ \u27e9\n    y \u2228 \u00ac x                \u2248\u27e8 \u2228-comm _ _ \u27e9\n    \u00ac x \u2228 y                \u220e\n\n  lem\u2082 = begin\n    (x \u2227 y) \u2228 (\u00ac x \u2228 \u00ac y)  \u2248\u27e8 \u2228-assoc _ _ _ \u27e8\n    ((x \u2227 y) \u2228 \u00ac x) \u2228 \u00ac y  \u2248\u27e8 \u2228-cong\u02b3 lem\u2083 \u27e9\n    (\u00ac x \u2228 y) \u2228 \u00ac y        \u2248\u27e8 \u2228-assoc _ _ _ \u27e9\n    \u00ac x \u2228 (y \u2228 \u00ac y)        \u2248\u27e8 \u2228-cong\u02e1 $ \u2228-complement\u02b3 _ \u27e9\n    \u00ac x \u2228 \u22a4                \u2248\u27e8 \u2228-zero\u02b3 _ \u27e9\n    \u22a4                      \u220e\n\ndeMorgan\u2082 : \u2200 x y \u2192 \u00ac (x \u2228 y) \u2248 \u00ac x \u2227 \u00ac y\ndeMorgan\u2082 x y = begin\n  \u00ac (x \u2228 y)          \u2248\u27e8 \u00ac-cong $ ((\u00ac-involutive _) \u27e8 \u2228-cong \u27e9 (\u00ac-involutive _)) \u27e8\n  \u00ac (\u00ac \u00ac x \u2228 \u00ac \u00ac y)  \u2248\u27e8 \u00ac-cong $ deMorgan\u2081 _ _ \u27e8\n  \u00ac \u00ac (\u00ac x \u2227 \u00ac y)    \u2248\u27e8 \u00ac-involutive _ \u27e9\n  \u00ac x \u2227 \u00ac y          \u220e\n\n------------------------------------------------------------------------\n-- (\u2295, \u2227, id, \u22a5, \u22a4) is a commutative ring\n\n-- This construction is parameterised over the definition of xor.\n\nmodule XorRing\n  (xor : Op\u2082 Carrier)\n  (\u2295-def : \u2200 x y \u2192 xor x y \u2248 (x \u2228 y) \u2227 \u00ac (x \u2227 y))\n  where\n\n  private\n    infixl 6 _\u2295_\n\n    _\u2295_ : Op\u2082 Carrier\n    _\u2295_ = xor\n\n    helper : \u2200 {x y u v} \u2192 x \u2248 y \u2192 u \u2248 v \u2192 x \u2227 \u00ac u \u2248 y \u2227 \u00ac v\n    helper x\u2248y u\u2248v = x\u2248y \u27e8 \u2227-cong \u27e9 \u00ac-cong u\u2248v\n\n  \u2295-cong : Congruent\u2082 _\u2295_\n  \u2295-cong {x} {y} {u} {v} x\u2248y u\u2248v = begin\n    x \u2295 u                \u2248\u27e8  \u2295-def _ _ \u27e9\n    (x \u2228 u) \u2227 \u00ac (x \u2227 u)  \u2248\u27e8  helper (x\u2248y \u27e8 \u2228-cong \u27e9 u\u2248v)\n                                    (x\u2248y \u27e8 \u2227-cong \u27e9 u\u2248v) \u27e9\n    (y \u2228 v) \u2227 \u00ac (y \u2227 v)  \u2248\u27e8 \u2295-def _ _ \u27e8\n    y \u2295 v                \u220e\n\n  \u2295-comm : Commutative _\u2295_\n  \u2295-comm x y = begin\n    x \u2295 y                \u2248\u27e8  \u2295-def _ _ \u27e9\n    (x \u2228 y) \u2227 \u00ac (x \u2227 y)  \u2248\u27e8  helper (\u2228-comm _ _) (\u2227-comm _ _) \u27e9\n    (y \u2228 x) \u2227 \u00ac (y \u2227 x)  \u2248\u27e8 \u2295-def _ _ \u27e8\n    y \u2295 x                \u220e\n\n  \u00ac-distrib\u02e1-\u2295 : \u2200 x y \u2192 \u00ac (x \u2295 y) \u2248 \u00ac x \u2295 y\n  \u00ac-distrib\u02e1-\u2295 x y = begin\n    \u00ac (x \u2295 y)                              \u2248\u27e8 \u00ac-cong $ \u2295-def _ _ \u27e9\n    \u00ac ((x \u2228 y) \u2227 (\u00ac (x \u2227 y)))              \u2248\u27e8 \u00ac-cong (\u2227-distrib\u02b3-\u2228 _ _ _) \u27e9\n    \u00ac ((x \u2227 \u00ac (x \u2227 y)) \u2228 (y \u2227 \u00ac (x \u2227 y)))  \u2248\u27e8 \u00ac-cong $ \u2228-cong\u02e1 $ \u2227-cong\u02e1 $ \u00ac-cong (\u2227-comm _ _) \u27e9\n    \u00ac ((x \u2227 \u00ac (x \u2227 y)) \u2228 (y \u2227 \u00ac (y \u2227 x)))  \u2248\u27e8 \u00ac-cong $ lem _ _ \u27e8 \u2228-cong \u27e9 lem _ _ \u27e9\n    \u00ac ((x \u2227 \u00ac y) \u2228 (y \u2227 \u00ac x))              \u2248\u27e8 deMorgan\u2082 _ _ \u27e9\n    \u00ac (x \u2227 \u00ac y) \u2227 \u00ac (y \u2227 \u00ac x)              \u2248\u27e8 \u2227-cong\u02b3 $ deMorgan\u2081 _ _ \u27e9\n    (\u00ac x \u2228 (\u00ac \u00ac y)) \u2227 \u00ac (y \u2227 \u00ac x)          \u2248\u27e8 helper (\u2228-cong\u02e1 $ \u00ac-involutive _) (\u2227-comm _ _) \u27e9\n    (\u00ac x \u2228 y) \u2227 \u00ac (\u00ac x \u2227 y)                \u2248\u27e8 \u2295-def _ _ \u27e8\n    \u00ac x \u2295 y                                \u220e\n    where\n    lem : \u2200 x y \u2192 x \u2227 \u00ac (x \u2227 y) \u2248 x \u2227 \u00ac y\n    lem x y = begin\n      x \u2227 \u00ac (x \u2227 y)          \u2248\u27e8 \u2227-cong\u02e1 $ deMorgan\u2081 _ _ \u27e9\n      x \u2227 (\u00ac x \u2228 \u00ac y)        \u2248\u27e8 \u2227-distrib\u02e1-\u2228 _ _ _ \u27e9\n      (x \u2227 \u00ac x) \u2228 (x \u2227 \u00ac y)  \u2248\u27e8 \u2228-cong\u02b3 $ \u2227-complement\u02b3 _ \u27e9\n      \u22a5 \u2228 (x \u2227 \u00ac y)          \u2248\u27e8 \u2228-identity\u02e1 _ \u27e9\n      x \u2227 \u00ac y                \u220e\n\n  \u00ac-distrib\u02b3-\u2295 : \u2200 x y \u2192 \u00ac (x \u2295 y) \u2248 x \u2295 \u00ac y\n  \u00ac-distrib\u02b3-\u2295 x y = begin\n    \u00ac (x \u2295 y)  \u2248\u27e8 \u00ac-cong $ \u2295-comm _ _ \u27e9\n    \u00ac (y \u2295 x)  \u2248\u27e8 \u00ac-distrib\u02e1-\u2295 _ _ \u27e9\n    \u00ac y \u2295 x    \u2248\u27e8 \u2295-comm _ _ \u27e9\n    x \u2295 \u00ac y    \u220e\n\n  \u2295-annihilates-\u00ac : \u2200 x y \u2192 x \u2295 y \u2248 \u00ac x \u2295 \u00ac y\n  \u2295-annihilates-\u00ac x y = begin\n    x \u2295 y        \u2248\u27e8 \u00ac-involutive _ \u27e8\n    \u00ac \u00ac (x \u2295 y)  \u2248\u27e8  \u00ac-cong $ \u00ac-distrib\u02e1-\u2295 _ _ \u27e9\n    \u00ac (\u00ac x \u2295 y)  \u2248\u27e8  \u00ac-distrib\u02b3-\u2295 _ _ \u27e9\n    \u00ac x \u2295 \u00ac y    \u220e\n\n  \u2295-identity\u02e1 : LeftIdentity \u22a5 _\u2295_\n  \u2295-identity\u02e1 x = begin\n    \u22a5 \u2295 x                \u2248\u27e8 \u2295-def _ _ \u27e9\n    (\u22a5 \u2228 x) \u2227 \u00ac (\u22a5 \u2227 x)  \u2248\u27e8 helper (\u2228-identity\u02e1 _) (\u2227-zero\u02e1 _) \u27e9\n    x \u2227 \u00ac \u22a5              \u2248\u27e8 \u2227-cong\u02e1 \u00ac\u22a5\u2248\u22a4 \u27e9\n    x \u2227 \u22a4                \u2248\u27e8 \u2227-identity\u02b3 _ \u27e9\n    x                    \u220e\n\n  \u2295-identity\u02b3 : RightIdentity \u22a5 _\u2295_\n  \u2295-identity\u02b3 _ = \u2295-comm _ _ \u27e8 trans \u27e9 \u2295-identity\u02e1 _\n\n  \u2295-identity : Identity \u22a5 _\u2295_\n  \u2295-identity = \u2295-identity\u02e1 , \u2295-identity\u02b3\n\n  \u2295-inverse\u02e1 : LeftInverse \u22a5 id _\u2295_\n  \u2295-inverse\u02e1 x = begin\n    x \u2295 x               \u2248\u27e8 \u2295-def _ _ \u27e9\n    (x \u2228 x) \u2227 \u00ac (x \u2227 x) \u2248\u27e8 helper (\u2228-idem _) (\u2227-idem _) \u27e9\n    x \u2227 \u00ac x             \u2248\u27e8 \u2227-complement\u02b3 _ \u27e9\n    \u22a5                   \u220e\n\n  \u2295-inverse\u02b3 : RightInverse \u22a5 id _\u2295_\n  \u2295-inverse\u02b3 _ = \u2295-comm _ _ \u27e8 trans \u27e9 \u2295-inverse\u02e1 _\n\n  \u2295-inverse : Inverse \u22a5 id _\u2295_\n  \u2295-inverse = \u2295-inverse\u02e1 , \u2295-inverse\u02b3\n\n  \u2227-distrib\u02e1-\u2295 : _\u2227_ DistributesOver\u02e1 _\u2295_\n  \u2227-distrib\u02e1-\u2295 x y z = begin\n    x \u2227 (y \u2295 z)                \u2248\u27e8 \u2227-cong\u02e1 $ \u2295-def _ _ \u27e9\n    x \u2227 ((y \u2228 z) \u2227 \u00ac (y \u2227 z))  \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n    (x \u2227 (y \u2228 z)) \u2227 \u00ac (y \u2227 z)  \u2248\u27e8 \u2227-cong\u02e1 $ deMorgan\u2081 _ _ \u27e9\n    (x \u2227 (y \u2228 z)) \u2227\n    (\u00ac y \u2228 \u00ac z)                \u2248\u27e8 \u2228-identity\u02e1 _ \u27e8\n    \u22a5 \u2228\n    ((x \u2227 (y \u2228 z)) \u2227\n    (\u00ac y \u2228 \u00ac z))               \u2248\u27e8 \u2228-cong\u02b3 lem\u2083 \u27e9\n    ((x \u2227 (y \u2228 z)) \u2227 \u00ac x) \u2228\n    ((x \u2227 (y \u2228 z)) \u2227\n    (\u00ac y \u2228 \u00ac z))               \u2248\u27e8 \u2227-distrib\u02e1-\u2228 _ _ _ \u27e8\n    (x \u2227 (y \u2228 z)) \u2227\n    (\u00ac x \u2228 (\u00ac y \u2228 \u00ac z))        \u2248\u27e8 \u2227-cong\u02e1 $ \u2228-cong\u02e1 (deMorgan\u2081 _ _) \u27e8\n    (x \u2227 (y \u2228 z)) \u2227\n    (\u00ac x \u2228 \u00ac (y \u2227 z))          \u2248\u27e8 \u2227-cong\u02e1 (deMorgan\u2081 _ _) \u27e8\n    (x \u2227 (y \u2228 z)) \u2227\n    \u00ac (x \u2227 (y \u2227 z))            \u2248\u27e8 helper refl lem\u2081 \u27e9\n    (x \u2227 (y \u2228 z)) \u2227\n    \u00ac ((x \u2227 y) \u2227 (x \u2227 z))      \u2248\u27e8 \u2227-cong\u02b3 $ \u2227-distrib\u02e1-\u2228 _ _ _ \u27e9\n    ((x \u2227 y) \u2228 (x \u2227 z)) \u2227\n    \u00ac ((x \u2227 y) \u2227 (x \u2227 z))      \u2248\u27e8 \u2295-def _ _ \u27e8\n    (x \u2227 y) \u2295 (x \u2227 z)          \u220e\n      where\n      lem\u2082 = begin\n        x \u2227 (y \u2227 z)  \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n        (x \u2227 y) \u2227 z  \u2248\u27e8 \u2227-cong\u02b3 $ \u2227-comm _ _ \u27e9\n        (y \u2227 x) \u2227 z  \u2248\u27e8 \u2227-assoc _ _ _ \u27e9\n        y \u2227 (x \u2227 z)  \u220e\n\n      lem\u2081 = begin\n        x \u2227 (y \u2227 z)        \u2248\u27e8 \u2227-cong\u02b3 (\u2227-idem _) \u27e8\n        (x \u2227 x) \u2227 (y \u2227 z)  \u2248\u27e8 \u2227-assoc _ _ _ \u27e9\n        x \u2227 (x \u2227 (y \u2227 z))  \u2248\u27e8 \u2227-cong\u02e1 lem\u2082 \u27e9\n        x \u2227 (y \u2227 (x \u2227 z))  \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n        (x \u2227 y) \u2227 (x \u2227 z)  \u220e\n\n      lem\u2083 = begin\n        \u22a5                      \u2248\u27e8 \u2227-zero\u02b3 _ \u27e8\n        (y \u2228 z) \u2227 \u22a5            \u2248\u27e8 \u2227-cong\u02e1 (\u2227-complement\u02b3 _) \u27e8\n        (y \u2228 z) \u2227 (x \u2227 \u00ac x)    \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n        ((y \u2228 z) \u2227 x) \u2227 \u00ac x    \u2248\u27e8 \u2227-cong\u02b3 (\u2227-comm _ _) \u27e9\n        (x \u2227 (y \u2228 z)) \u2227 \u00ac x    \u220e\n\n  \u2227-distrib\u02b3-\u2295 : _\u2227_ DistributesOver\u02b3 _\u2295_\n  \u2227-distrib\u02b3-\u2295 = comm\u2227distr\u02e1\u21d2distr\u02b3 \u2295-cong \u2227-comm \u2227-distrib\u02e1-\u2295\n\n  \u2227-distrib-\u2295 : _\u2227_ DistributesOver _\u2295_\n  \u2227-distrib-\u2295 = \u2227-distrib\u02e1-\u2295 , \u2227-distrib\u02b3-\u2295\n\n  private\n\n    lemma\u2082 : \u2200 x y u v \u2192\n             (x \u2227 y) \u2228 (u \u2227 v) \u2248\n             ((x \u2228 u) \u2227 (y \u2228 u)) \u2227\n             ((x \u2228 v) \u2227 (y \u2228 v))\n    lemma\u2082 x y u v = begin\n        (x \u2227 y) \u2228 (u \u2227 v)              \u2248\u27e8 \u2228-distrib\u02e1-\u2227 _ _ _ \u27e9\n        ((x \u2227 y) \u2228 u) \u2227 ((x \u2227 y) \u2228 v)  \u2248\u27e8 \u2228-distrib\u02b3-\u2227 _ _ _\n                                            \u27e8 \u2227-cong \u27e9\n                                          \u2228-distrib\u02b3-\u2227 _ _ _ \u27e9\n        ((x \u2228 u) \u2227 (y \u2228 u)) \u2227\n        ((x \u2228 v) \u2227 (y \u2228 v))            \u220e\n\n  \u2295-assoc : Associative _\u2295_\n  \u2295-assoc x y z = sym $ begin\n    x \u2295 (y \u2295 z)                                \u2248\u27e8 \u2295-cong refl (\u2295-def _ _) \u27e9\n    x \u2295 ((y \u2228 z) \u2227 \u00ac (y \u2227 z))                  \u2248\u27e8 \u2295-def _ _ \u27e9\n      (x \u2228 ((y \u2228 z) \u2227 \u00ac (y \u2227 z))) \u2227\n    \u00ac (x \u2227 ((y \u2228 z) \u2227 \u00ac (y \u2227 z)))              \u2248\u27e8 \u2227-cong lem\u2083 lem\u2084 \u27e9\n    (((x \u2228 y) \u2228 z) \u2227 ((x \u2228 \u00ac y) \u2228 \u00ac z)) \u2227\n    (((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z))    \u2248\u27e8 \u2227-assoc _ _ _ \u27e9\n    ((x \u2228 y) \u2228 z) \u2227\n    (((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227\n     (((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z)))  \u2248\u27e8 \u2227-cong\u02e1 lem\u2085 \u27e9\n    ((x \u2228 y) \u2228 z) \u2227\n    (((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227\n     (((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z)))  \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n    (((x \u2228 y) \u2228 z) \u2227 ((\u00ac x \u2228 \u00ac y) \u2228 z)) \u2227\n    (((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z))    \u2248\u27e8 \u2227-cong lem\u2081 lem\u2082 \u27e9\n      (((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2228 z) \u2227\n    \u00ac (((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2227 z)              \u2248\u27e8 \u2295-def _ _ \u27e8\n    ((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2295 z                  \u2248\u27e8 \u2295-cong (\u2295-def _ _) refl \u27e8\n    (x \u2295 y) \u2295 z                                \u220e\n    where\n    lem\u2081 = begin\n      ((x \u2228 y) \u2228 z) \u2227 ((\u00ac x \u2228 \u00ac y) \u2228 z)  \u2248\u27e8 \u2228-distrib\u02b3-\u2227 _ _ _ \u27e8\n      ((x \u2228 y) \u2227 (\u00ac x \u2228 \u00ac y)) \u2228 z        \u2248\u27e8 \u2228-cong\u02b3 $ \u2227-cong\u02e1 (deMorgan\u2081 _ _) \u27e8\n      ((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2228 z          \u220e\n\n    lem\u2082\u2032 = begin\n      (x \u2228 \u00ac y) \u2227 (\u00ac x \u2228 y)              \u2248\u27e8 \u2227-cong (\u2227-identity\u02e1 _) (\u2227-identity\u02b3 _) \u27e8\n      (\u22a4 \u2227 (x \u2228 \u00ac y)) \u2227 ((\u00ac x \u2228 y) \u2227 \u22a4)  \u2248\u27e8 \u2227-cong\n                                              (\u2227-cong (\u2228-complement\u02e1 _) (\u2228-comm _ _))\n                                              (\u2227-cong\u02e1 $ \u2228-complement\u02e1 _) \u27e8\n      ((\u00ac x \u2228 x) \u2227 (\u00ac y \u2228 x)) \u2227\n      ((\u00ac x \u2228 y) \u2227 (\u00ac y \u2228 y))            \u2248\u27e8 lemma\u2082 _ _ _ _ \u27e8\n      (\u00ac x \u2227 \u00ac y) \u2228 (x \u2227 y)              \u2248\u27e8 \u2228-cong (deMorgan\u2082 _ _) (\u00ac-involutive _) \u27e8\n      \u00ac (x \u2228 y) \u2228 \u00ac \u00ac (x \u2227 y)            \u2248\u27e8 deMorgan\u2081 _ _ \u27e8\n      \u00ac ((x \u2228 y) \u2227 \u00ac (x \u2227 y))            \u220e\n\n    lem\u2082 = begin\n      ((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z)  \u2248\u27e8 \u2228-distrib\u02b3-\u2227 _ _ _ \u27e8\n      ((x \u2228 \u00ac y) \u2227 (\u00ac x \u2228 y)) \u2228 \u00ac z          \u2248\u27e8 \u2228-cong\u02b3 lem\u2082\u2032 \u27e9\n      \u00ac ((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2228 \u00ac z          \u2248\u27e8 deMorgan\u2081 _ _ \u27e8\n      \u00ac (((x \u2228 y) \u2227 \u00ac (x \u2227 y)) \u2227 z)          \u220e\n\n    lem\u2083 = begin\n      x \u2228 ((y \u2228 z) \u2227 \u00ac (y \u2227 z))          \u2248\u27e8 \u2228-cong\u02e1 $ \u2227-cong\u02e1 $ deMorgan\u2081 _ _ \u27e9\n      x \u2228 ((y \u2228 z) \u2227 (\u00ac y \u2228 \u00ac z))        \u2248\u27e8 \u2228-distrib\u02e1-\u2227 _ _ _ \u27e9\n      (x \u2228 (y \u2228 z)) \u2227 (x \u2228 (\u00ac y \u2228 \u00ac z))  \u2248\u27e8 \u2228-assoc _ _ _ \u27e8 \u2227-cong \u27e9 \u2228-assoc _ _ _ \u27e8\n      ((x \u2228 y) \u2228 z) \u2227 ((x \u2228 \u00ac y) \u2228 \u00ac z)  \u220e\n\n    lem\u2084\u2032 = begin\n      \u00ac ((y \u2228 z) \u2227 \u00ac (y \u2227 z))    \u2248\u27e8 deMorgan\u2081 _ _ \u27e9\n      \u00ac (y \u2228 z) \u2228 \u00ac \u00ac (y \u2227 z)    \u2248\u27e8 deMorgan\u2082 _ _ \u27e8 \u2228-cong \u27e9 \u00ac-involutive _ \u27e9\n      (\u00ac y \u2227 \u00ac z) \u2228 (y \u2227 z)      \u2248\u27e8 lemma\u2082 _ _ _ _ \u27e9\n      ((\u00ac y \u2228 y) \u2227 (\u00ac z \u2228 y)) \u2227\n      ((\u00ac y \u2228 z) \u2227 (\u00ac z \u2228 z))    \u2248\u27e8 (\u2228-complement\u02e1 _ \u27e8 \u2227-cong \u27e9 \u2228-comm _ _)\n                                      \u27e8 \u2227-cong \u27e9\n                                   (\u2227-cong\u02e1 $ \u2228-complement\u02e1 _) \u27e9\n      (\u22a4 \u2227 (y \u2228 \u00ac z)) \u2227\n      ((\u00ac y \u2228 z) \u2227 \u22a4)            \u2248\u27e8 \u2227-identity\u02e1 _ \u27e8 \u2227-cong \u27e9 \u2227-identity\u02b3 _ \u27e9\n      (y \u2228 \u00ac z) \u2227 (\u00ac y \u2228 z)      \u220e\n\n    lem\u2084 = begin\n      \u00ac (x \u2227 ((y \u2228 z) \u2227 \u00ac (y \u2227 z)))  \u2248\u27e8 deMorgan\u2081 _ _ \u27e9\n      \u00ac x \u2228 \u00ac ((y \u2228 z) \u2227 \u00ac (y \u2227 z))  \u2248\u27e8 \u2228-cong\u02e1 lem\u2084\u2032 \u27e9\n      \u00ac x \u2228 ((y \u2228 \u00ac z) \u2227 (\u00ac y \u2228 z))  \u2248\u27e8 \u2228-distrib\u02e1-\u2227 _ _ _ \u27e9\n      (\u00ac x \u2228 (y     \u2228 \u00ac z)) \u2227\n      (\u00ac x \u2228 (\u00ac y \u2228 z))              \u2248\u27e8 \u2228-assoc _ _ _ \u27e8 \u2227-cong \u27e9 \u2228-assoc _ _ _ \u27e8\n      ((\u00ac x \u2228 y)     \u2228 \u00ac z) \u2227\n      ((\u00ac x \u2228 \u00ac y) \u2228 z)              \u2248\u27e8 \u2227-comm _ _ \u27e9\n      ((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227\n      ((\u00ac x \u2228 y)     \u2228 \u00ac z)          \u220e\n\n    lem\u2085 = begin\n      ((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227\n      (((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z))    \u2248\u27e8 \u2227-assoc _ _ _ \u27e8\n      (((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227 ((\u00ac x \u2228 \u00ac y) \u2228 z)) \u2227\n      ((\u00ac x \u2228 y) \u2228 \u00ac z)                          \u2248\u27e8 \u2227-cong\u02b3 $ \u2227-comm _ _ \u27e9\n      (((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227 ((x \u2228 \u00ac y) \u2228 \u00ac z)) \u2227\n      ((\u00ac x \u2228 y) \u2228 \u00ac z)                          \u2248\u27e8 \u2227-assoc _ _ _ \u27e9\n      ((\u00ac x \u2228 \u00ac y) \u2228 z) \u2227\n      (((x \u2228 \u00ac y) \u2228 \u00ac z) \u2227 ((\u00ac x \u2228 y) \u2228 \u00ac z))    \u220e\n\n  \u2295-isMagma : IsMagma _\u2295_\n  \u2295-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = \u2295-cong\n    }\n\n  \u2295-isSemigroup : IsSemigroup _\u2295_\n  \u2295-isSemigroup = record\n    { isMagma = \u2295-isMagma\n    ; assoc   = \u2295-assoc\n    }\n\n  \u2295-\u22a5-isMonoid : IsMonoid _\u2295_ \u22a5\n  \u2295-\u22a5-isMonoid = record\n    { isSemigroup = \u2295-isSemigroup\n    ; identity    = \u2295-identity\n    }\n\n  \u2295-\u22a5-isGroup : IsGroup _\u2295_ \u22a5 id\n  \u2295-\u22a5-isGroup = record\n    { isMonoid = \u2295-\u22a5-isMonoid\n    ; inverse  = \u2295-inverse\n    ; \u207b\u00b9-cong  = id\n    }\n\n  \u2295-\u22a5-isAbelianGroup : IsAbelianGroup _\u2295_ \u22a5 id\n  \u2295-\u22a5-isAbelianGroup = record\n    { isGroup = \u2295-\u22a5-isGroup\n    ; comm    = \u2295-comm\n    }\n\n  \u2295-\u2227-isRing : IsRing _\u2295_ _\u2227_ id \u22a5 \u22a4\n  \u2295-\u2227-isRing = record\n    { +-isAbelianGroup = \u2295-\u22a5-isAbelianGroup\n    ; *-cong = \u2227-cong\n    ; *-assoc = \u2227-assoc\n    ; *-identity = \u2227-identity\n    ; distrib = \u2227-distrib-\u2295\n    }\n\n  \u2295-\u2227-isCommutativeRing : IsCommutativeRing _\u2295_ _\u2227_ id \u22a5 \u22a4\n  \u2295-\u2227-isCommutativeRing = record\n    { isRing = \u2295-\u2227-isRing\n    ; *-comm = \u2227-comm\n    }\n\n  \u2295-\u2227-commutativeRing : CommutativeRing _ _\n  \u2295-\u2227-commutativeRing = record\n    { isCommutativeRing = \u2295-\u2227-isCommutativeRing\n    }\n\n\ninfixl 6 _\u2295_\n\n_\u2295_ : Op\u2082 Carrier\nx \u2295 y = (x \u2228 y) \u2227 \u00ac (x \u2227 y)\n\nmodule DefaultXorRing = XorRing _\u2295_ (\u03bb _ _ \u2192 refl)\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.3\n\n\u22a5\u2249\u22a4 = \u00ac\u22a5\u2248\u22a4\n{-# WARNING_ON_USAGE \u22a5\u2249\u22a4\n\"Warning: \u22a5\u2249\u22a4 was deprecated in v2.3.\nPlease use \u00ac\u22a5\u2248\u22a4 instead.\"\n#-}\n\u22a4\u2249\u22a5 = \u00ac\u22a4\u2248\u22a5\n{-# WARNING_ON_USAGE \u22a4\u2249\u22a5\n\"Warning: \u22a4\u2249\u22a5 was deprecated in v2.3.\nPlease use \u00ac\u22a4\u2248\u22a5 instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Lattice/Properties/DistributiveLattice/","title":"Algebra.Lattice.Properties.DistributiveLattice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some derivable properties\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Lattice.Bundles using (DistributiveLattice)\n\nmodule Algebra.Lattice.Properties.DistributiveLattice\n  {dl\u2081 dl\u2082} (DL : DistributiveLattice dl\u2081 dl\u2082)\n  where\n\nimport Algebra.Lattice.Properties.Lattice as LatticeProperties\nopen DistributiveLattice DL\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Lattice.Structures _\u2248_\nopen import Relation.Binary.Reasoning.Setoid setoid\n\n------------------------------------------------------------------------\n-- Export properties of lattices\n\nopen LatticeProperties lattice public\n\n------------------------------------------------------------------------\n-- The dual construction is also a distributive lattice.\n\n\u2227-\u2228-isDistributiveLattice : IsDistributiveLattice _\u2227_ _\u2228_\n\u2227-\u2228-isDistributiveLattice = record\n  { isLattice   = \u2227-\u2228-isLattice\n  ; \u2228-distrib-\u2227 = \u2227-distrib-\u2228\n  ; \u2227-distrib-\u2228 = \u2228-distrib-\u2227\n  }\n\n\u2227-\u2228-distributiveLattice : DistributiveLattice _ _\n\u2227-\u2228-distributiveLattice = record\n  { isDistributiveLattice = \u2227-\u2228-isDistributiveLattice\n  }\n</pre>"},{"location":"md/Algebra/Lattice/Properties/Lattice/","title":"Algebra.Lattice.Properties.Lattice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some derivable properties of lattices\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Lattice.Bundles using (Lattice; Semilattice)\n\nmodule Algebra.Lattice.Properties.Lattice\n  {l\u2081 l\u2082} (L : Lattice l\u2081 l\u2082) where\n\nimport Algebra.Lattice.Properties.Semilattice as SemilatticeProperties\nopen import Data.Product.Base using (_,_; swap)\nopen Lattice L\nopen import Algebra.Definitions _\u2248_ using (Idempotent; Congruent\u2082)\nopen import Algebra.Structures _\u2248_ using (IsMagma; IsSemigroup; IsBand)\nopen import Algebra.Lattice.Structures _\u2248_ using (IsLattice; IsSemilattice)\nopen import Function.Base\nopen import Relation.Binary.Reasoning.Setoid setoid\nopen import Relation.Binary.Bundles using (Poset)\nimport Relation.Binary.Lattice as R\n\n------------------------------------------------------------------------\n-- _\u2227_ is a semilattice\n\n\u2227-idem : Idempotent _\u2227_\n\u2227-idem x = begin\n  x \u2227 x            \u2248\u27e8 \u2227-cong\u02e1 (\u2228-absorbs-\u2227 _ _) \u27e8\n  x \u2227 (x \u2228 x \u2227 x)  \u2248\u27e8  \u2227-absorbs-\u2228 _ _ \u27e9\n  x                \u220e\n\n\u2227-isMagma : IsMagma _\u2227_\n\u2227-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = \u2227-cong\n  }\n\n\u2227-isSemigroup : IsSemigroup _\u2227_\n\u2227-isSemigroup = record\n  { isMagma = \u2227-isMagma\n  ; assoc   = \u2227-assoc\n  }\n\n\u2227-isBand : IsBand _\u2227_\n\u2227-isBand = record\n  { isSemigroup = \u2227-isSemigroup\n  ; idem        = \u2227-idem\n  }\n\n\u2227-isSemilattice : IsSemilattice _\u2227_\n\u2227-isSemilattice = record\n  { isBand = \u2227-isBand\n  ; comm   = \u2227-comm\n  }\n\n\u2227-semilattice : Semilattice l\u2081 l\u2082\n\u2227-semilattice = record\n  { isSemilattice = \u2227-isSemilattice\n  }\n\nopen SemilatticeProperties \u2227-semilattice public\n  using\n  ( \u2227-isOrderTheoreticMeetSemilattice\n  ; \u2227-isOrderTheoreticJoinSemilattice\n  ; \u2227-orderTheoreticMeetSemilattice\n  ; \u2227-orderTheoreticJoinSemilattice\n  )\n\n------------------------------------------------------------------------\n-- _\u2228_ is a semilattice\n\n\u2228-idem : Idempotent _\u2228_\n\u2228-idem x = begin\n  x \u2228 x      \u2248\u27e8 \u2228-cong\u02e1 (\u2227-idem _) \u27e8\n  x \u2228 x \u2227 x  \u2248\u27e8  \u2228-absorbs-\u2227 _ _ \u27e9\n  x          \u220e\n\n\u2228-isMagma : IsMagma _\u2228_\n\u2228-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = \u2228-cong\n  }\n\n\u2228-isSemigroup : IsSemigroup _\u2228_\n\u2228-isSemigroup = record\n  { isMagma = \u2228-isMagma\n  ; assoc   = \u2228-assoc\n  }\n\n\u2228-isBand : IsBand _\u2228_\n\u2228-isBand = record\n  { isSemigroup = \u2228-isSemigroup\n  ; idem        = \u2228-idem\n  }\n\n\u2228-isSemilattice : IsSemilattice _\u2228_\n\u2228-isSemilattice = record\n  { isBand = \u2228-isBand\n  ; comm   = \u2228-comm\n  }\n\n\u2228-semilattice : Semilattice l\u2081 l\u2082\n\u2228-semilattice = record\n  { isSemilattice = \u2228-isSemilattice\n  }\n\nopen SemilatticeProperties \u2228-semilattice public\n  using ()\n  renaming\n  ( \u2227-isOrderTheoreticMeetSemilattice to \u2228-isOrderTheoreticMeetSemilattice\n  ; \u2227-isOrderTheoreticJoinSemilattice to \u2228-isOrderTheoreticJoinSemilattice\n  ; \u2227-orderTheoreticMeetSemilattice   to \u2228-orderTheoreticMeetSemilattice\n  ; \u2227-orderTheoreticJoinSemilattice   to \u2228-orderTheoreticJoinSemilattice\n  )\n\n------------------------------------------------------------------------\n-- The dual construction is also a lattice.\n\n\u2227-\u2228-isLattice : IsLattice _\u2227_ _\u2228_\n\u2227-\u2228-isLattice = record\n  { isEquivalence = isEquivalence\n  ; \u2228-comm        = \u2227-comm\n  ; \u2228-assoc       = \u2227-assoc\n  ; \u2228-cong        = \u2227-cong\n  ; \u2227-comm        = \u2228-comm\n  ; \u2227-assoc       = \u2228-assoc\n  ; \u2227-cong        = \u2228-cong\n  ; absorptive    = swap absorptive\n  }\n\n\u2227-\u2228-lattice : Lattice _ _\n\u2227-\u2228-lattice = record\n  { isLattice = \u2227-\u2228-isLattice\n  }\n\n------------------------------------------------------------------------\n-- Every algebraic lattice can be turned into an order-theoretic one.\n\nopen SemilatticeProperties \u2227-semilattice public using (poset)\nopen Poset poset using (_\u2264_; isPartialOrder)\n\n\u2228-\u2227-isOrderTheoreticLattice : R.IsLattice _\u2248_ _\u2264_ _\u2228_ _\u2227_\n\u2228-\u2227-isOrderTheoreticLattice = record\n  { isPartialOrder = isPartialOrder\n  ; supremum       = supremum\n  ; infimum        = infimum\n  }\n  where\n  open R.MeetSemilattice \u2227-orderTheoreticMeetSemilattice using (infimum)\n  open R.JoinSemilattice \u2228-orderTheoreticJoinSemilattice using (x\u2264x\u2228y; y\u2264x\u2228y; \u2228-least)\n    renaming (_\u2264_ to _\u2264\u2032_)\n\n  -- An alternative but equivalent interpretation of the order _\u2264_.\n\n  sound : \u2200 {x y} \u2192 x \u2264\u2032 y \u2192 x \u2264 y\n  sound {x} {y} y\u2248y\u2228x = sym $ begin\n    x \u2227 y        \u2248\u27e8 \u2227-cong\u02e1 y\u2248y\u2228x \u27e9\n    x \u2227 (y \u2228 x)  \u2248\u27e8 \u2227-cong\u02e1 (\u2228-comm y x) \u27e9\n    x \u2227 (x \u2228 y)  \u2248\u27e8 \u2227-absorbs-\u2228 x y \u27e9\n    x            \u220e\n\n  complete : \u2200 {x y} \u2192 x \u2264 y \u2192 x \u2264\u2032 y\n  complete {x} {y} x\u2248x\u2227y = sym $ begin\n    y \u2228 x        \u2248\u27e8 \u2228-cong\u02e1 x\u2248x\u2227y \u27e9\n    y \u2228 (x \u2227 y)  \u2248\u27e8 \u2228-cong\u02e1 (\u2227-comm x y) \u27e9\n    y \u2228 (y \u2227 x)  \u2248\u27e8 \u2228-absorbs-\u2227 y x \u27e9\n    y            \u220e\n\n  supremum : R.Supremum _\u2264_ _\u2228_\n  supremum x y =\n     sound (x\u2264x\u2228y x y) ,\n     sound (y\u2264x\u2228y x y) ,\n     \u03bb z x\u2264z y\u2264z \u2192 sound (\u2228-least (complete x\u2264z) (complete y\u2264z))\n\n\u2228-\u2227-orderTheoreticLattice : R.Lattice _ _ _\n\u2228-\u2227-orderTheoreticLattice = record\n  { isLattice = \u2228-\u2227-isOrderTheoreticLattice\n  }\n</pre>"},{"location":"md/Algebra/Lattice/Properties/Semilattice/","title":"Algebra.Lattice.Properties.Semilattice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some derivable properties of semilattices\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Lattice.Bundles using (Semilattice)\n\nmodule Algebra.Lattice.Properties.Semilattice\n  {c \u2113} (L : Semilattice c \u2113) where\n\nopen import Relation.Binary.Bundles using (Poset)\nimport Relation.Binary.Lattice as B\nimport Relation.Binary.Properties.Poset as PosetProperties\nopen Semilattice L renaming (_\u2219_ to _\u2227_)\n\nopen import Relation.Binary.Reasoning.Setoid setoid\nimport Relation.Binary.Construct.NaturalOrder.Left _\u2248_ _\u2227_\n  as LeftNaturalOrder\n\n------------------------------------------------------------------------\n-- Every semilattice can be turned into a poset via the left natural\n-- order.\n\nposet : Poset c \u2113 \u2113\nposet = LeftNaturalOrder.poset isSemilattice\n\nopen Poset poset using (_\u2264_; _\u2265_; isPartialOrder)\nopen PosetProperties poset using (\u2265-isPartialOrder)\n\n------------------------------------------------------------------------\n-- Every algebraic semilattice can be turned into an order-theoretic one.\n\n\u2227-isOrderTheoreticMeetSemilattice : B.IsMeetSemilattice _\u2248_ _\u2264_ _\u2227_\n\u2227-isOrderTheoreticMeetSemilattice = record\n  { isPartialOrder = isPartialOrder\n  ; infimum        = LeftNaturalOrder.infimum isSemilattice\n  }\n\n\u2227-isOrderTheoreticJoinSemilattice : B.IsJoinSemilattice _\u2248_ _\u2265_ _\u2227_\n\u2227-isOrderTheoreticJoinSemilattice = record\n  { isPartialOrder = \u2265-isPartialOrder\n  ; supremum       = B.IsMeetSemilattice.infimum\n                       \u2227-isOrderTheoreticMeetSemilattice\n  }\n\n\u2227-orderTheoreticMeetSemilattice : B.MeetSemilattice c \u2113 \u2113\n\u2227-orderTheoreticMeetSemilattice = record\n  { isMeetSemilattice = \u2227-isOrderTheoreticMeetSemilattice\n  }\n\n\u2227-orderTheoreticJoinSemilattice : B.JoinSemilattice c \u2113 \u2113\n\u2227-orderTheoreticJoinSemilattice = record\n  { isJoinSemilattice = \u2227-isOrderTheoreticJoinSemilattice\n  }\n</pre>"},{"location":"md/Algebra/Lattice/Structures/","title":"Algebra.Lattice.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some lattice-like structures defined by properties of _\u2227_ and _\u2228_\n-- (not packed up with sets, operations, etc.)\n--\n-- For lattices defined via an order relation, see\n-- Relation.Binary.Lattice.\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra.Lattice`,\n-- unless you want to parameterise it via the equality relation.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Data.Product.Base using (proj\u2081; proj\u2082)\nopen import Level using (_\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Algebra.Lattice.Structures\n  {a \u2113} {A : Set a}  -- The underlying set\n  (_\u2248_ : Rel A \u2113)    -- The underlying equality relation\n  where\n\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Structures _\u2248_\n\n------------------------------------------------------------------------\n-- Structures with 1 binary operation\n\nIsSemilattice = IsCommutativeBand\nmodule IsSemilattice {\u2219} (L : IsSemilattice \u2219) where\n  open IsCommutativeBand L public\n    using (isBand; comm)\n  open IsBand isBand public\n\n-- Used to bring names appropriate for a meet semilattice into scope.\nIsMeetSemilattice = IsSemilattice\nmodule IsMeetSemilattice {\u2227} (L : IsMeetSemilattice \u2227) where\n  open IsSemilattice L public\n    renaming\n    ( \u2219-cong  to \u2227-cong\n    ; \u2219-cong\u02e1 to \u2227-cong\u02e1\n    ; \u2219-cong\u02b3 to \u2227-cong\u02b3\n    )\n\n-- Used to bring names appropriate for a join semilattice into scope.\nIsJoinSemilattice = IsSemilattice\nmodule IsJoinSemilattice {\u2228} (L : IsJoinSemilattice \u2228) where\n  open IsSemilattice L public\n    renaming\n    ( \u2219-cong  to \u2228-cong\n    ; \u2219-cong\u02e1 to \u2228-cong\u02e1\n    ; \u2219-cong\u02b3 to \u2228-cong\u02b3\n    )\n\n------------------------------------------------------------------------\n-- Structures with 1 binary operation &amp; 1 element\n\n-- A bounded semi-lattice is the same thing as an idempotent commutative\n-- monoid.\nIsBoundedSemilattice = IsIdempotentCommutativeMonoid\nmodule IsBoundedSemilattice {\u2219 \u03b5} (L : IsBoundedSemilattice \u2219 \u03b5) where\n\n  open IsIdempotentCommutativeMonoid L public\n    renaming (isCommutativeBand to isSemilattice)\n\n\n-- Used to bring names appropriate for a bounded meet semilattice\n-- into scope.\nIsBoundedMeetSemilattice = IsBoundedSemilattice\nmodule IsBoundedMeetSemilattice {\u2227 \u22a4} (L : IsBoundedMeetSemilattice \u2227 \u22a4)\n  where\n\n  open IsBoundedSemilattice L public\n    using (identity; identity\u02e1; identity\u02b3)\n    renaming (isSemilattice to isMeetSemilattice)\n\n  open IsMeetSemilattice isMeetSemilattice public\n\n\n-- Used to bring names appropriate for a bounded join semilattice\n-- into scope.\nIsBoundedJoinSemilattice = IsBoundedSemilattice\nmodule IsBoundedJoinSemilattice {\u2228 \u22a5} (L : IsBoundedJoinSemilattice \u2228 \u22a5)\n  where\n\n  open IsBoundedSemilattice L public\n    using (identity; identity\u02e1; identity\u02b3)\n    renaming (isSemilattice to isJoinSemilattice)\n\n  open IsJoinSemilattice isJoinSemilattice public\n\n------------------------------------------------------------------------\n-- Structures with 2 binary operations\n\n-- Note that `IsLattice` is not defined in terms of `IsMeetSemilattice`\n-- and `IsJoinSemilattice` for two reasons:\n--   1) it would result in a structure with two *different* proofs that\n--   the equality relation `\u2248` is an equivalence relation.\n--   2) the idempotence laws of \u2228 and \u2227 can be derived from the\n--   absorption laws, which makes the corresponding \"idem\" fields\n--   redundant.\n--\n-- It is possible to construct the `IsLattice` record from\n-- `IsMeetSemilattice` and `IsJoinSemilattice` via the `IsLattice\u2082`\n-- record found in `Algebra.Lattice.Structures.Biased`.\n--\n-- The derived idempotence laws are stated and proved in\n-- `Algebra.Lattice.Properties.Lattice` along with the fact that every\n-- lattice consists of two semilattices.\n\nrecord IsLattice (\u2228 \u2227 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isEquivalence : IsEquivalence _\u2248_\n    \u2228-comm        : Commutative \u2228\n    \u2228-assoc       : Associative \u2228\n    \u2228-cong        : Congruent\u2082 \u2228\n    \u2227-comm        : Commutative \u2227\n    \u2227-assoc       : Associative \u2227\n    \u2227-cong        : Congruent\u2082 \u2227\n    absorptive    : Absorptive \u2228 \u2227\n\n  open IsEquivalence isEquivalence public\n\n  \u2228-absorbs-\u2227 : \u2228 Absorbs \u2227\n  \u2228-absorbs-\u2227 = proj\u2081 absorptive\n\n  \u2227-absorbs-\u2228 : \u2227 Absorbs \u2228\n  \u2227-absorbs-\u2228 = proj\u2082 absorptive\n\n  \u2227-cong\u02e1 : LeftCongruent \u2227\n  \u2227-cong\u02e1 y\u2248z = \u2227-cong refl y\u2248z\n\n  \u2227-cong\u02b3 : RightCongruent \u2227\n  \u2227-cong\u02b3 y\u2248z = \u2227-cong y\u2248z refl\n\n  \u2228-cong\u02e1 : LeftCongruent \u2228\n  \u2228-cong\u02e1 y\u2248z = \u2228-cong refl y\u2248z\n\n  \u2228-cong\u02b3 : RightCongruent \u2228\n  \u2228-cong\u02b3 y\u2248z = \u2228-cong y\u2248z refl\n\n\nrecord IsDistributiveLattice (\u2228 \u2227 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isLattice   : IsLattice \u2228 \u2227\n    \u2228-distrib-\u2227 : \u2228 DistributesOver \u2227\n    \u2227-distrib-\u2228 : \u2227 DistributesOver \u2228\n\n  open IsLattice isLattice public\n\n  \u2228-distrib\u02e1-\u2227 : \u2228 DistributesOver\u02e1 \u2227\n  \u2228-distrib\u02e1-\u2227 = proj\u2081 \u2228-distrib-\u2227\n\n  \u2228-distrib\u02b3-\u2227 : \u2228 DistributesOver\u02b3 \u2227\n  \u2228-distrib\u02b3-\u2227 = proj\u2082 \u2228-distrib-\u2227\n\n  \u2227-distrib\u02e1-\u2228 : \u2227 DistributesOver\u02e1 \u2228\n  \u2227-distrib\u02e1-\u2228 = proj\u2081 \u2227-distrib-\u2228\n\n  \u2227-distrib\u02b3-\u2228 : \u2227 DistributesOver\u02b3 \u2228\n  \u2227-distrib\u02b3-\u2228 = proj\u2082 \u2227-distrib-\u2228\n\n------------------------------------------------------------------------\n-- Structures with 2 binary ops, 1 unary op and 2 elements.\n\nrecord IsBooleanAlgebra (\u2228 \u2227 : Op\u2082 A) (\u00ac : Op\u2081 A) (\u22a4 \u22a5 : A) : Set (a \u2294 \u2113)\n  where\n\n  field\n    isDistributiveLattice : IsDistributiveLattice \u2228 \u2227\n    \u2228-complement          : Inverse \u22a4 \u00ac \u2228\n    \u2227-complement          : Inverse \u22a5 \u00ac \u2227\n    \u00ac-cong                : Congruent\u2081 \u00ac\n\n  open IsDistributiveLattice isDistributiveLattice public\n\n  \u2228-complement\u02e1 : LeftInverse \u22a4 \u00ac \u2228\n  \u2228-complement\u02e1 = proj\u2081 \u2228-complement\n\n  \u2228-complement\u02b3 : RightInverse \u22a4 \u00ac \u2228\n  \u2228-complement\u02b3 = proj\u2082 \u2228-complement\n\n  \u2227-complement\u02e1 : LeftInverse \u22a5 \u00ac \u2227\n  \u2227-complement\u02e1 = proj\u2081 \u2227-complement\n\n  \u2227-complement\u02b3 : RightInverse \u22a5 \u00ac \u2227\n  \u2227-complement\u02b3 = proj\u2082 \u2227-complement\n</pre>"},{"location":"md/Algebra/Morphism/","title":"Algebra.Morphism","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Morphisms between algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Morphism where\n\nimport Algebra.Morphism.Definitions as MorphismDefinitions\nopen import Algebra\nopen import Function.Base\nopen import Level\nopen import Relation.Binary.Core using (Rel; _Preserves_\u27f6_)\nimport Relation.Binary.Reasoning.Setoid as \u2248-Reasoning\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Re-export\n\nmodule Definitions {a b \u2113\u2081} (A : Set a) (B : Set b) (_\u2248_ : Rel B \u2113\u2081) where\n  open MorphismDefinitions A B _\u2248_ public\n\nopen import Algebra.Morphism.Structures public\n\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new definitions re-exported from\n-- `Algebra.Morphism.Structures` as continuing support for the below is\n-- no guaranteed.\n\n-- Version 1.5\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : Semigroup c\u2081 \u2113\u2081)\n         (To   : Semigroup c\u2082 \u2113\u2082) where\n\n  private\n    module F = Semigroup From\n    module T = Semigroup To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsSemigroupMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      \u27e6\u27e7-cong : \u27e6_\u27e7 Preserves F._\u2248_ \u27f6 T._\u2248_\n      \u2219-homo  : Homomorphic\u2082 \u27e6_\u27e7 F._\u2219_ T._\u2219_\n\n  IsSemigroupMorphism-syntax = IsSemigroupMorphism\n  syntax IsSemigroupMorphism-syntax From To F = F Is From -Semigroup\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : Monoid c\u2081 \u2113\u2081)\n         (To   : Monoid c\u2082 \u2113\u2082) where\n\n  private\n    module F = Monoid From\n    module T = Monoid To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsMonoidMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      sm-homo : IsSemigroupMorphism F.semigroup T.semigroup \u27e6_\u27e7\n      \u03b5-homo  : Homomorphic\u2080 \u27e6_\u27e7 F.\u03b5 T.\u03b5\n\n    open IsSemigroupMorphism sm-homo public\n\n  IsMonoidMorphism-syntax = IsMonoidMorphism\n  syntax IsMonoidMorphism-syntax From To F = F Is From -Monoid\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : CommutativeMonoid c\u2081 \u2113\u2081)\n         (To   : CommutativeMonoid c\u2082 \u2113\u2082) where\n\n  private\n    module F = CommutativeMonoid From\n    module T = CommutativeMonoid To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsCommutativeMonoidMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      mn-homo : IsMonoidMorphism F.monoid T.monoid \u27e6_\u27e7\n\n    open IsMonoidMorphism mn-homo public\n\n  IsCommutativeMonoidMorphism-syntax = IsCommutativeMonoidMorphism\n  syntax IsCommutativeMonoidMorphism-syntax From To F = F Is From -CommutativeMonoid\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : IdempotentCommutativeMonoid c\u2081 \u2113\u2081)\n         (To   : IdempotentCommutativeMonoid c\u2082 \u2113\u2082) where\n\n  private\n    module F = IdempotentCommutativeMonoid From\n    module T = IdempotentCommutativeMonoid To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsIdempotentCommutativeMonoidMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      mn-homo : IsMonoidMorphism F.monoid T.monoid \u27e6_\u27e7\n\n    open IsMonoidMorphism mn-homo public\n\n    isCommutativeMonoidMorphism :\n      IsCommutativeMonoidMorphism F.commutativeMonoid T.commutativeMonoid \u27e6_\u27e7\n    isCommutativeMonoidMorphism = record { mn-homo = mn-homo }\n\n  IsIdempotentCommutativeMonoidMorphism-syntax = IsIdempotentCommutativeMonoidMorphism\n  syntax IsIdempotentCommutativeMonoidMorphism-syntax From To F = F Is From -IdempotentCommutativeMonoid\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : Group c\u2081 \u2113\u2081)\n         (To   : Group c\u2082 \u2113\u2082) where\n\n  private\n    module F = Group From\n    module T = Group To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsGroupMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      mn-homo : IsMonoidMorphism F.monoid T.monoid \u27e6_\u27e7\n\n    open IsMonoidMorphism mn-homo public\n\n    \u207b\u00b9-homo : Homomorphic\u2081 \u27e6_\u27e7 F._\u207b\u00b9 T._\u207b\u00b9\n    \u207b\u00b9-homo x = let open \u2248-Reasoning T.setoid in T.unique\u02e1-\u207b\u00b9 \u27e6 x F.\u207b\u00b9 \u27e7 \u27e6 x \u27e7 $ begin\n      \u27e6 x F.\u207b\u00b9 \u27e7 T.\u2219 \u27e6 x \u27e7 \u2248\u27e8 T.sym (\u2219-homo (x F.\u207b\u00b9) x) \u27e9\n      \u27e6 x F.\u207b\u00b9 F.\u2219 x \u27e7     \u2248\u27e8 \u27e6\u27e7-cong (F.inverse\u02e1 x) \u27e9\n      \u27e6 F.\u03b5 \u27e7              \u2248\u27e8 \u03b5-homo \u27e9\n      T.\u03b5 \u220e\n\n  IsGroupMorphism-syntax = IsGroupMorphism\n  syntax IsGroupMorphism-syntax From To F = F Is From -Group\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : AbelianGroup c\u2081 \u2113\u2081)\n         (To   : AbelianGroup c\u2082 \u2113\u2082) where\n\n  private\n    module F = AbelianGroup From\n    module T = AbelianGroup To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsAbelianGroupMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      gp-homo : IsGroupMorphism F.group T.group \u27e6_\u27e7\n\n    open IsGroupMorphism gp-homo public\n\n  IsAbelianGroupMorphism-syntax = IsAbelianGroupMorphism\n  syntax IsAbelianGroupMorphism-syntax From To F = F Is From -AbelianGroup\u27f6 To\n\nmodule _ {c\u2081 \u2113\u2081 c\u2082 \u2113\u2082}\n         (From : Ring c\u2081 \u2113\u2081)\n         (To   : Ring c\u2082 \u2113\u2082) where\n\n  private\n    module F = Ring From\n    module T = Ring To\n  open Definitions F.Carrier T.Carrier T._\u2248_\n\n  record IsRingMorphism (\u27e6_\u27e7 : Morphism) :\n         Set (c\u2081 \u2294 \u2113\u2081 \u2294 c\u2082 \u2294 \u2113\u2082) where\n    field\n      +-abgp-homo : \u27e6_\u27e7 Is F.+-abelianGroup -AbelianGroup\u27f6 T.+-abelianGroup\n      *-mn-homo   : \u27e6_\u27e7 Is F.*-monoid -Monoid\u27f6 T.*-monoid\n\n  IsRingMorphism-syntax = IsRingMorphism\n  syntax IsRingMorphism-syntax From To F = F Is From -Ring\u27f6 To\n\n{-# WARNING_ON_USAGE IsSemigroupMorphism\n\"Warning: IsSemigroupMorphism was deprecated in v1.5.\nPlease use IsMagmaHomomorphism instead.\"\n#-}\n{-# WARNING_ON_USAGE IsMonoidMorphism\n\"Warning: IsMonoidMorphism was deprecated in v1.5.\nPlease use IsMonoidHomomorphism instead.\"\n#-}\n{-# WARNING_ON_USAGE IsCommutativeMonoidMorphism\n\"Warning: IsCommutativeMonoidMorphism was deprecated in v1.5.\nPlease use IsMonoidHomomorphism instead.\"\n#-}\n{-# WARNING_ON_USAGE IsIdempotentCommutativeMonoidMorphism\n\"Warning: IsIdempotentCommutativeMonoidMorphism was deprecated in v1.5.\nPlease use IsMonoidHomomorphism instead.\"\n#-}\n{-# WARNING_ON_USAGE IsGroupMorphism\n\"Warning: IsGroupMorphism was deprecated in v1.5.\nPlease use IsGroupHomomorphism instead.\"\n#-}\n{-# WARNING_ON_USAGE IsAbelianGroupMorphism\n\"Warning: IsAbelianGroupMorphism was deprecated in v1.5.\nPlease use IsGroupHomomorphism instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Morphism/Definitions/","title":"Algebra.Morphism.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definitions for morphisms between algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core\n\nmodule Algebra.Morphism.Definitions\n  {a} (A : Set a)     -- The domain of the morphism\n  {b} (B : Set b)     -- The codomain of the morphism\n  {\u2113} (_\u2248_ : Rel B \u2113)  -- The equality relation over the codomain\n  where\n\nopen import Algebra.Core\n  using (Op\u2081; Op\u2082)\n\n------------------------------------------------------------------------\n-- Basic definitions\n\nHomomorphic\u2080 : (A \u2192 B) \u2192 A \u2192 B \u2192 Set _\nHomomorphic\u2080 \u27e6_\u27e7 \u2219 \u2218 = \u27e6 \u2219 \u27e7 \u2248 \u2218\n\nHomomorphic\u2081 : (A \u2192 B) \u2192 Op\u2081 A \u2192 Op\u2081 B \u2192 Set _\nHomomorphic\u2081 \u27e6_\u27e7 \u2219_ \u2218_ = \u2200 x \u2192 \u27e6 \u2219 x \u27e7 \u2248 (\u2218 \u27e6 x \u27e7)\n\nHomomorphic\u2082 : (A \u2192 B) \u2192 Op\u2082 A \u2192 Op\u2082 B \u2192 Set _\nHomomorphic\u2082 \u27e6_\u27e7 _\u2219_ _\u2218_ = \u2200 x y \u2192 \u27e6 x \u2219 y \u27e7 \u2248 (\u27e6 x \u27e7 \u2218 \u27e6 y \u27e7)\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.3\n\nMorphism : Set _\nMorphism = A \u2192 B\n\n{-# WARNING_ON_USAGE Morphism\n\"Warning: Morphism was deprecated in v1.3.\nPlease use the standard function notation (e.g. A \u2192 B) instead.\"\n#-}\n</pre>"},{"location":"md/Algebra/Morphism/Structures/","title":"Algebra.Morphism.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Morphisms between algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Morphism.Structures where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Algebra.Bundles\nimport Algebra.Morphism.Definitions as MorphismDefinitions\nopen import Level using (Level; _\u2294_)\nopen import Function.Definitions using (Injective; Surjective)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Morphism.Structures\n  using (IsRelHomomorphism; IsRelMonomorphism; IsRelIsomorphism)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Morphisms over SuccessorSet-like structures\n------------------------------------------------------------------------\n\nmodule SuccessorSetMorphisms\n  (N\u2081 : RawSuccessorSet a \u2113\u2081) (N\u2082 : RawSuccessorSet b \u2113\u2082)\n  where\n\n  open RawSuccessorSet N\u2081\n    renaming (Carrier to A; _\u2248_ to _\u2248\u2081_; suc# to suc#\u2081; zero# to zero#\u2081)\n  open RawSuccessorSet N\u2082\n    renaming (Carrier to B; _\u2248_ to _\u2248\u2082_; suc# to suc#\u2082; zero# to zero#\u2082)\n  open MorphismDefinitions A B _\u2248\u2082_\n\n\n  record IsSuccessorSetHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRelHomomorphism : IsRelHomomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n      suc#-homo         : Homomorphic\u2081 \u27e6_\u27e7 suc#\u2081 suc#\u2082\n      zero#-homo        : Homomorphic\u2080 \u27e6_\u27e7 zero#\u2081 zero#\u2082\n\n  record IsSuccessorSetMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSuccessorSetHomomorphism : IsSuccessorSetHomomorphism \u27e6_\u27e7\n      injective                  : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsSuccessorSetHomomorphism isSuccessorSetHomomorphism public\n\n    isRelMonomorphism : IsRelMonomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelMonomorphism = record\n      { isHomomorphism = isRelHomomorphism\n      ; injective      = injective\n      }\n\n\n  record IsSuccessorSetIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSuccessorSetMonomorphism : IsSuccessorSetMonomorphism \u27e6_\u27e7\n      surjective                 : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsSuccessorSetMonomorphism isSuccessorSetMonomorphism public\n\n    isRelIsomorphism : IsRelIsomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelIsomorphism = record\n      { isMonomorphism = isRelMonomorphism\n      ; surjective     = surjective\n      }\n\n\n------------------------------------------------------------------------\n-- Morphisms over magma-like structures\n------------------------------------------------------------------------\n\nmodule MagmaMorphisms (M\u2081 : RawMagma a \u2113\u2081) (M\u2082 : RawMagma b \u2113\u2082) where\n\n  open RawMagma M\u2081 renaming (Carrier to A; _\u2248_ to _\u2248\u2081_; _\u2219_ to _\u2219_)\n  open RawMagma M\u2082 renaming (Carrier to B; _\u2248_ to _\u2248\u2082_; _\u2219_ to _\u25e6_)\n  open MorphismDefinitions A B _\u2248\u2082_\n\n\n  record IsMagmaHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRelHomomorphism : IsRelHomomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n      homo              : Homomorphic\u2082 \u27e6_\u27e7 _\u2219_ _\u25e6_\n\n    open IsRelHomomorphism isRelHomomorphism public\n      renaming (cong to \u27e6\u27e7-cong)\n\n\n  record IsMagmaMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMagmaHomomorphism : IsMagmaHomomorphism \u27e6_\u27e7\n      injective           : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsMagmaHomomorphism isMagmaHomomorphism public\n\n    isRelMonomorphism : IsRelMonomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelMonomorphism = record\n      { isHomomorphism = isRelHomomorphism\n      ; injective      = injective\n      }\n\n\n  record IsMagmaIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMagmaMonomorphism : IsMagmaMonomorphism \u27e6_\u27e7\n      surjective          : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsMagmaMonomorphism isMagmaMonomorphism public\n\n    isRelIsomorphism : IsRelIsomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelIsomorphism = record\n      { isMonomorphism = isRelMonomorphism\n      ; surjective     = surjective\n      }\n\n\n------------------------------------------------------------------------\n-- Morphisms over monoid-like structures\n------------------------------------------------------------------------\n\nmodule MonoidMorphisms (M\u2081 : RawMonoid a \u2113\u2081) (M\u2082 : RawMonoid b \u2113\u2082) where\n\n  open RawMonoid M\u2081 renaming (Carrier to A; _\u2248_ to _\u2248\u2081_; _\u2219_ to _\u2219_; \u03b5 to \u03b5\u2081)\n  open RawMonoid M\u2082 renaming (Carrier to B; _\u2248_ to _\u2248\u2082_; _\u2219_ to _\u25e6_; \u03b5 to \u03b5\u2082)\n  open MorphismDefinitions A B _\u2248\u2082_\n  open MagmaMorphisms (RawMonoid.rawMagma M\u2081) (RawMonoid.rawMagma M\u2082)\n\n\n  record IsMonoidHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMagmaHomomorphism : IsMagmaHomomorphism \u27e6_\u27e7\n      \u03b5-homo              : Homomorphic\u2080 \u27e6_\u27e7 \u03b5\u2081 \u03b5\u2082\n\n    open IsMagmaHomomorphism isMagmaHomomorphism public\n\n\n  record IsMonoidMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMonoidHomomorphism : IsMonoidHomomorphism \u27e6_\u27e7\n      injective            : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsMonoidHomomorphism isMonoidHomomorphism public\n\n    isMagmaMonomorphism : IsMagmaMonomorphism \u27e6_\u27e7\n    isMagmaMonomorphism = record\n      { isMagmaHomomorphism = isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n    open IsMagmaMonomorphism isMagmaMonomorphism public\n      using (isRelMonomorphism)\n\n\n  record IsMonoidIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMonoidMonomorphism : IsMonoidMonomorphism \u27e6_\u27e7\n      surjective           : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsMonoidMonomorphism isMonoidMonomorphism public\n\n    isMagmaIsomorphism : IsMagmaIsomorphism \u27e6_\u27e7\n    isMagmaIsomorphism = record\n      { isMagmaMonomorphism = isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n    open IsMagmaIsomorphism isMagmaIsomorphism public\n      using (isRelIsomorphism)\n\n\n------------------------------------------------------------------------\n-- Morphisms over group-like structures\n------------------------------------------------------------------------\n\nmodule GroupMorphisms (G\u2081 : RawGroup a \u2113\u2081) (G\u2082 : RawGroup b \u2113\u2082) where\n\n  open RawGroup G\u2081 renaming\n    (Carrier to A; _\u2248_ to _\u2248\u2081_; _\u2219_ to _\u2219_; _\u207b\u00b9 to _\u207b\u00b9\u2081; \u03b5 to \u03b5\u2081)\n  open RawGroup G\u2082 renaming\n    (Carrier to B; _\u2248_ to _\u2248\u2082_; _\u2219_ to _\u25e6_; _\u207b\u00b9 to _\u207b\u00b9\u2082; \u03b5 to \u03b5\u2082)\n  open MorphismDefinitions A B _\u2248\u2082_\n  open MagmaMorphisms  (RawGroup.rawMagma  G\u2081) (RawGroup.rawMagma  G\u2082)\n  open MonoidMorphisms (RawGroup.rawMonoid G\u2081) (RawGroup.rawMonoid G\u2082)\n\n\n  record IsGroupHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isMonoidHomomorphism : IsMonoidHomomorphism \u27e6_\u27e7\n      \u207b\u00b9-homo              : Homomorphic\u2081 \u27e6_\u27e7 _\u207b\u00b9\u2081 _\u207b\u00b9\u2082\n\n    open IsMonoidHomomorphism isMonoidHomomorphism public\n\n\n  record IsGroupMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isGroupHomomorphism : IsGroupHomomorphism \u27e6_\u27e7\n      injective           : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsGroupHomomorphism isGroupHomomorphism public\n      renaming (homo to \u2219-homo)\n\n    isMonoidMonomorphism : IsMonoidMonomorphism \u27e6_\u27e7\n    isMonoidMonomorphism = record\n      { isMonoidHomomorphism = isMonoidHomomorphism\n      ; injective            = injective\n      }\n\n    open IsMonoidMonomorphism isMonoidMonomorphism public\n      using (isRelMonomorphism; isMagmaMonomorphism)\n\n\n  record IsGroupIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isGroupMonomorphism : IsGroupMonomorphism \u27e6_\u27e7\n      surjective          : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsGroupMonomorphism isGroupMonomorphism public\n\n    isMonoidIsomorphism : IsMonoidIsomorphism \u27e6_\u27e7\n    isMonoidIsomorphism = record\n      { isMonoidMonomorphism = isMonoidMonomorphism\n      ; surjective           = surjective\n      }\n\n    open IsMonoidIsomorphism isMonoidIsomorphism public\n      using (isRelIsomorphism; isMagmaIsomorphism)\n\n\n------------------------------------------------------------------------\n-- Morphisms over near-semiring-like structures\n------------------------------------------------------------------------\n\nmodule NearSemiringMorphisms (R\u2081 : RawNearSemiring a \u2113\u2081) (R\u2082 : RawNearSemiring b \u2113\u2082) where\n\n  open RawNearSemiring R\u2081 renaming\n    ( Carrier to A; _\u2248_ to _\u2248\u2081_\n    ; +-rawMonoid to +-rawMonoid\u2081\n    ; _*_ to _*\u2081_\n    ; *-rawMagma to *-rawMagma\u2081)\n\n  open RawNearSemiring R\u2082 renaming\n    ( Carrier to B; _\u2248_ to _\u2248\u2082_\n    ; +-rawMonoid to +-rawMonoid\u2082\n    ; _*_ to _*\u2082_\n    ; *-rawMagma to *-rawMagma\u2082)\n\n  private\n    module + = MonoidMorphisms +-rawMonoid\u2081 +-rawMonoid\u2082\n    module * = MagmaMorphisms *-rawMagma\u2081 *-rawMagma\u2082\n\n  open MorphismDefinitions A B _\u2248\u2082_\n\n\n  record IsNearSemiringHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      +-isMonoidHomomorphism : +.IsMonoidHomomorphism \u27e6_\u27e7\n      *-homo : Homomorphic\u2082 \u27e6_\u27e7 _*\u2081_ _*\u2082_\n\n    open +.IsMonoidHomomorphism +-isMonoidHomomorphism public\n      renaming (homo to +-homo; \u03b5-homo to 0#-homo; isMagmaHomomorphism to +-isMagmaHomomorphism)\n\n    *-isMagmaHomomorphism : *.IsMagmaHomomorphism \u27e6_\u27e7\n    *-isMagmaHomomorphism = record\n      { isRelHomomorphism = isRelHomomorphism\n      ; homo = *-homo\n      }\n\n  record IsNearSemiringMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isNearSemiringHomomorphism : IsNearSemiringHomomorphism \u27e6_\u27e7\n      injective          : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsNearSemiringHomomorphism isNearSemiringHomomorphism public\n\n    +-isMonoidMonomorphism : +.IsMonoidMonomorphism \u27e6_\u27e7\n    +-isMonoidMonomorphism = record\n      { isMonoidHomomorphism = +-isMonoidHomomorphism\n      ; injective            = injective\n      }\n\n    open +.IsMonoidMonomorphism +-isMonoidMonomorphism public\n      using (isRelMonomorphism)\n      renaming (isMagmaMonomorphism to +-isMagmaMonomorphsm)\n\n    *-isMagmaMonomorphism : *.IsMagmaMonomorphism \u27e6_\u27e7\n    *-isMagmaMonomorphism = record\n      { isMagmaHomomorphism = *-isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n  record IsNearSemiringIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isNearSemiringMonomorphism : IsNearSemiringMonomorphism \u27e6_\u27e7\n      surjective                 : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsNearSemiringMonomorphism isNearSemiringMonomorphism public\n\n    +-isMonoidIsomorphism : +.IsMonoidIsomorphism \u27e6_\u27e7\n    +-isMonoidIsomorphism = record\n      { isMonoidMonomorphism = +-isMonoidMonomorphism\n      ; surjective           = surjective\n      }\n\n    open +.IsMonoidIsomorphism +-isMonoidIsomorphism public\n      using (isRelIsomorphism)\n      renaming (isMagmaIsomorphism to +-isMagmaIsomorphism)\n\n    *-isMagmaIsomorphism : *.IsMagmaIsomorphism \u27e6_\u27e7\n    *-isMagmaIsomorphism = record\n      { isMagmaMonomorphism = *-isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n------------------------------------------------------------------------\n-- Morphisms over semiring-like structures\n------------------------------------------------------------------------\n\nmodule SemiringMorphisms (R\u2081 : RawSemiring a \u2113\u2081) (R\u2082 : RawSemiring b \u2113\u2082) where\n\n  open RawSemiring R\u2081 renaming\n    ( Carrier to A; _\u2248_ to _\u2248\u2081_\n    ; 1# to 1#\u2081\n    ; rawNearSemiring to rawNearSemiring\u2081\n    ; *-rawMonoid to *-rawMonoid\u2081)\n\n  open RawSemiring R\u2082 renaming\n    ( Carrier to B; _\u2248_ to _\u2248\u2082_\n    ; 1# to 1#\u2082\n    ; rawNearSemiring to rawNearSemiring\u2082\n    ; *-rawMonoid to *-rawMonoid\u2082)\n\n  private\n    module * = MonoidMorphisms *-rawMonoid\u2081 *-rawMonoid\u2082\n\n  open MorphismDefinitions A B _\u2248\u2082_\n  open NearSemiringMorphisms rawNearSemiring\u2081 rawNearSemiring\u2082\n\n  record IsSemiringHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isNearSemiringHomomorphism : IsNearSemiringHomomorphism \u27e6_\u27e7\n      1#-homo : Homomorphic\u2080 \u27e6_\u27e7 1#\u2081 1#\u2082\n\n    open IsNearSemiringHomomorphism isNearSemiringHomomorphism public\n\n    *-isMonoidHomomorphism : *.IsMonoidHomomorphism \u27e6_\u27e7\n    *-isMonoidHomomorphism = record\n      { isMagmaHomomorphism = *-isMagmaHomomorphism\n      ; \u03b5-homo = 1#-homo\n      }\n\n  record IsSemiringMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSemiringHomomorphism : IsSemiringHomomorphism \u27e6_\u27e7\n      injective              : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsSemiringHomomorphism isSemiringHomomorphism public\n\n    isNearSemiringMonomorphism : IsNearSemiringMonomorphism \u27e6_\u27e7\n    isNearSemiringMonomorphism = record\n      { isNearSemiringHomomorphism = isNearSemiringHomomorphism\n      ; injective = injective\n      }\n\n    open IsNearSemiringMonomorphism isNearSemiringMonomorphism public\n      using (+-isMonoidMonomorphism; *-isMagmaMonomorphism)\n\n    *-isMonoidMonomorphism : *.IsMonoidMonomorphism \u27e6_\u27e7\n    *-isMonoidMonomorphism = record\n      { isMonoidHomomorphism = *-isMonoidHomomorphism\n      ; injective            = injective\n      }\n\n  record IsSemiringIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSemiringMonomorphism : IsSemiringMonomorphism \u27e6_\u27e7\n      surjective             : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsSemiringMonomorphism isSemiringMonomorphism public\n\n    isNearSemiringIsomorphism : IsNearSemiringIsomorphism \u27e6_\u27e7\n    isNearSemiringIsomorphism = record\n      { isNearSemiringMonomorphism = isNearSemiringMonomorphism\n      ; surjective = surjective\n      }\n\n    open IsNearSemiringIsomorphism isNearSemiringIsomorphism public\n      using (+-isMonoidIsomorphism; *-isMagmaIsomorphism)\n\n    *-isMonoidIsomorphism : *.IsMonoidIsomorphism \u27e6_\u27e7\n    *-isMonoidIsomorphism = record\n      { isMonoidMonomorphism = *-isMonoidMonomorphism\n      ; surjective           = surjective\n      }\n\n------------------------------------------------------------------------\n-- Morphisms over ringWithoutOne-like structures\n------------------------------------------------------------------------\n\nmodule RingWithoutOneMorphisms (R\u2081 : RawRingWithoutOne a \u2113\u2081) (R\u2082 : RawRingWithoutOne b \u2113\u2082) where\n\n  open RawRingWithoutOne R\u2081 renaming\n    ( Carrier to A; _\u2248_ to _\u2248\u2081_\n    ; _*_ to _*\u2081_\n    ; *-rawMagma to *-rawMagma\u2081\n    ; +-rawGroup to +-rawGroup\u2081\n    ; rawNearSemiring to rawNearSemiring\u2081)\n\n  open RawRingWithoutOne R\u2082 renaming\n    ( Carrier to B; _\u2248_ to _\u2248\u2082_\n    ; _*_ to _*\u2082_\n    ; *-rawMagma to *-rawMagma\u2082\n    ; +-rawGroup to +-rawGroup\u2082\n    ; rawNearSemiring to rawNearSemiring\u2082)\n\n  private\n    module + = GroupMorphisms  +-rawGroup\u2081  +-rawGroup\u2082\n    module * = MagmaMorphisms *-rawMagma\u2081 *-rawMagma\u2082\n    module +* = NearSemiringMorphisms rawNearSemiring\u2081 rawNearSemiring\u2082\n\n  open MorphismDefinitions A B _\u2248\u2082_\n\n  record IsRingWithoutOneHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      +-isGroupHomomorphism : +.IsGroupHomomorphism \u27e6_\u27e7\n      *-homo : Homomorphic\u2082 \u27e6_\u27e7 _*\u2081_ _*\u2082_\n\n    open +.IsGroupHomomorphism +-isGroupHomomorphism public\n      renaming (homo to +-homo; \u03b5-homo to 0#-homo; isMagmaHomomorphism to +-isMagmaHomomorphism; isMonoidHomomorphism to +-isMonoidHomomorphism)\n\n    isNearSemiringHomomorphism : +*.IsNearSemiringHomomorphism \u27e6_\u27e7\n    isNearSemiringHomomorphism = record\n      { +-isMonoidHomomorphism = +-isMonoidHomomorphism\n      ; *-homo = *-homo\n      }\n\n    *-isMagmaHomomorphism : *.IsMagmaHomomorphism \u27e6_\u27e7\n    *-isMagmaHomomorphism = record\n      { isRelHomomorphism = isRelHomomorphism\n      ; homo = *-homo\n      }\n\n  record IsRingWithoutOneMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRingWithoutOneHomomorphism : IsRingWithoutOneHomomorphism \u27e6_\u27e7\n      injective                    : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsRingWithoutOneHomomorphism isRingWithoutOneHomomorphism public\n\n    +-isGroupMonomorphism : +.IsGroupMonomorphism \u27e6_\u27e7\n    +-isGroupMonomorphism = record\n      { isGroupHomomorphism = +-isGroupHomomorphism\n      ; injective            = injective\n      }\n\n    open +.IsGroupMonomorphism +-isGroupMonomorphism public\n      using (isRelMonomorphism)\n      renaming (isMagmaMonomorphism to +-isMagmaMonomorphsm; isMonoidMonomorphism to +-isMonoidMonomorphism)\n\n    *-isMagmaMonomorphism : *.IsMagmaMonomorphism \u27e6_\u27e7\n    *-isMagmaMonomorphism = record\n      { isMagmaHomomorphism = *-isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n  record IsRingWithoutOneIsoMorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRingWithoutOneMonomorphism : IsRingWithoutOneMonomorphism \u27e6_\u27e7\n      surjective                   : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsRingWithoutOneMonomorphism isRingWithoutOneMonomorphism public\n\n    +-isGroupIsomorphism   : +.IsGroupIsomorphism \u27e6_\u27e7\n    +-isGroupIsomorphism  = record\n      { isGroupMonomorphism = +-isGroupMonomorphism\n      ; surjective           = surjective\n      }\n\n    open +.IsGroupIsomorphism +-isGroupIsomorphism public\n      using (isRelIsomorphism)\n      renaming (isMagmaIsomorphism to +-isMagmaIsomorphism; isMonoidIsomorphism to +-isMonoidIsomorphism)\n\n    *-isMagmaIsomorphism : *.IsMagmaIsomorphism \u27e6_\u27e7\n    *-isMagmaIsomorphism = record\n      { isMagmaMonomorphism = *-isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n\n------------------------------------------------------------------------\n-- Morphisms over ring-like structures\n------------------------------------------------------------------------\n\nmodule RingMorphisms (R\u2081 : RawRing a \u2113\u2081) (R\u2082 : RawRing b \u2113\u2082) where\n\n  open RawRing R\u2081 renaming\n    ( Carrier to A; _\u2248_ to _\u2248\u2081_\n    ; -_ to -\u2081_\n    ; rawRingWithoutOne to rawRingWithoutOne\u2081\n    ; rawSemiring to rawSemiring\u2081\n    ; *-rawMonoid to *-rawMonoid\u2081\n    ; +-rawGroup to +-rawGroup\u2081)\n\n  open RawRing R\u2082 renaming\n    ( Carrier to B; _\u2248_ to _\u2248\u2082_\n    ; -_ to -\u2082_\n    ; rawRingWithoutOne to rawRingWithoutOne\u2082\n    ; rawSemiring to rawSemiring\u2082\n    ; *-rawMonoid to *-rawMonoid\u2082\n    ; +-rawGroup to +-rawGroup\u2082)\n\n  module + = GroupMorphisms  +-rawGroup\u2081  +-rawGroup\u2082\n  module * = MonoidMorphisms *-rawMonoid\u2081 *-rawMonoid\u2082\n  module *+0 = RingWithoutOneMorphisms rawRingWithoutOne\u2081 rawRingWithoutOne\u2082\n\n  open MorphismDefinitions A B _\u2248\u2082_\n  open SemiringMorphisms rawSemiring\u2081 rawSemiring\u2082\n\n\n  record IsRingHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSemiringHomomorphism : IsSemiringHomomorphism \u27e6_\u27e7\n      -\u203fhomo : Homomorphic\u2081 \u27e6_\u27e7 -\u2081_ -\u2082_\n\n    open IsSemiringHomomorphism isSemiringHomomorphism public\n\n    +-isGroupHomomorphism : +.IsGroupHomomorphism \u27e6_\u27e7\n    +-isGroupHomomorphism = record\n      { isMonoidHomomorphism = +-isMonoidHomomorphism\n      ; \u207b\u00b9-homo = -\u203fhomo\n      }\n\n    isRingWithoutOneHomomorphism : *+0.IsRingWithoutOneHomomorphism \u27e6_\u27e7\n    isRingWithoutOneHomomorphism = record\n      { +-isGroupHomomorphism = +-isGroupHomomorphism\n      ; *-homo = *-homo\n      }\n\n  record IsRingMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRingHomomorphism : IsRingHomomorphism \u27e6_\u27e7\n      injective          : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsRingHomomorphism isRingHomomorphism public\n\n    isSemiringMonomorphism : IsSemiringMonomorphism \u27e6_\u27e7\n    isSemiringMonomorphism = record\n      { isSemiringHomomorphism = isSemiringHomomorphism\n      ; injective = injective\n      }\n\n    +-isGroupMonomorphism : +.IsGroupMonomorphism \u27e6_\u27e7\n    +-isGroupMonomorphism = record\n      { isGroupHomomorphism = +-isGroupHomomorphism\n      ; injective           = injective\n      }\n\n    open +.IsGroupMonomorphism +-isGroupMonomorphism\n      using (isRelMonomorphism)\n      renaming ( isMagmaMonomorphism to +-isMagmaMonomorphism\n               ; isMonoidMonomorphism to +-isMonoidMonomorphism\n               )\n\n    *-isMonoidMonomorphism : *.IsMonoidMonomorphism \u27e6_\u27e7\n    *-isMonoidMonomorphism = record\n      { isMonoidHomomorphism = *-isMonoidHomomorphism\n      ; injective            = injective\n      }\n\n    open *.IsMonoidMonomorphism *-isMonoidMonomorphism public\n      using ()\n      renaming (isMagmaMonomorphism to *-isMagmaMonomorphism)\n\n\n  record IsRingIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRingMonomorphism : IsRingMonomorphism \u27e6_\u27e7\n      surjective         : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsRingMonomorphism isRingMonomorphism public\n\n    isSemiringIsomorphism : IsSemiringIsomorphism \u27e6_\u27e7\n    isSemiringIsomorphism = record\n      { isSemiringMonomorphism = isSemiringMonomorphism\n      ; surjective = surjective\n      }\n\n    +-isGroupIsomorphism : +.IsGroupIsomorphism \u27e6_\u27e7\n    +-isGroupIsomorphism = record\n      { isGroupMonomorphism = +-isGroupMonomorphism\n      ; surjective          = surjective\n      }\n\n    open +.IsGroupIsomorphism +-isGroupIsomorphism\n      using (isRelIsomorphism)\n      renaming ( isMagmaIsomorphism to +-isMagmaIsomorphism\n               ; isMonoidIsomorphism to +-isMonoidIsomorphisn\n               )\n\n    *-isMonoidIsomorphism : *.IsMonoidIsomorphism \u27e6_\u27e7\n    *-isMonoidIsomorphism = record\n      { isMonoidMonomorphism = *-isMonoidMonomorphism\n      ; surjective           = surjective\n      }\n\n    open *.IsMonoidIsomorphism *-isMonoidIsomorphism public\n      using ()\n      renaming (isMagmaIsomorphism to *-isMagmaIsomorphisn)\n\n------------------------------------------------------------------------\n-- Morphisms over quasigroup-like structures\n------------------------------------------------------------------------\n\nmodule QuasigroupMorphisms (Q\u2081 : RawQuasigroup a \u2113\u2081) (Q\u2082 : RawQuasigroup b \u2113\u2082) where\n\n  open RawQuasigroup Q\u2081 renaming (Carrier to A; \u2219-rawMagma to \u2219-rawMagma\u2081;\n                                  \\\\-rawMagma to \\\\-rawMagma\u2081; //-rawMagma to //-rawMagma\u2081;\n                                  _\u2248_ to _\u2248\u2081_; _\u2219_ to _\u2219\u2081_; _\\\\_ to _\\\\\u2081_; _//_ to _//\u2081_)\n  open RawQuasigroup Q\u2082 renaming (Carrier to B; \u2219-rawMagma to \u2219-rawMagma\u2082;\n                                  \\\\-rawMagma to \\\\-rawMagma\u2082; //-rawMagma to //-rawMagma\u2082;\n                                  _\u2248_ to _\u2248\u2082_; _\u2219_ to _\u2219\u2082_; _\\\\_ to _\\\\\u2082_; _//_ to _//\u2082_)\n\n  module \u2219  = MagmaMorphisms \u2219-rawMagma\u2081 \u2219-rawMagma\u2082\n  module \\\\ = MagmaMorphisms \\\\-rawMagma\u2081 \\\\-rawMagma\u2082\n  module // = MagmaMorphisms //-rawMagma\u2081 //-rawMagma\u2082\n\n  open MorphismDefinitions A B _\u2248\u2082_\n\n  record IsQuasigroupHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isRelHomomorphism : IsRelHomomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n      \u2219-homo            : Homomorphic\u2082 \u27e6_\u27e7 _\u2219\u2081_ _\u2219\u2082_\n      \\\\-homo           : Homomorphic\u2082 \u27e6_\u27e7 _\\\\\u2081_ _\\\\\u2082_\n      //-homo           : Homomorphic\u2082 \u27e6_\u27e7 _//\u2081_ _//\u2082_\n\n    open IsRelHomomorphism isRelHomomorphism public\n      renaming (cong to \u27e6\u27e7-cong)\n\n    \u2219-isMagmaHomomorphism : \u2219.IsMagmaHomomorphism \u27e6_\u27e7\n    \u2219-isMagmaHomomorphism = record\n      { isRelHomomorphism = isRelHomomorphism\n      ; homo = \u2219-homo\n      }\n\n    \\\\-isMagmaHomomorphism : \\\\.IsMagmaHomomorphism \u27e6_\u27e7\n    \\\\-isMagmaHomomorphism = record\n      { isRelHomomorphism  = isRelHomomorphism\n      ; homo = \\\\-homo\n      }\n\n    //-isMagmaHomomorphism : //.IsMagmaHomomorphism \u27e6_\u27e7\n    //-isMagmaHomomorphism = record\n      { isRelHomomorphism  = isRelHomomorphism\n      ; homo = //-homo\n      }\n\n  record IsQuasigroupMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isQuasigroupHomomorphism : IsQuasigroupHomomorphism \u27e6_\u27e7\n      injective                : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsQuasigroupHomomorphism isQuasigroupHomomorphism public\n\n\n    \u2219-isMagmaMonomorphism   : \u2219.IsMagmaMonomorphism \u27e6_\u27e7\n    \u2219-isMagmaMonomorphism   = record\n      { isMagmaHomomorphism = \u2219-isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n    \\\\-isMagmaMonomorphism  : \\\\.IsMagmaMonomorphism \u27e6_\u27e7\n    \\\\-isMagmaMonomorphism  = record\n      { isMagmaHomomorphism = \\\\-isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n    //-isMagmaMonomorphism  : //.IsMagmaMonomorphism \u27e6_\u27e7\n    //-isMagmaMonomorphism  = record\n      { isMagmaHomomorphism = //-isMagmaHomomorphism\n      ; injective           = injective\n      }\n\n    open //.IsMagmaMonomorphism //-isMagmaMonomorphism public\n      using (isRelMonomorphism)\n\n\n  record IsQuasigroupIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isQuasigroupMonomorphism : IsQuasigroupMonomorphism \u27e6_\u27e7\n      surjective               : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsQuasigroupMonomorphism isQuasigroupMonomorphism public\n\n    \u2219-isMagmaIsomorphism    : \u2219.IsMagmaIsomorphism \u27e6_\u27e7\n    \u2219-isMagmaIsomorphism    = record\n      { isMagmaMonomorphism = \u2219-isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n    \\\\-isMagmaIsomorphism   : \\\\.IsMagmaIsomorphism \u27e6_\u27e7\n    \\\\-isMagmaIsomorphism   = record\n      { isMagmaMonomorphism = \\\\-isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n    //-isMagmaIsomorphism   : //.IsMagmaIsomorphism \u27e6_\u27e7\n    //-isMagmaIsomorphism   = record\n      { isMagmaMonomorphism = //-isMagmaMonomorphism\n      ; surjective          = surjective\n      }\n\n    open //.IsMagmaIsomorphism //-isMagmaIsomorphism public\n      using (isRelIsomorphism)\n\n------------------------------------------------------------------------\n-- Morphisms over loop-like structures\n------------------------------------------------------------------------\n\nmodule LoopMorphisms (L\u2081 : RawLoop a \u2113\u2081) (L\u2082 : RawLoop b \u2113\u2082) where\n\n  open RawLoop L\u2081 renaming (Carrier to A; \u2219-rawMagma to \u2219-rawMagma\u2081;\n                            \\\\-rawMagma to \\\\-rawMagma\u2081; //-rawMagma to //-rawMagma\u2081;\n                             _\u2248_ to _\u2248\u2081_; _\u2219_ to _\u2219\u2081_; _\\\\_ to _\\\\\u2081_; _//_ to _//\u2081_; \u03b5 to \u03b5\u2081)\n  open RawLoop L\u2082 renaming (Carrier to B; \u2219-rawMagma to \u2219-rawMagma\u2082;\n                            \\\\-rawMagma to \\\\-rawMagma\u2082; //-rawMagma to //-rawMagma\u2082;\n                            _\u2248_ to _\u2248\u2082_; _\u2219_ to _\u2219\u2082_; _\\\\_ to _\\\\\u2082_; _//_ to _//\u2082_ ; \u03b5 to \u03b5\u2082)\n  open MorphismDefinitions A B _\u2248\u2082_\n\n  open QuasigroupMorphisms (RawLoop.rawQuasigroup L\u2081) (RawLoop.rawQuasigroup L\u2082)\n\n  record IsLoopHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isQuasigroupHomomorphism : IsQuasigroupHomomorphism \u27e6_\u27e7\n      \u03b5-homo                   : Homomorphic\u2080 \u27e6_\u27e7 \u03b5\u2081 \u03b5\u2082\n\n    open IsQuasigroupHomomorphism isQuasigroupHomomorphism public\n\n  record IsLoopMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isLoopHomomorphism   : IsLoopHomomorphism \u27e6_\u27e7\n      injective            : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsLoopHomomorphism isLoopHomomorphism public\n\n  record IsLoopIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isLoopMonomorphism   : IsLoopMonomorphism \u27e6_\u27e7\n      surjective           : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsLoopMonomorphism isLoopMonomorphism public\n\n------------------------------------------------------------------------\n-- Morphisms over Kleene algebra structures\n------------------------------------------------------------------------\nmodule KleeneAlgebraMorphisms (R\u2081 : RawKleeneAlgebra a \u2113\u2081) (R\u2082 : RawKleeneAlgebra b \u2113\u2082) where\n\n  open RawKleeneAlgebra R\u2081 renaming\n    ( Carrier to A; _\u2248_ to _\u2248\u2081_\n    ; _\u22c6 to _\u22c6\u2081\n    ; rawSemiring to rawSemiring\u2081\n    )\n\n  open RawKleeneAlgebra R\u2082 renaming\n    ( Carrier to B; _\u2248_ to _\u2248\u2082_\n    ; _\u22c6 to _\u22c6\u2082\n    ; rawSemiring to rawSemiring\u2082\n    )\n\n  open MorphismDefinitions A B _\u2248\u2082_\n  open SemiringMorphisms rawSemiring\u2081 rawSemiring\u2082\n\n  record IsKleeneAlgebraHomomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isSemiringHomomorphism : IsSemiringHomomorphism \u27e6_\u27e7\n      \u22c6-homo :  Homomorphic\u2081 \u27e6_\u27e7 _\u22c6\u2081 _\u22c6\u2082\n\n    open IsSemiringHomomorphism isSemiringHomomorphism public\n\n  record IsKleeneAlgebraMonomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isKleeneAlgebraHomomorphism   : IsKleeneAlgebraHomomorphism \u27e6_\u27e7\n      injective                     : Injective  _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsKleeneAlgebraHomomorphism isKleeneAlgebraHomomorphism public\n\n  record IsKleeneAlgebraIsomorphism (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      isKleeneAlgebraMonomorphism   : IsKleeneAlgebraMonomorphism \u27e6_\u27e7\n      surjective                    : Surjective  _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n    open IsKleeneAlgebraMonomorphism isKleeneAlgebraMonomorphism public\n\n------------------------------------------------------------------------\n-- Re-export contents of modules publicly\n\nopen MagmaMorphisms public\nopen MonoidMorphisms public\nopen GroupMorphisms public\nopen NearSemiringMorphisms public\nopen SemiringMorphisms public\nopen RingWithoutOneMorphisms public\nopen RingMorphisms public\nopen QuasigroupMorphisms public\nopen LoopMorphisms public\nopen KleeneAlgebraMorphisms public\n</pre>"},{"location":"md/Algebra/Properties/CommutativeSemigroup/","title":"Algebra.Properties.CommutativeSemigroup","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some theory for commutative semigroup\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Bundles using (CommutativeSemigroup)\n\nmodule Algebra.Properties.CommutativeSemigroup\n  {a \u2113} (CS : CommutativeSemigroup a \u2113)\n  where\n\nopen CommutativeSemigroup CS\nopen import Algebra.Definitions _\u2248_\nopen import Relation.Binary.Reasoning.Setoid setoid\nopen import Data.Product.Base using (_,_)\n\n------------------------------------------------------------------------\n-- Re-export the contents of semigroup\n\nopen import Algebra.Properties.Semigroup semigroup public\n\n------------------------------------------------------------------------\n-- Properties\n\ninterchange : Interchangable _\u2219_ _\u2219_\ninterchange a b c d = begin\n  (a \u2219 b) \u2219 (c \u2219 d)  \u2248\u27e8  assoc a b (c \u2219 d) \u27e9\n  a \u2219 (b \u2219 (c \u2219 d))  \u2248\u27e8 \u2219-cong\u02e1 (assoc b c d) \u27e8\n  a \u2219 ((b \u2219 c) \u2219 d)  \u2248\u27e8  \u2219-cong\u02e1 (\u2219-cong\u02b3 (comm b c)) \u27e9\n  a \u2219 ((c \u2219 b) \u2219 d)  \u2248\u27e8  \u2219-cong\u02e1 (assoc c b d) \u27e9\n  a \u2219 (c \u2219 (b \u2219 d))  \u2248\u27e8 assoc a c (b \u2219 d) \u27e8\n  (a \u2219 c) \u2219 (b \u2219 d)  \u220e\n\n------------------------------------------------------------------------\n-- Permutation laws for _\u2219_ for three factors.\n\n-- There are five nontrivial permutations.\n\n------------------------------------------------------------------------\n-- Partitions (1,1).\n\nx\u2219yz\u2248y\u2219xz :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 y \u2219 (x \u2219 z)\nx\u2219yz\u2248y\u2219xz x y z = begin\n  x \u2219 (y \u2219 z)    \u2248\u27e8 sym (assoc x y z) \u27e9\n  (x \u2219 y) \u2219 z    \u2248\u27e8 \u2219-cong\u02b3 (comm x y) \u27e9\n  (y \u2219 x) \u2219 z    \u2248\u27e8 assoc y x z \u27e9\n  y \u2219 (x \u2219 z)    \u220e\n\nx\u2219yz\u2248z\u2219yx :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 z \u2219 (y \u2219 x)\nx\u2219yz\u2248z\u2219yx x y z = begin\n  x \u2219 (y \u2219 z)    \u2248\u27e8 \u2219-cong\u02e1 (comm y z) \u27e9\n  x \u2219 (z \u2219 y)    \u2248\u27e8 x\u2219yz\u2248y\u2219xz x z y \u27e9\n  z \u2219 (x \u2219 y)    \u2248\u27e8 \u2219-cong\u02e1 (comm x y) \u27e9\n  z \u2219 (y \u2219 x)    \u220e\n\nx\u2219yz\u2248x\u2219zy :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 x \u2219 (z \u2219 y)\nx\u2219yz\u2248x\u2219zy _ y z =  \u2219-cong\u02e1 (comm y z)\n\nx\u2219yz\u2248y\u2219zx :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 y \u2219 (z \u2219 x)\nx\u2219yz\u2248y\u2219zx x y z = begin\n  x \u2219 (y \u2219 z)   \u2248\u27e8 comm x _ \u27e9\n  (y \u2219 z) \u2219 x   \u2248\u27e8 assoc y z x \u27e9\n  y \u2219 (z \u2219 x)   \u220e\n\nx\u2219yz\u2248z\u2219xy :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 z \u2219 (x \u2219 y)\nx\u2219yz\u2248z\u2219xy x y z = begin\n  x \u2219 (y \u2219 z)   \u2248\u27e8 sym (assoc x y z) \u27e9\n  (x \u2219 y) \u2219 z   \u2248\u27e8 comm _ z \u27e9\n  z \u2219 (x \u2219 y)   \u220e\n\n------------------------------------------------------------------------\n-- Partitions (1,2).\n\n-- These permutation laws are proved by composing the proofs for\n-- partitions (1,1) with  \\p \u2192 trans p (sym (assoc _ _ _)).\n\nx\u2219yz\u2248yx\u2219z :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (y \u2219 x) \u2219 z\nx\u2219yz\u2248yx\u2219z x y z =  trans (x\u2219yz\u2248y\u2219xz x y z) (sym (assoc y x z))\n\nx\u2219yz\u2248zy\u2219x :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (z \u2219 y) \u2219 x\nx\u2219yz\u2248zy\u2219x x y z =  trans (x\u2219yz\u2248z\u2219yx x y z) (sym (assoc z y x))\n\nx\u2219yz\u2248xz\u2219y :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (x \u2219 z) \u2219 y\nx\u2219yz\u2248xz\u2219y x y z =  trans (x\u2219yz\u2248x\u2219zy x y z) (sym (assoc x z y))\n\nx\u2219yz\u2248yz\u2219x :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (y \u2219 z) \u2219 x\nx\u2219yz\u2248yz\u2219x x y z =  trans (x\u2219yz\u2248y\u2219zx _ _ _) (sym (assoc y z x))\n\nx\u2219yz\u2248zx\u2219y :  \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (z \u2219 x) \u2219 y\nx\u2219yz\u2248zx\u2219y x y z =  trans (x\u2219yz\u2248z\u2219xy x y z) (sym (assoc z x y))\n\n------------------------------------------------------------------------\n-- Partitions (2,1).\n\n-- Their laws are proved by composing proofs for partitions (1,1) with\n-- trans (assoc x y z).\n\nxy\u2219z\u2248y\u2219xz :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 y \u2219 (x \u2219 z)\nxy\u2219z\u2248y\u2219xz x y z =  trans (assoc x y z) (x\u2219yz\u2248y\u2219xz x y z)\n\nxy\u2219z\u2248z\u2219yx :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 z \u2219 (y \u2219 x)\nxy\u2219z\u2248z\u2219yx x y z =  trans (assoc x y z) (x\u2219yz\u2248z\u2219yx x y z)\n\nxy\u2219z\u2248x\u2219zy :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 x \u2219 (z \u2219 y)\nxy\u2219z\u2248x\u2219zy x y z =  trans (assoc x y z) (x\u2219yz\u2248x\u2219zy x y z)\n\nxy\u2219z\u2248y\u2219zx :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 y \u2219 (z \u2219 x)\nxy\u2219z\u2248y\u2219zx x y z =  trans (assoc x y z) (x\u2219yz\u2248y\u2219zx x y z)\n\nxy\u2219z\u2248z\u2219xy :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 z \u2219 (x \u2219 y)\nxy\u2219z\u2248z\u2219xy x y z =  trans (assoc x y z) (x\u2219yz\u2248z\u2219xy x y z)\n\n------------------------------------------------------------------------\n-- Partitions (2,2).\n\n-- These proofs are by composing with the proofs for (2,1).\n\nxy\u2219z\u2248yx\u2219z :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 (y \u2219 x) \u2219 z\nxy\u2219z\u2248yx\u2219z x y z =  trans (xy\u2219z\u2248y\u2219xz _ _ _) (sym (assoc y x z))\n\nxy\u2219z\u2248zy\u2219x :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 (z \u2219 y) \u2219 x\nxy\u2219z\u2248zy\u2219x x y z =  trans (xy\u2219z\u2248z\u2219yx x y z) (sym (assoc z y x))\n\nxy\u2219z\u2248xz\u2219y :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 (x \u2219 z) \u2219 y\nxy\u2219z\u2248xz\u2219y x y z =  trans (xy\u2219z\u2248x\u2219zy x y z) (sym (assoc x z y))\n\nxy\u2219z\u2248yz\u2219x :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 (y \u2219 z) \u2219 x\nxy\u2219z\u2248yz\u2219x x y z =  trans (xy\u2219z\u2248y\u2219zx x y z) (sym (assoc y z x))\n\nxy\u2219z\u2248zx\u2219y :  \u2200 x y z \u2192 (x \u2219 y) \u2219 z \u2248 (z \u2219 x) \u2219 y\nxy\u2219z\u2248zx\u2219y x y z =  trans (xy\u2219z\u2248z\u2219xy x y z) (sym (assoc z x y))\n\n------------------------------------------------------------------------\n-- commutative semigroup has Jordan identity\n\nxy\u2219xx\u2248x\u2219yxx : \u2200 x y \u2192 (x \u2219 y) \u2219 (x \u2219 x) \u2248 x \u2219 (y \u2219 (x \u2219 x))\nxy\u2219xx\u2248x\u2219yxx x y = assoc x y ((x \u2219 x))\n\n------------------------------------------------------------------------\n-- commutative semigroup is left/right/middle semiMedial\n\nsemimedial\u02e1 : LeftSemimedial _\u2219_\nsemimedial\u02e1 x y z = begin\n  (x \u2219 x) \u2219 (y \u2219 z) \u2248\u27e8 assoc x x (y \u2219 z) \u27e9\n  x \u2219 (x \u2219 (y \u2219 z)) \u2248\u27e8 \u2219-cong\u02e1 (sym (assoc x y z)) \u27e9\n  x \u2219 ((x \u2219 y) \u2219 z) \u2248\u27e8 \u2219-cong\u02e1 (\u2219-cong\u02b3 (comm x y)) \u27e9\n  x \u2219 ((y \u2219 x) \u2219 z) \u2248\u27e8 \u2219-cong\u02e1 (assoc y x z) \u27e9\n  x \u2219 (y \u2219 (x \u2219 z)) \u2248\u27e8 sym (assoc x y ((x \u2219 z))) \u27e9\n  (x \u2219 y) \u2219 (x \u2219 z) \u220e\n\nsemimedial\u02b3 : RightSemimedial _\u2219_\nsemimedial\u02b3 x y z = begin\n  (y \u2219 z) \u2219 (x \u2219 x) \u2248\u27e8 assoc y z (x \u2219 x) \u27e9\n  y \u2219 (z \u2219 (x \u2219 x)) \u2248\u27e8 \u2219-cong\u02e1 (sym (assoc z x x)) \u27e9\n  y \u2219 ((z \u2219 x) \u2219 x) \u2248\u27e8 \u2219-cong\u02e1 (\u2219-cong\u02b3 (comm z x)) \u27e9\n  y \u2219 ((x \u2219 z) \u2219 x) \u2248\u27e8 \u2219-cong\u02e1 (assoc x z x) \u27e9\n  y \u2219 (x \u2219 (z \u2219 x)) \u2248\u27e8 sym (assoc y x ((z \u2219 x))) \u27e9\n  (y \u2219 x) \u2219 (z \u2219 x) \u220e\n\nmiddleSemimedial : \u2200 x y z \u2192 (x \u2219 y) \u2219 (z \u2219 x) \u2248 (x \u2219 z) \u2219 (y \u2219 x)\nmiddleSemimedial x y z = begin\n  (x \u2219 y) \u2219 (z \u2219 x) \u2248\u27e8 assoc x y ((z \u2219 x)) \u27e9\n  x \u2219 (y \u2219 (z \u2219 x)) \u2248\u27e8 \u2219-cong\u02e1 (sym (assoc y z x)) \u27e9\n  x \u2219 ((y \u2219 z) \u2219 x) \u2248\u27e8 \u2219-cong\u02e1 (\u2219-cong\u02b3 (comm y z)) \u27e9\n  x \u2219 ((z \u2219 y) \u2219 x) \u2248\u27e8 \u2219-cong\u02e1 ( assoc z y x) \u27e9\n  x \u2219 (z \u2219 (y \u2219 x)) \u2248\u27e8 sym (assoc x z ((y \u2219 x))) \u27e9\n  (x \u2219 z) \u2219 (y \u2219 x) \u220e\n\nsemimedial : Semimedial _\u2219_\nsemimedial = semimedial\u02e1 , semimedial\u02b3\n</pre>"},{"location":"md/Algebra/Properties/Semigroup/","title":"Algebra.Properties.Semigroup","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some theory for Semigroup\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra using (Semigroup)\n\nmodule Algebra.Properties.Semigroup {a \u2113} (S : Semigroup a \u2113) where\n\nopen import Data.Product.Base using (_,_)\n\nopen Semigroup S\n  using (Carrier; _\u2219_; _\u2248_; setoid; trans ; refl; sym; assoc; \u2219-cong; \u2219-cong\u02e1; \u2219-cong\u02b3)\nopen import Algebra.Definitions _\u2248_\n  using (Alternative; LeftAlternative; RightAlternative; Flexible)\n\nprivate\n  variable\n    u v w x y z : Carrier\n\nx\u2219yz\u2248xy\u2219z : \u2200 x y z \u2192 x \u2219 (y \u2219 z) \u2248 (x \u2219 y) \u2219 z\nx\u2219yz\u2248xy\u2219z x y z = sym (assoc x y z)\n\nalternative\u02e1 : LeftAlternative _\u2219_\nalternative\u02e1 x y = assoc x x y\n\nalternative\u02b3 : RightAlternative _\u2219_\nalternative\u02b3 x y = sym (assoc x y y)\n\nalternative : Alternative _\u2219_\nalternative = alternative\u02e1 , alternative\u02b3\n\nflexible : Flexible _\u2219_\nflexible x y = assoc x y x\n\nmodule _ (uv\u2248w : u \u2219 v \u2248 w) where\n  uv\u2248w\u21d2xu\u2219v\u2248xw : \u2200 x \u2192 (x \u2219 u) \u2219 v \u2248 x \u2219 w\n  uv\u2248w\u21d2xu\u2219v\u2248xw x = trans (assoc x u v) (\u2219-cong\u02e1 uv\u2248w)\n\n  uv\u2248w\u21d2u\u2219vx\u2248wx : \u2200 x \u2192 u \u2219 (v \u2219 x) \u2248 w \u2219 x\n  uv\u2248w\u21d2u\u2219vx\u2248wx x = trans (sym (assoc u v x)) (\u2219-cong\u02b3 uv\u2248w)\n\n  uv\u2248w\u21d2u[vx\u2219y]\u2248w\u2219xy : \u2200 x y \u2192 u \u2219 ((v \u2219 x) \u2219 y) \u2248 w \u2219 (x \u2219 y)\n  uv\u2248w\u21d2u[vx\u2219y]\u2248w\u2219xy x y = trans (\u2219-cong\u02e1 (assoc v x y)) (uv\u2248w\u21d2u\u2219vx\u2248wx (x \u2219 y))\n\n  uv\u2248w\u21d2x[uv\u2219y]\u2248x\u2219wy : \u2200 x y \u2192 x \u2219 (u \u2219 (v \u2219 y)) \u2248 x \u2219 (w \u2219 y)\n  uv\u2248w\u21d2x[uv\u2219y]\u2248x\u2219wy x y = \u2219-cong\u02e1 (uv\u2248w\u21d2u\u2219vx\u2248wx y)\n\n  uv\u2248w\u21d2[x\u2219yu]v\u2248x\u2219yw : \u2200 x y \u2192 (x \u2219 (y \u2219 u)) \u2219 v \u2248 x \u2219 (y \u2219 w)\n  uv\u2248w\u21d2[x\u2219yu]v\u2248x\u2219yw x y = trans (assoc x (y \u2219 u) v) (\u2219-cong\u02e1 (uv\u2248w\u21d2xu\u2219v\u2248xw y))\n\n  uv\u2248w\u21d2[xu\u2219v]y\u2248x\u2219wy : \u2200 x y \u2192 ((x \u2219 u) \u2219 v) \u2219 y \u2248 x \u2219 (w \u2219 y)\n  uv\u2248w\u21d2[xu\u2219v]y\u2248x\u2219wy x y = trans (\u2219-cong\u02b3 (uv\u2248w\u21d2xu\u2219v\u2248xw x)) (assoc x w y)\n\n  uv\u2248w\u21d2[xy\u2219u]v\u2248x\u2219yw : \u2200 x y \u2192 ((x \u2219 y) \u2219 u) \u2219 v \u2248 x \u2219 (y \u2219 w)\n  uv\u2248w\u21d2[xy\u2219u]v\u2248x\u2219yw x y = trans (\u2219-cong\u02b3 (assoc x y u)) (uv\u2248w\u21d2[x\u2219yu]v\u2248x\u2219yw x y )\n\nmodule _ (uv\u2248w : u \u2219 v \u2248 w) where\n\n  uv\u2248w\u21d2xu\u2219vy\u2248x\u2219wy : \u2200 x y \u2192 (x \u2219 u) \u2219 (v \u2219 y) \u2248 x \u2219 (w \u2219 y)\n  uv\u2248w\u21d2xu\u2219vy\u2248x\u2219wy x y = uv\u2248w\u21d2xu\u2219v\u2248xw (uv\u2248w\u21d2u\u2219vx\u2248wx uv\u2248w y) x\n\n  uv\u2248w\u21d2xy\u2248z\u21d2u[vx\u2219y]\u2248wz : \u2200 x y \u2192 x \u2219 y \u2248 z \u2192 u \u2219 ((v \u2219 x) \u2219 y) \u2248 w \u2219 z\n  uv\u2248w\u21d2xy\u2248z\u21d2u[vx\u2219y]\u2248wz x y xy\u2248z = trans (\u2219-cong\u02e1 (uv\u2248w\u21d2xu\u2219v\u2248xw xy\u2248z v)) (uv\u2248w\u21d2u\u2219vx\u2248wx uv\u2248w _)\n\n  uv\u2248w\u21d2x\u2219wy\u2248x\u2219[u\u2219vy] : x \u2219 (w \u2219 y) \u2248 x \u2219 (u \u2219 (v \u2219 y))\n  uv\u2248w\u21d2x\u2219wy\u2248x\u2219[u\u2219vy] = sym (uv\u2248w\u21d2x[uv\u2219y]\u2248x\u2219wy uv\u2248w _ _)\n\nmodule _ u v w x where\n  [uv\u2219w]x\u2248u[vw\u2219x] : ((u \u2219 v) \u2219 w) \u2219 x \u2248 u \u2219 ((v \u2219 w) \u2219 x)\n  [uv\u2219w]x\u2248u[vw\u2219x] = uv\u2248w\u21d2[xu\u2219v]y\u2248x\u2219wy refl u x\n\n  [uv\u2219w]x\u2248u[v\u2219wx] : ((u \u2219 v) \u2219 w) \u2219 x \u2248 u \u2219 (v \u2219 (w \u2219 x))\n  [uv\u2219w]x\u2248u[v\u2219wx] = uv\u2248w\u21d2[xy\u2219u]v\u2248x\u2219yw refl u v\n\n  [u\u2219vw]x\u2248uv\u2219wx : (u \u2219 (v \u2219 w)) \u2219 x \u2248 (u \u2219 v) \u2219 (w \u2219 x)\n  [u\u2219vw]x\u2248uv\u2219wx = trans (sym (\u2219-cong\u02b3 (assoc u v w))) (assoc (u \u2219 v) w x)\n\n  [u\u2219vw]x\u2248u[v\u2219wx] : (u \u2219 (v \u2219 w)) \u2219 x \u2248 u \u2219 (v \u2219 (w \u2219 x))\n  [u\u2219vw]x\u2248u[v\u2219wx] = uv\u2248w\u21d2[x\u2219yu]v\u2248x\u2219yw refl u v\n\n  uv\u2219wx\u2248u[vw\u2219x] : (u \u2219 v) \u2219 (w \u2219 x) \u2248 u \u2219 ((v \u2219 w) \u2219 x)\n  uv\u2219wx\u2248u[vw\u2219x] = uv\u2248w\u21d2xu\u2219vy\u2248x\u2219wy refl u x\n\nmodule _ (uv\u2248wx : u \u2219 v \u2248 w \u2219 x) where\n  uv\u2248wx\u21d2yu\u2219v\u2248yw\u2219x : \u2200 y \u2192 (y \u2219 u) \u2219 v \u2248 (y \u2219 w) \u2219 x\n  uv\u2248wx\u21d2yu\u2219v\u2248yw\u2219x y = trans (uv\u2248w\u21d2xu\u2219v\u2248xw uv\u2248wx y) (sym (assoc y w x))\n\n  uv\u2248wx\u21d2u\u2219vy\u2248w\u2219xy : \u2200 y \u2192 u \u2219 (v \u2219 y) \u2248 w \u2219 (x \u2219 y)\n  uv\u2248wx\u21d2u\u2219vy\u2248w\u2219xy y = trans (uv\u2248w\u21d2u\u2219vx\u2248wx uv\u2248wx y) (assoc w x y)\n\n  uv\u2248wx\u21d2yu\u2219vz\u2248yw\u2219xz : \u2200 y z \u2192 (y \u2219 u) \u2219 (v \u2219 z) \u2248 (y \u2219 w) \u2219 (x \u2219 z)\n  uv\u2248wx\u21d2yu\u2219vz\u2248yw\u2219xz y z = trans (uv\u2248w\u21d2xu\u2219v\u2248xw (uv\u2248wx\u21d2u\u2219vy\u2248w\u2219xy z) y) (sym (assoc y w (x \u2219 z)))\n</pre>"},{"location":"md/Algebra/Structures/","title":"Algebra.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some algebraic structures (not packed up with sets, operations, etc.)\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra`, unless\n-- you want to parameterise it via the equality relation.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Algebra.Structures\n  {a \u2113} {A : Set a}  -- The underlying set\n  (_\u2248_ : Rel A \u2113)    -- The underlying equality relation\n  where\n\n-- The file is divided into sections depending on the arities of the\n-- components of the algebraic structure.\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Algebra.Definitions _\u2248_\nimport Algebra.Consequences.Setoid as Consequences\nopen import Data.Product.Base using (_,_; proj\u2081; proj\u2082)\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Structures with 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord IsSuccessorSet (suc# : Op\u2081 A) (zero# : A) : Set (a \u2294 \u2113) where\n  field\n    isEquivalence : IsEquivalence _\u2248_\n    suc#-cong     : Congruent\u2081 suc#\n\n  open IsEquivalence isEquivalence public\n\n  setoid : Setoid a \u2113\n  setoid = record { isEquivalence = isEquivalence }\n\n------------------------------------------------------------------------\n-- Structures with 1 binary operation\n------------------------------------------------------------------------\n\nrecord IsMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isEquivalence : IsEquivalence _\u2248_\n    \u2219-cong        : Congruent\u2082 \u2219\n\n  open IsEquivalence isEquivalence public\n\n  setoid : Setoid a \u2113\n  setoid = record { isEquivalence = isEquivalence }\n\n  open Consequences.Congruence setoid \u2219-cong public\n\nrecord IsCommutativeMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma : IsMagma \u2219\n    comm    : Commutative \u2219\n\n  open IsMagma isMagma public\n\nrecord IsIdempotentMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma : IsMagma \u2219\n    idem    : Idempotent \u2219\n\n  open IsMagma isMagma public\n\nrecord IsAlternativeMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma  : IsMagma \u2219\n    alter    : Alternative \u2219\n\n  open IsMagma isMagma public\n\n  alternative\u02e1 : LeftAlternative \u2219\n  alternative\u02e1 = proj\u2081 alter\n\n  alternative\u02b3 : RightAlternative \u2219\n  alternative\u02b3 = proj\u2082 alter\n\nrecord IsFlexibleMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma  : IsMagma \u2219\n    flex     : Flexible \u2219\n\n  open IsMagma isMagma public\n\nrecord IsMedialMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma : IsMagma \u2219\n    medial  : Medial \u2219\n\n  open IsMagma isMagma public\n\nrecord IsSemimedialMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma    : IsMagma \u2219\n    semiMedial : Semimedial \u2219\n\n  open IsMagma isMagma public\n\n  semimedial\u02e1 : LeftSemimedial \u2219\n  semimedial\u02e1 = proj\u2081 semiMedial\n\n  semimedial\u02b3 : RightSemimedial \u2219\n  semimedial\u02b3 = proj\u2082 semiMedial\n\nrecord IsSelectiveMagma (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma : IsMagma \u2219\n    sel     : Selective \u2219\n\n  open IsMagma isMagma public\n\n\nrecord IsSemigroup (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma : IsMagma \u2219\n    assoc   : Associative \u2219\n\n  open IsMagma isMagma public\n\n\nrecord IsBand (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isSemigroup : IsSemigroup \u2219\n    idem        : Idempotent \u2219\n\n  open IsSemigroup isSemigroup public\n\n\nrecord IsCommutativeSemigroup (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isSemigroup : IsSemigroup \u2219\n    comm        : Commutative \u2219\n\n  open IsSemigroup isSemigroup public\n\n  isCommutativeMagma : IsCommutativeMagma \u2219\n  isCommutativeMagma = record\n    { isMagma = isMagma\n    ; comm    = comm\n    }\n\n\nrecord IsCommutativeBand (\u2219 : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isBand : IsBand \u2219\n    comm   : Commutative \u2219\n\n  open IsBand isBand public\n\n  isCommutativeSemigroup : IsCommutativeSemigroup \u2219\n  isCommutativeSemigroup = record { isSemigroup = isSemigroup ; comm = comm }\n\n  open IsCommutativeSemigroup isCommutativeSemigroup public\n    using (isCommutativeMagma)\n\n------------------------------------------------------------------------\n-- Structures with 1 binary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord IsUnitalMagma (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isMagma  : IsMagma \u2219\n    identity : Identity \u03b5 \u2219\n\n  open IsMagma isMagma public\n\n  identity\u02e1 : LeftIdentity \u03b5 \u2219\n  identity\u02e1 = proj\u2081 identity\n\n  identity\u02b3 : RightIdentity \u03b5 \u2219\n  identity\u02b3 = proj\u2082 identity\n\n\nrecord IsMonoid (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isSemigroup : IsSemigroup \u2219\n    identity    : Identity \u03b5 \u2219\n\n  open IsSemigroup isSemigroup public\n\n  identity\u02e1 : LeftIdentity \u03b5 \u2219\n  identity\u02e1 = proj\u2081 identity\n\n  identity\u02b3 : RightIdentity \u03b5 \u2219\n  identity\u02b3 = proj\u2082 identity\n\n  isUnitalMagma : IsUnitalMagma \u2219 \u03b5\n  isUnitalMagma = record\n    { isMagma  = isMagma\n    ; identity = identity\n    }\n\n\nrecord IsCommutativeMonoid (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isMonoid : IsMonoid \u2219 \u03b5\n    comm     : Commutative \u2219\n\n  open IsMonoid isMonoid public\n\n  isCommutativeSemigroup : IsCommutativeSemigroup \u2219\n  isCommutativeSemigroup = record\n    { isSemigroup = isSemigroup\n    ; comm        = comm\n    }\n\n  open IsCommutativeSemigroup isCommutativeSemigroup public\n    using (isCommutativeMagma)\n\n\nrecord IsIdempotentMonoid (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isMonoid : IsMonoid \u2219 \u03b5\n    idem     : Idempotent \u2219\n\n  open IsMonoid isMonoid public\n\n  isBand : IsBand \u2219\n  isBand = record { isSemigroup = isSemigroup ; idem = idem }\n\n\nrecord IsIdempotentCommutativeMonoid (\u2219 : Op\u2082 A)\n                                     (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isCommutativeMonoid : IsCommutativeMonoid \u2219 \u03b5\n    idem                : Idempotent \u2219\n\n  open IsCommutativeMonoid isCommutativeMonoid public\n\n  isIdempotentMonoid : IsIdempotentMonoid \u2219 \u03b5\n  isIdempotentMonoid = record { isMonoid = isMonoid ; idem = idem }\n\n  open IsIdempotentMonoid isIdempotentMonoid public\n    using (isBand)\n\n  isCommutativeBand : IsCommutativeBand \u2219\n  isCommutativeBand = record { isBand = isBand ; comm = comm }\n\n------------------------------------------------------------------------\n-- Structures with 1 binary operation, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord IsInvertibleMagma (_\u2219_ : Op\u2082 A) (\u03b5 : A) (_\u207b\u00b9 : Op\u2081 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma  : IsMagma _\u2219_\n    inverse   : Inverse \u03b5 _\u207b\u00b9 _\u2219_\n    \u207b\u00b9-cong   : Congruent\u2081 _\u207b\u00b9\n\n  open IsMagma isMagma public\n\n  inverse\u02e1 : LeftInverse \u03b5 _\u207b\u00b9 _\u2219_\n  inverse\u02e1 = proj\u2081 inverse\n\n  inverse\u02b3 : RightInverse \u03b5 _\u207b\u00b9 _\u2219_\n  inverse\u02b3 = proj\u2082 inverse\n\n\nrecord IsInvertibleUnitalMagma (_\u2219_ : Op\u2082 A) (\u03b5 : A) (\u207b\u00b9 : Op\u2081 A) : Set (a \u2294 \u2113) where\n  field\n    isInvertibleMagma : IsInvertibleMagma _\u2219_  \u03b5 \u207b\u00b9\n    identity          : Identity \u03b5 _\u2219_\n\n  open IsInvertibleMagma isInvertibleMagma public\n\n  identity\u02e1 : LeftIdentity \u03b5 _\u2219_\n  identity\u02e1 = proj\u2081 identity\n\n  identity\u02b3 : RightIdentity \u03b5 _\u2219_\n  identity\u02b3 = proj\u2082 identity\n\n  isUnitalMagma : IsUnitalMagma _\u2219_  \u03b5\n  isUnitalMagma = record\n    { isMagma  = isMagma\n    ; identity = identity\n    }\n\n\nrecord IsGroup (_\u2219_ : Op\u2082 A) (\u03b5 : A) (_\u207b\u00b9 : Op\u2081 A) : Set (a \u2294 \u2113) where\n  field\n    isMonoid  : IsMonoid _\u2219_ \u03b5\n    inverse   : Inverse \u03b5 _\u207b\u00b9 _\u2219_\n    \u207b\u00b9-cong   : Congruent\u2081 _\u207b\u00b9\n\n  open IsMonoid isMonoid public\n\n  infixr 6 _\\\\_\n  _\\\\_ : Op\u2082 A\n  x \\\\ y = (x \u207b\u00b9) \u2219 y\n\n  infixl 6 _//_\n  _//_ : Op\u2082 A\n  x // y = x \u2219 (y \u207b\u00b9)\n\n  -- Deprecated.\n  infixl 6 _-_\n  _-_ : Op\u2082 A\n  _-_ = _//_\n  {-# WARNING_ON_USAGE _-_\n  \"Warning: _-_ was deprecated in v2.1.\n  Please use _//_ instead. \"\n  #-}\n\n  inverse\u02e1 : LeftInverse \u03b5 _\u207b\u00b9 _\u2219_\n  inverse\u02e1 = proj\u2081 inverse\n\n  inverse\u02b3 : RightInverse \u03b5 _\u207b\u00b9 _\u2219_\n  inverse\u02b3 = proj\u2082 inverse\n\n  unique\u02e1-\u207b\u00b9 : \u2200 x y \u2192 (x \u2219 y) \u2248 \u03b5 \u2192 x \u2248 (y \u207b\u00b9)\n  unique\u02e1-\u207b\u00b9 = Consequences.assoc\u2227id\u2227inv\u02b3\u21d2inv\u02e1-unique\n                setoid \u2219-cong assoc identity inverse\u02b3\n  {-# WARNING_ON_USAGE unique\u02e1-\u207b\u00b9\n  \"Warning: unique\u02e1-\u207b\u00b9 was deprecated in v2.3.\n  Please use Algebra.Properties.Group.inverse\u02e1-unique instead. \"\n  #-}\n\n  unique\u02b3-\u207b\u00b9 : \u2200 x y \u2192 (x \u2219 y) \u2248 \u03b5 \u2192 y \u2248 (x \u207b\u00b9)\n  unique\u02b3-\u207b\u00b9 = Consequences.assoc\u2227id\u2227inv\u02e1\u21d2inv\u02b3-unique\n                setoid \u2219-cong assoc identity inverse\u02e1\n  {-# WARNING_ON_USAGE unique\u02b3-\u207b\u00b9\n  \"Warning: unique\u02b3-\u207b\u00b9 was deprecated in v2.3.\n  Please use Algebra.Properties.Group.inverse\u02b3-unique instead. \"\n  #-}\n\n  isInvertibleMagma : IsInvertibleMagma _\u2219_ \u03b5 _\u207b\u00b9\n  isInvertibleMagma = record\n    { isMagma = isMagma\n    ; inverse = inverse\n    ; \u207b\u00b9-cong = \u207b\u00b9-cong\n    }\n\n  isInvertibleUnitalMagma : IsInvertibleUnitalMagma _\u2219_ \u03b5 _\u207b\u00b9\n  isInvertibleUnitalMagma = record\n    { isInvertibleMagma = isInvertibleMagma\n    ; identity = identity\n    }\n\n\nrecord IsAbelianGroup (\u2219 : Op\u2082 A)\n                      (\u03b5 : A) (\u207b\u00b9 : Op\u2081 A) : Set (a \u2294 \u2113) where\n  field\n    isGroup : IsGroup \u2219 \u03b5 \u207b\u00b9\n    comm    : Commutative \u2219\n\n  open IsGroup isGroup public renaming (_//_ to _-_) hiding (_\\\\_; _-_)\n\n  isCommutativeMonoid : IsCommutativeMonoid \u2219 \u03b5\n  isCommutativeMonoid = record\n    { isMonoid = isMonoid\n    ; comm     = comm\n    }\n\n  open IsCommutativeMonoid isCommutativeMonoid public\n    using (isCommutativeMagma; isCommutativeSemigroup)\n\n\n------------------------------------------------------------------------\n-- Structures with 2 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord IsNearSemiring (+ * : Op\u2082 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isMonoid    : IsMonoid + 0#\n    *-cong        : Congruent\u2082 *\n    *-assoc       : Associative *\n    distrib\u02b3      : * DistributesOver\u02b3 +\n    zero\u02e1         : LeftZero 0# *\n\n  open IsMonoid +-isMonoid public\n    renaming\n    ( assoc         to +-assoc\n    ; \u2219-cong        to +-cong\n    ; \u2219-cong\u02e1       to +-cong\u02e1\n    ; \u2219-cong\u02b3       to +-cong\u02b3\n    ; identity      to +-identity\n    ; identity\u02e1     to +-identity\u02e1\n    ; identity\u02b3     to +-identity\u02b3\n    ; isMagma       to +-isMagma\n    ; isUnitalMagma to +-isUnitalMagma\n    ; isSemigroup   to +-isSemigroup\n    )\n\n  *-isMagma : IsMagma *\n  *-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = *-cong\n    }\n\n  *-isSemigroup : IsSemigroup *\n  *-isSemigroup = record\n    { isMagma = *-isMagma\n    ; assoc   = *-assoc\n    }\n\n  open IsMagma *-isMagma public\n    using ()\n    renaming\n    ( \u2219-cong\u02e1  to *-cong\u02e1\n    ; \u2219-cong\u02b3  to *-cong\u02b3\n    )\n\n\nrecord IsSemiringWithoutOne (+ * : Op\u2082 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-cong                : Congruent\u2082 *\n    *-assoc               : Associative *\n    distrib               : * DistributesOver +\n    zero                  : Zero 0# *\n\n  open IsCommutativeMonoid +-isCommutativeMonoid public\n    using (setoid; isEquivalence)\n    renaming\n    ( \u2219-cong                 to +-cong\n    ; \u2219-cong\u02e1                to +-cong\u02e1\n    ; \u2219-cong\u02b3                to +-cong\u02b3\n    ; assoc                  to +-assoc\n    ; identity               to +-identity\n    ; identity\u02e1              to +-identity\u02e1\n    ; identity\u02b3              to +-identity\u02b3\n    ; comm                   to +-comm\n    ; isMonoid               to +-isMonoid\n    ; isCommutativeMagma     to +-isCommutativeMagma\n    ; isCommutativeSemigroup to +-isCommutativeSemigroup\n    )\n\n  open IsEquivalence isEquivalence public\n\n  *-isMagma : IsMagma *\n  *-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = *-cong\n    }\n\n  *-isSemigroup : IsSemigroup *\n  *-isSemigroup = record\n    { isMagma = *-isMagma\n    ; assoc   = *-assoc\n    }\n\n  open IsMagma *-isMagma public\n    using ()\n    renaming\n    ( \u2219-cong\u02e1 to *-cong\u02e1\n    ; \u2219-cong\u02b3 to *-cong\u02b3\n    )\n\n  distrib\u02e1 : * DistributesOver\u02e1 +\n  distrib\u02e1 = proj\u2081 distrib\n\n  distrib\u02b3 : * DistributesOver\u02b3 +\n  distrib\u02b3 = proj\u2082 distrib\n\n  zero\u02e1 : LeftZero 0# *\n  zero\u02e1 = proj\u2081 zero\n\n  zero\u02b3 : RightZero 0# *\n  zero\u02b3 = proj\u2082 zero\n\n  isNearSemiring : IsNearSemiring + * 0#\n  isNearSemiring = record\n    { +-isMonoid    = +-isMonoid\n    ; *-cong        = *-cong\n    ; *-assoc       = *-assoc\n    ; distrib\u02b3      = proj\u2082 distrib\n    ; zero\u02e1         = zero\u02e1\n    }\n\nrecord IsCommutativeSemiringWithoutOne\n         (+ * : Op\u2082 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    isSemiringWithoutOne : IsSemiringWithoutOne + * 0#\n    *-comm               : Commutative *\n\n  open IsSemiringWithoutOne isSemiringWithoutOne public\n\n  *-isCommutativeSemigroup : IsCommutativeSemigroup *\n  *-isCommutativeSemigroup = record\n    { isSemigroup = *-isSemigroup\n    ; comm        = *-comm\n    }\n\n  open IsCommutativeSemigroup *-isCommutativeSemigroup public\n    using () renaming (isCommutativeMagma to *-isCommutativeMagma)\n\n------------------------------------------------------------------------\n-- Structures with 2 binary operations &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord IsSemiringWithoutAnnihilatingZero (+ * : Op\u2082 A)\n                                         (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    -- Note that these structures do have an additive unit, but this\n    -- unit does not necessarily annihilate multiplication.\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-cong                : Congruent\u2082 *\n    *-assoc               : Associative *\n    *-identity            : Identity 1# *\n    distrib               : * DistributesOver +\n\n  distrib\u02e1 : * DistributesOver\u02e1 +\n  distrib\u02e1 = proj\u2081 distrib\n\n  distrib\u02b3 : * DistributesOver\u02b3 +\n  distrib\u02b3 = proj\u2082 distrib\n\n  open IsCommutativeMonoid +-isCommutativeMonoid public\n    renaming\n    ( assoc                  to +-assoc\n    ; \u2219-cong                 to +-cong\n    ; \u2219-cong\u02e1                to +-cong\u02e1\n    ; \u2219-cong\u02b3                to +-cong\u02b3\n    ; identity               to +-identity\n    ; identity\u02e1              to +-identity\u02e1\n    ; identity\u02b3              to +-identity\u02b3\n    ; comm                   to +-comm\n    ; isMagma                to +-isMagma\n    ; isSemigroup            to +-isSemigroup\n    ; isMonoid               to +-isMonoid\n    ; isUnitalMagma          to +-isUnitalMagma\n    ; isCommutativeMagma     to +-isCommutativeMagma\n    ; isCommutativeSemigroup to +-isCommutativeSemigroup\n    )\n\n  *-isMagma : IsMagma *\n  *-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = *-cong\n    }\n\n  *-isSemigroup : IsSemigroup *\n  *-isSemigroup = record\n    { isMagma = *-isMagma\n    ; assoc   = *-assoc\n    }\n\n  *-isMonoid : IsMonoid * 1#\n  *-isMonoid = record\n    { isSemigroup = *-isSemigroup\n    ; identity    = *-identity\n    }\n\n  open IsMonoid *-isMonoid public\n    using ()\n    renaming\n    ( \u2219-cong\u02e1     to *-cong\u02e1\n    ; \u2219-cong\u02b3     to *-cong\u02b3\n    ; identity\u02e1   to *-identity\u02e1\n    ; identity\u02b3   to *-identity\u02b3\n    )\n\n\nrecord IsSemiring (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isSemiringWithoutAnnihilatingZero :\n      IsSemiringWithoutAnnihilatingZero + * 0# 1#\n    zero : Zero 0# *\n\n  open IsSemiringWithoutAnnihilatingZero\n         isSemiringWithoutAnnihilatingZero public\n\n  isSemiringWithoutOne : IsSemiringWithoutOne + * 0#\n  isSemiringWithoutOne = record\n    { +-isCommutativeMonoid = +-isCommutativeMonoid\n    ; *-cong                = *-cong\n    ; *-assoc               = *-assoc\n    ; distrib               = distrib\n    ; zero                  = zero\n    }\n\n  open IsSemiringWithoutOne isSemiringWithoutOne public\n    using\n    ( isNearSemiring\n    ; zero\u02e1\n    ; zero\u02b3\n    )\n\n\nrecord IsCommutativeSemiring (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isSemiring : IsSemiring + * 0# 1#\n    *-comm     : Commutative *\n\n  open IsSemiring isSemiring public\n\n  isCommutativeSemiringWithoutOne :\n    IsCommutativeSemiringWithoutOne + * 0#\n  isCommutativeSemiringWithoutOne = record\n    { isSemiringWithoutOne = isSemiringWithoutOne\n    ; *-comm = *-comm\n    }\n\n  open IsCommutativeSemiringWithoutOne isCommutativeSemiringWithoutOne public\n    using\n    ( *-isCommutativeMagma\n    ; *-isCommutativeSemigroup\n    )\n\n  *-isCommutativeMonoid : IsCommutativeMonoid * 1#\n  *-isCommutativeMonoid = record\n    { isMonoid = *-isMonoid\n    ; comm     = *-comm\n    }\n\n\nrecord IsCancellativeCommutativeSemiring (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isCommutativeSemiring : IsCommutativeSemiring + * 0# 1#\n    *-cancel\u02e1-nonZero     : AlmostLeftCancellative 0# *\n\n  open IsCommutativeSemiring isCommutativeSemiring public\n\n  *-cancel\u02b3-nonZero : AlmostRightCancellative 0# *\n  *-cancel\u02b3-nonZero = Consequences.comm\u2227almostCancel\u02e1\u21d2almostCancel\u02b3 setoid\n      *-comm *-cancel\u02e1-nonZero\n\nrecord IsIdempotentSemiring (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isSemiring     : IsSemiring + * 0# 1#\n    +-idem         : Idempotent +\n\n  open IsSemiring isSemiring public\n\n  +-isIdempotentCommutativeMonoid : IsIdempotentCommutativeMonoid + 0#\n  +-isIdempotentCommutativeMonoid = record\n    { isCommutativeMonoid = +-isCommutativeMonoid\n    ; idem = +-idem\n    }\n\n  open IsIdempotentCommutativeMonoid +-isIdempotentCommutativeMonoid public\n    using ()\n    renaming ( isCommutativeBand to +-isCommutativeBand\n             ; isBand to +-isBand\n             ; isIdempotentMonoid to +-isIdempotentMonoid\n             )\n\n\nrecord IsKleeneAlgebra (+ * : Op\u2082 A) (\u22c6 : Op\u2081 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isIdempotentSemiring  : IsIdempotentSemiring + * 0# 1#\n    starExpansive         : StarExpansive 1# + * \u22c6\n    starDestructive       : StarDestructive + * \u22c6\n\n  open IsIdempotentSemiring isIdempotentSemiring public\n\n  starExpansive\u02e1 : StarLeftExpansive 1# + * \u22c6\n  starExpansive\u02e1 = proj\u2081 starExpansive\n\n  starExpansive\u02b3 : StarRightExpansive 1# + * \u22c6\n  starExpansive\u02b3 = proj\u2082 starExpansive\n\n  starDestructive\u02e1 : StarLeftDestructive + * \u22c6\n  starDestructive\u02e1 = proj\u2081 starDestructive\n\n  starDestructive\u02b3 : StarRightDestructive + * \u22c6\n  starDestructive\u02b3 = proj\u2082 starDestructive\n\nrecord IsQuasiring (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isMonoid    : IsMonoid + 0#\n    *-cong        : Congruent\u2082 *\n    *-assoc       : Associative *\n    *-identity    : Identity 1# *\n    distrib       : * DistributesOver +\n    zero          : Zero 0# *\n\n  open IsMonoid +-isMonoid public\n    renaming\n    ( assoc         to +-assoc\n    ; \u2219-cong        to +-cong\n    ; \u2219-cong\u02e1       to +-cong\u02e1\n    ; \u2219-cong\u02b3       to +-cong\u02b3\n    ; identity      to +-identity\n    ; identity\u02e1     to +-identity\u02e1\n    ; identity\u02b3     to +-identity\u02b3\n    ; isMagma       to +-isMagma\n    ; isUnitalMagma to +-isUnitalMagma\n    ; isSemigroup   to +-isSemigroup\n    )\n\n  distrib\u02e1 : * DistributesOver\u02e1 +\n  distrib\u02e1 = proj\u2081 distrib\n\n  distrib\u02b3 : * DistributesOver\u02b3 +\n  distrib\u02b3 = proj\u2082 distrib\n\n  zero\u02e1 : LeftZero 0# *\n  zero\u02e1 = proj\u2081 zero\n\n  zero\u02b3 : RightZero 0# *\n  zero\u02b3 = proj\u2082 zero\n\n  identity\u02e1 : LeftIdentity 1# *\n  identity\u02e1 = proj\u2081 *-identity\n\n  identity\u02b3 : RightIdentity 1# *\n  identity\u02b3 = proj\u2082 *-identity\n\n  *-isMagma : IsMagma *\n  *-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = *-cong\n    }\n\n  *-isSemigroup : IsSemigroup *\n  *-isSemigroup = record\n    { isMagma = *-isMagma\n    ; assoc   = *-assoc\n    }\n\n  *-isMonoid : IsMonoid * 1#\n  *-isMonoid = record\n    { isSemigroup = *-isSemigroup\n    ; identity    = *-identity\n    }\n\n  open IsMonoid *-isMonoid public\n    using ()\n    renaming\n    ( \u2219-cong\u02e1     to *-cong\u02e1\n    ; \u2219-cong\u02b3     to *-cong\u02b3\n    ; identity\u02e1   to *-identity\u02e1\n    ; identity\u02b3   to *-identity\u02b3\n    )\n\n------------------------------------------------------------------------\n-- Structures with 2 binary operations, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord IsRingWithoutOne (+ * : Op\u2082 A) (-_ : Op\u2081 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isAbelianGroup : IsAbelianGroup + 0# -_\n    *-cong           : Congruent\u2082 *\n    *-assoc          : Associative *\n    distrib          : * DistributesOver +\n\n  open IsAbelianGroup +-isAbelianGroup public\n    renaming\n    ( assoc                   to +-assoc\n    ; \u2219-cong                  to +-cong\n    ; \u2219-cong\u02e1                 to +-cong\u02e1\n    ; \u2219-cong\u02b3                 to +-cong\u02b3\n    ; identity                to +-identity\n    ; identity\u02e1               to +-identity\u02e1\n    ; identity\u02b3               to +-identity\u02b3\n    ; inverse                 to -\u203finverse\n    ; inverse\u02e1                to -\u203finverse\u02e1\n    ; inverse\u02b3                to -\u203finverse\u02b3\n    ; \u207b\u00b9-cong                 to -\u203fcong\n    ; comm                    to +-comm\n    ; isMagma                 to +-isMagma\n    ; isSemigroup             to +-isSemigroup\n    ; isMonoid                to +-isMonoid\n    ; isUnitalMagma           to +-isUnitalMagma\n    ; isCommutativeMagma      to +-isCommutativeMagma\n    ; isCommutativeMonoid     to +-isCommutativeMonoid\n    ; isCommutativeSemigroup  to +-isCommutativeSemigroup\n    ; isInvertibleMagma       to +-isInvertibleMagma\n    ; isInvertibleUnitalMagma to +-isInvertibleUnitalMagma\n    ; isGroup                 to +-isGroup\n    )\n\n  distrib\u02e1 : * DistributesOver\u02e1 +\n  distrib\u02e1 = proj\u2081 distrib\n\n  distrib\u02b3 : * DistributesOver\u02b3 +\n  distrib\u02b3 = proj\u2082 distrib\n\n  zero\u02e1 : LeftZero 0# *\n  zero\u02e1 = Consequences.assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 setoid\n    +-cong *-cong +-assoc distrib\u02b3 +-identity\u02b3 -\u203finverse\u02b3\n\n  zero\u02b3 : RightZero 0# *\n  zero\u02b3 = Consequences.assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 setoid\n    +-cong *-cong +-assoc distrib\u02e1 +-identity\u02b3 -\u203finverse\u02b3\n\n  zero : Zero 0# *\n  zero = zero\u02e1 , zero\u02b3\n\n  isNearSemiring : IsNearSemiring + * 0#\n  isNearSemiring = record\n    { +-isMonoid = +-isMonoid\n    ; *-cong = *-cong\n    ; *-assoc = *-assoc\n    ; distrib\u02b3 = distrib\u02b3\n    ; zero\u02e1 = zero\u02e1\n    }\n\n  open IsNearSemiring isNearSemiring public\n    using (*-isMagma; *-isSemigroup; *-cong\u02e1; *-cong\u02b3)\n\n------------------------------------------------------------------------\n-- Structures with 2 binary operations, 1 unary operation &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord IsNonAssociativeRing (+ * : Op\u2082 A) (-_ : Op\u2081 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isAbelianGroup : IsAbelianGroup + 0# -_\n    *-cong           : Congruent\u2082 *\n    *-identity       : Identity 1# *\n    distrib          : * DistributesOver +\n    zero             : Zero 0# *\n\n  open IsAbelianGroup +-isAbelianGroup public\n    renaming\n    ( assoc                   to +-assoc\n    ; \u2219-cong                  to +-cong\n    ; \u2219-cong\u02e1                 to +-cong\u02e1\n    ; \u2219-cong\u02b3                 to +-cong\u02b3\n    ; identity                to +-identity\n    ; identity\u02e1               to +-identity\u02e1\n    ; identity\u02b3               to +-identity\u02b3\n    ; inverse                 to -\u203finverse\n    ; inverse\u02e1                to -\u203finverse\u02e1\n    ; inverse\u02b3                to -\u203finverse\u02b3\n    ; \u207b\u00b9-cong                 to -\u203fcong\n    ; comm                    to +-comm\n    ; isMagma                 to +-isMagma\n    ; isSemigroup             to +-isSemigroup\n    ; isMonoid                to +-isMonoid\n    ; isUnitalMagma           to +-isUnitalMagma\n    ; isCommutativeMagma      to +-isCommutativeMagma\n    ; isCommutativeMonoid     to +-isCommutativeMonoid\n    ; isCommutativeSemigroup  to +-isCommutativeSemigroup\n    ; isInvertibleMagma       to +-isInvertibleMagma\n    ; isInvertibleUnitalMagma to +-isInvertibleUnitalMagma\n    ; isGroup                 to +-isGroup\n    )\n\n  zero\u02e1 : LeftZero 0# *\n  zero\u02e1 = proj\u2081 zero\n\n  zero\u02b3 : RightZero 0# *\n  zero\u02b3 = proj\u2082 zero\n\n  distrib\u02e1 : * DistributesOver\u02e1 +\n  distrib\u02e1 = proj\u2081 distrib\n\n  distrib\u02b3 : * DistributesOver\u02b3 +\n  distrib\u02b3 = proj\u2082 distrib\n\n  *-isMagma : IsMagma *\n  *-isMagma = record\n    { isEquivalence = isEquivalence\n    ; \u2219-cong        = *-cong\n    }\n\n  *-identity\u02e1 : LeftIdentity 1# *\n  *-identity\u02e1 = proj\u2081 *-identity\n\n  *-identity\u02b3 : RightIdentity 1# *\n  *-identity\u02b3 = proj\u2082 *-identity\n\n  *-isUnitalMagma : IsUnitalMagma * 1#\n  *-isUnitalMagma = record\n    { isMagma = *-isMagma\n    ; identity = *-identity\n    }\n\n  open IsUnitalMagma *-isUnitalMagma public\n    using ()\n    renaming\n    ( \u2219-cong\u02e1   to *-cong\u02e1\n    ; \u2219-cong\u02b3   to *-cong\u02b3\n    )\n\nrecord IsNearring (+ * : Op\u2082 A) (0# 1# : A) (_\u207b\u00b9 : Op\u2081 A) : Set (a \u2294 \u2113) where\n  field\n    isQuasiring : IsQuasiring + * 0# 1#\n    +-inverse   : Inverse 0# _\u207b\u00b9 +\n    \u207b\u00b9-cong     : Congruent\u2081 _\u207b\u00b9\n\n  open IsQuasiring isQuasiring public\n\n  +-inverse\u02e1 : LeftInverse 0# _\u207b\u00b9 +\n  +-inverse\u02e1 = proj\u2081 +-inverse\n\n  +-inverse\u02b3 : RightInverse 0# _\u207b\u00b9 +\n  +-inverse\u02b3 = proj\u2082 +-inverse\n\nrecord IsRing (+ * : Op\u2082 A) (-_ : Op\u2081 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isAbelianGroup : IsAbelianGroup + 0# -_\n    *-cong           : Congruent\u2082 *\n    *-assoc          : Associative *\n    *-identity       : Identity 1# *\n    distrib          : * DistributesOver +\n\n  isRingWithoutOne : IsRingWithoutOne + * -_ 0#\n  isRingWithoutOne = record\n    { +-isAbelianGroup = +-isAbelianGroup\n    ; *-cong  = *-cong\n    ; *-assoc = *-assoc\n    ; distrib = distrib\n    }\n\n  open IsRingWithoutOne isRingWithoutOne public\n    hiding (+-isAbelianGroup; *-cong; *-assoc; distrib)\n\n  *-isMonoid : IsMonoid * 1#\n  *-isMonoid = record\n    { isSemigroup = *-isSemigroup\n    ; identity    = *-identity\n    }\n\n  open IsMonoid *-isMonoid public\n    using ()\n    renaming\n    ( identity\u02e1   to *-identity\u02e1\n    ; identity\u02b3   to *-identity\u02b3\n    )\n\n  isSemiringWithoutAnnihilatingZero\n    : IsSemiringWithoutAnnihilatingZero + * 0# 1#\n  isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = +-isCommutativeMonoid\n    ; *-cong                = *-cong\n    ; *-assoc               = *-assoc\n    ; *-identity            = *-identity\n    ; distrib               = distrib\n    }\n\n  isSemiring : IsSemiring + * 0# 1#\n  isSemiring = record\n    { isSemiringWithoutAnnihilatingZero =\n        isSemiringWithoutAnnihilatingZero\n    ; zero = zero\n    }\n\n  open IsSemiring isSemiring public\n    using (isSemiringWithoutOne)\n\n\nrecord IsCommutativeRing\n         (+ * : Op\u2082 A) (- : Op\u2081 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    isRing : IsRing + * - 0# 1#\n    *-comm : Commutative *\n\n  open IsRing isRing public\n\n  isCommutativeSemiring : IsCommutativeSemiring + * 0# 1#\n  isCommutativeSemiring = record\n    { isSemiring = isSemiring\n    ; *-comm = *-comm\n    }\n\n  open IsCommutativeSemiring isCommutativeSemiring public\n    using\n    ( isCommutativeSemiringWithoutOne\n    ; *-isCommutativeMagma\n    ; *-isCommutativeSemigroup\n    ; *-isCommutativeMonoid\n    )\n\n------------------------------------------------------------------------\n-- Structures with 3 binary operations\n------------------------------------------------------------------------\n\nrecord IsQuasigroup (\u2219 \\\\ // : Op\u2082 A) : Set (a \u2294 \u2113) where\n  field\n    isMagma       : IsMagma \u2219\n    \\\\-cong       : Congruent\u2082 \\\\\n    //-cong       : Congruent\u2082 //\n    leftDivides   : LeftDivides \u2219 \\\\\n    rightDivides  : RightDivides \u2219 //\n\n  open IsMagma isMagma public\n\n  \\\\-cong\u02e1 : LeftCongruent \\\\\n  \\\\-cong\u02e1 y\u2248z = \\\\-cong refl y\u2248z\n\n  \\\\-cong\u02b3 : RightCongruent \\\\\n  \\\\-cong\u02b3 y\u2248z = \\\\-cong y\u2248z refl\n\n  //-cong\u02e1 : LeftCongruent //\n  //-cong\u02e1 y\u2248z = //-cong refl y\u2248z\n\n  //-cong\u02b3 : RightCongruent //\n  //-cong\u02b3 y\u2248z = //-cong y\u2248z refl\n\n  leftDivides\u02e1 : LeftDivides\u02e1 \u2219 \\\\\n  leftDivides\u02e1 = proj\u2081 leftDivides\n\n  leftDivides\u02b3 : LeftDivides\u02b3 \u2219 \\\\\n  leftDivides\u02b3 = proj\u2082 leftDivides\n\n  rightDivides\u02e1 : RightDivides\u02e1 \u2219 //\n  rightDivides\u02e1 = proj\u2081 rightDivides\n\n  rightDivides\u02b3 : RightDivides\u02b3 \u2219 //\n  rightDivides\u02b3 = proj\u2082 rightDivides\n\n\nrecord IsLoop (\u2219 \\\\ // : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isQuasigroup : IsQuasigroup \u2219 \\\\ //\n    identity     : Identity \u03b5 \u2219\n\n  open IsQuasigroup isQuasigroup public\n\n  identity\u02e1 : LeftIdentity \u03b5 \u2219\n  identity\u02e1 = proj\u2081 identity\n\n  identity\u02b3 : RightIdentity \u03b5 \u2219\n  identity\u02b3 = proj\u2082 identity\n\nrecord IsLeftBolLoop (\u2219 \\\\ // : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isLoop  : IsLoop \u2219 \\\\ //  \u03b5\n    leftBol : LeftBol \u2219\n\n  open IsLoop isLoop public\n\nrecord IsRightBolLoop (\u2219 \\\\ // : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isLoop   : IsLoop \u2219 \\\\ //  \u03b5\n    rightBol : RightBol \u2219\n\n  open IsLoop isLoop public\n\nrecord IsMoufangLoop (\u2219 \\\\ // : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isLeftBolLoop  : IsLeftBolLoop \u2219 \\\\ //  \u03b5\n    rightBol       : RightBol \u2219\n    identical      : Identical \u2219\n\n  open IsLeftBolLoop isLeftBolLoop public\n\nrecord IsMiddleBolLoop (\u2219 \\\\ // : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isLoop    : IsLoop \u2219 \\\\ //  \u03b5\n    middleBol : MiddleBol \u2219 \\\\ //\n\n  open IsLoop isLoop public\n</pre>"},{"location":"md/Algebra/Structures/Biased/","title":"Algebra.Structures.Biased","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Ways to give instances of certain structures where some fields can\n-- be given in terms of others. Re-exported via `Algebra`.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Core\nopen import Algebra.Consequences.Setoid\nopen import Data.Product.Base using (_,_; proj\u2081; proj\u2082)\nopen import Level using (_\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Algebra.Structures.Biased\n  {a \u2113} {A : Set a}  -- The underlying set\n  (_\u2248_ : Rel A \u2113)    -- The underlying equality relation\n  where\n\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Structures  _\u2248_\n\n------------------------------------------------------------------------\n-- IsCommutativeMonoid\n\nrecord IsCommutativeMonoid\u02e1 (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isSemigroup : IsSemigroup \u2219\n    identity\u02e1   : LeftIdentity \u03b5 \u2219\n    comm        : Commutative \u2219\n\n  isCommutativeMonoid : IsCommutativeMonoid \u2219 \u03b5\n  isCommutativeMonoid = record\n    { isMonoid = record\n      { isSemigroup = isSemigroup\n      ; identity    = comm\u2227id\u02e1\u21d2id setoid comm identity\u02e1\n      }\n    ; comm = comm\n    } where open IsSemigroup isSemigroup\n\nopen IsCommutativeMonoid\u02e1 public\n  using () renaming (isCommutativeMonoid to isCommutativeMonoid\u02e1)\n\n\nrecord IsCommutativeMonoid\u02b3 (\u2219 : Op\u2082 A) (\u03b5 : A) : Set (a \u2294 \u2113) where\n  field\n    isSemigroup : IsSemigroup \u2219\n    identity\u02b3   : RightIdentity \u03b5 \u2219\n    comm        : Commutative \u2219\n\n  isCommutativeMonoid : IsCommutativeMonoid \u2219 \u03b5\n  isCommutativeMonoid = record\n    { isMonoid = record\n      { isSemigroup = isSemigroup\n      ; identity    = comm\u2227id\u02b3\u21d2id setoid comm identity\u02b3\n      }\n    ; comm = comm\n    } where open IsSemigroup isSemigroup\n\nopen IsCommutativeMonoid\u02b3 public\n  using () renaming (isCommutativeMonoid to isCommutativeMonoid\u02b3)\n\n------------------------------------------------------------------------\n-- IsSemiringWithoutOne\n\nrecord IsSemiringWithoutOne* (+ * : Op\u2082 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-isSemigroup         : IsSemigroup *\n    distrib               : * DistributesOver +\n    zero                  : Zero 0# *\n\n  isSemiringWithoutOne : IsSemiringWithoutOne + * 0#\n  isSemiringWithoutOne = record\n    { +-isCommutativeMonoid = +-isCommutativeMonoid\n    ; *-cong = \u2219-cong\n    ; *-assoc = assoc\n    ; distrib = distrib\n    ; zero = zero\n    } where open IsSemigroup *-isSemigroup\n\nopen IsSemiringWithoutOne* public\n  using () renaming (isSemiringWithoutOne to isSemiringWithoutOne*)\n\n------------------------------------------------------------------------\n-- IsNearSemiring\n\nrecord IsNearSemiring* (+ * : Op\u2082 A) (0# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isMonoid    : IsMonoid + 0#\n    *-isSemigroup : IsSemigroup *\n    distrib\u02b3      : * DistributesOver\u02b3 +\n    zero\u02e1         : LeftZero 0# *\n\n  isNearSemiring : IsNearSemiring + * 0#\n  isNearSemiring = record\n    { +-isMonoid = +-isMonoid\n    ; *-cong = \u2219-cong\n    ; *-assoc = assoc\n    ; distrib\u02b3 = distrib\u02b3\n    ; zero\u02e1 = zero\u02e1\n    } where open IsSemigroup *-isSemigroup\n\nopen IsNearSemiring* public\n  using () renaming (isNearSemiring to isNearSemiring*)\n\n------------------------------------------------------------------------\n-- IsSemiringWithoutAnnihilatingZero\n\nrecord IsSemiringWithoutAnnihilatingZero* (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-isMonoid            : IsMonoid * 1#\n    distrib               : * DistributesOver +\n\n  isSemiringWithoutAnnihilatingZero : IsSemiringWithoutAnnihilatingZero + * 0# 1#\n  isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = +-isCommutativeMonoid\n    ; *-cong = \u2219-cong\n    ; *-assoc = assoc\n    ; *-identity = identity\n    ; distrib = distrib\n    } where open IsMonoid *-isMonoid\n\nopen IsSemiringWithoutAnnihilatingZero* public\n  using () renaming (isSemiringWithoutAnnihilatingZero to isSemiringWithoutAnnihilatingZero*)\n\n------------------------------------------------------------------------\n-- IsCommutativeSemiring\n\nrecord IsCommutativeSemiring\u02e1 (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-isCommutativeMonoid : IsCommutativeMonoid * 1#\n    distrib\u02b3              : * DistributesOver\u02b3 +\n    zero\u02e1                 : LeftZero 0# *\n\n  isCommutativeSemiring : IsCommutativeSemiring + * 0# 1#\n  isCommutativeSemiring = record\n    { isSemiring = record\n      { isSemiringWithoutAnnihilatingZero = record\n        { +-isCommutativeMonoid = +-isCommutativeMonoid\n        ; *-cong                = *.\u2219-cong\n        ; *-assoc               = *.assoc\n        ; *-identity            = *.identity\n        ; distrib               = comm\u2227distr\u02b3\u21d2distr +.setoid +.\u2219-cong *.comm distrib\u02b3\n        }\n      ; zero = comm\u2227ze\u02e1\u21d2ze +.setoid *.comm zero\u02e1\n      }\n    ; *-comm = *.comm\n    }\n    where\n    module + = IsCommutativeMonoid +-isCommutativeMonoid\n    module * = IsCommutativeMonoid *-isCommutativeMonoid\n\nopen IsCommutativeSemiring\u02e1 public\n  using () renaming (isCommutativeSemiring to isCommutativeSemiring\u02e1)\n\n\nrecord IsCommutativeSemiring\u02b3 (+ * : Op\u2082 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isCommutativeMonoid : IsCommutativeMonoid + 0#\n    *-isCommutativeMonoid : IsCommutativeMonoid * 1#\n    distrib\u02e1              : * DistributesOver\u02e1 +\n    zero\u02b3                 : RightZero 0# *\n\n  isCommutativeSemiring : IsCommutativeSemiring + * 0# 1#\n  isCommutativeSemiring = record\n    { isSemiring = record\n      { isSemiringWithoutAnnihilatingZero = record\n        { +-isCommutativeMonoid = +-isCommutativeMonoid\n        ; *-cong                = *.\u2219-cong\n        ; *-assoc               = *.assoc\n        ; *-identity            = *.identity\n        ; distrib               = comm\u2227distr\u02e1\u21d2distr +.setoid +.\u2219-cong *.comm distrib\u02e1\n        }\n      ; zero = comm\u2227ze\u02b3\u21d2ze +.setoid *.comm zero\u02b3\n      }\n    ; *-comm = *.comm\n    }\n    where\n    module + = IsCommutativeMonoid +-isCommutativeMonoid\n    module * = IsCommutativeMonoid *-isCommutativeMonoid\n\nopen IsCommutativeSemiring\u02b3 public\n  using () renaming (isCommutativeSemiring to isCommutativeSemiring\u02b3)\n\n\n------------------------------------------------------------------------\n-- IsRing\n\nrecord IsRing* (+ * : Op\u2082 A) (-_ : Op\u2081 A) (0# 1# : A) : Set (a \u2294 \u2113) where\n  field\n    +-isAbelianGroup : IsAbelianGroup + 0# -_\n    *-isMonoid       : IsMonoid * 1#\n    distrib          : * DistributesOver +\n    zero             : Zero 0# *\n\n  isRing : IsRing + * -_ 0# 1#\n  isRing = record\n    { +-isAbelianGroup = +-isAbelianGroup\n    ; *-cong = \u2219-cong\n    ; *-assoc = assoc\n    ; *-identity = identity\n    ; distrib = distrib\n    } where open IsMonoid *-isMonoid\n\nopen IsRing* public\n  using () renaming (isRing to isRing*)\n\n\n\n------------------------------------------------------------------------\n-- Deprecated\n------------------------------------------------------------------------\n\n-- Version 2.0\n\n-- We can recover a ring without proving that 0# annihilates *.\nrecord IsRingWithoutAnnihilatingZero (+ * : Op\u2082 A) (-_ : Op\u2081 A) (0# 1# : A)\n                                     : Set (a \u2294 \u2113) where\n  field\n    +-isAbelianGroup : IsAbelianGroup + 0# -_\n    *-isMonoid       : IsMonoid * 1#\n    distrib          : * DistributesOver +\n\n  module + = IsAbelianGroup +-isAbelianGroup\n  module * = IsMonoid *-isMonoid\n\n  open + using (setoid) renaming (\u2219-cong to +-cong)\n  open * using ()       renaming (\u2219-cong to *-cong)\n\n  zero\u02e1 : LeftZero 0# *\n  zero\u02e1 = assoc\u2227distrib\u02b3\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02e1 setoid\n            +-cong *-cong +.assoc (proj\u2082 distrib) +.identity\u02b3 +.inverse\u02b3\n\n  zero\u02b3 : RightZero 0# *\n  zero\u02b3 = assoc\u2227distrib\u02e1\u2227id\u02b3\u2227inv\u02b3\u21d2ze\u02b3 setoid\n            +-cong *-cong +.assoc (proj\u2081 distrib) +.identity\u02b3 +.inverse\u02b3\n\n  zero : Zero 0# *\n  zero = (zero\u02e1 , zero\u02b3)\n\n  isRing : IsRing + * -_ 0# 1#\n  isRing = record\n    { +-isAbelianGroup = +-isAbelianGroup\n    ; *-cong           = *.\u2219-cong\n    ; *-assoc          = *.assoc\n    ; *-identity       = *.identity\n    ; distrib          = distrib\n    }\n\nopen IsRingWithoutAnnihilatingZero public\n  using () renaming (isRing to isRingWithoutAnnihilatingZero)\n\n{-# WARNING_ON_USAGE IsRingWithoutAnnihilatingZero\n\"Warning: IsRingWithoutAnnihilatingZero was deprecated in v2.0.\nPlease use the standard `IsRing` instead.\"\n#-}\n{-# WARNING_ON_USAGE isRingWithoutAnnihilatingZero\n\"Warning: isRingWithoutAnnihilatingZero was deprecated in v2.0.\nPlease use the standard `isRing` instead.\"\n#-}\n\n-- Version 2.1\n\n-- issue #2253\n{-# WARNING_ON_USAGE IsRing*\n\"Warning: IsRing* was deprecated in v2.1.\nPlease use the standard `IsRing` instead.\"\n#-}\n{-# WARNING_ON_USAGE isRing*\n\"Warning: isRing* was deprecated in v2.1.\nPlease use the standard `isRing` instead.\"\n#-}\n</pre>"},{"location":"md/Axiom/UniquenessOfIdentityProofs/","title":"Axiom.UniquenessOfIdentityProofs","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Results concerning uniqueness of identity proofs\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Axiom.UniquenessOfIdentityProofs where\n\nopen import Level using (Level)\nopen import Relation.Nullary.Decidable.Core\n  using (recompute; recompute-constant)\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\nopen import Relation.Binary.Definitions\n  using (Sym; Irrelevant; DecidableEquality)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; trans; sym; cong)\nopen import Relation.Binary.PropositionalEquality.Properties\n\nprivate\n  variable\n    a : Level\n    A : Set a\n    x y : A\n\n------------------------------------------------------------------------\n-- Definition\n--\n-- Uniqueness of Identity Proofs (UIP) states that all proofs of\n-- equality are themselves equal. In other words, the equality relation\n-- is irrelevant. Here we define UIP relative to a given type.\n\nUIP : (A : Set a) \u2192 Set a\nUIP A = Irrelevant {A = A} _\u2261_\n\n------------------------------------------------------------------------\n-- Properties\n\n-- UIP always holds when using axiom K\n-- (see `Axiom.UniquenessOfIdentityProofs.WithK`).\n\n-- The existence of a constant function over proofs of equality for\n-- elements in A is enough to prove UIP for A. Indeed, we can relate any\n-- proof to its image via this function which we then know is equal to\n-- the image of any other proof.\n\nmodule Constant\u21d2UIP\n  (f : _\u2261_ {A = A} \u21d2 _\u2261_)\n  (f-constant : \u2200 {x y} (p q : x \u2261 y) \u2192 f p \u2261 f q)\n  where\n\n  \u2261-canonical : (p : x \u2261 y) \u2192 trans (sym (f refl)) (f p) \u2261 p\n  \u2261-canonical refl = trans-sym\u02e1 (f refl)\n\n  \u2261-irrelevant : UIP A\n  \u2261-irrelevant p q = begin\n    p                          \u2261\u27e8 sym (\u2261-canonical p) \u27e9\n    trans (sym (f refl)) (f p) \u2261\u27e8 cong (trans _) (f-constant p q) \u27e9\n    trans (sym (f refl)) (f q) \u2261\u27e8 \u2261-canonical q \u27e9\n    q                          \u220e\n    where open \u2261-Reasoning\n\n-- If equality is decidable for a given type, then we can prove UIP for\n-- that type. Indeed, the decision procedure allows us to define a\n-- function over proofs of equality which is constant: it returns the\n-- proof produced by the decision procedure.\n\nmodule Decidable\u21d2UIP (_\u225f_ : DecidableEquality A)\n  where\n\n  \u2261-normalise : _\u2261_ {A = A} \u21d2 _\u2261_\n  \u2261-normalise {x} {y} x\u2261y = recompute (x \u225f y) x\u2261y\n\n  \u2261-normalise-constant : (p q : x \u2261 y) \u2192 \u2261-normalise p \u2261 \u2261-normalise q\n  \u2261-normalise-constant {x = x} {y = y} = recompute-constant (x \u225f y)\n\n  \u2261-irrelevant : UIP A\n  \u2261-irrelevant = Constant\u21d2UIP.\u2261-irrelevant \u2261-normalise \u2261-normalise-constant\n</pre>"},{"location":"md/Data/Bool/","title":"Data.Bool","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Booleans\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Bool where\n\n------------------------------------------------------------------------\n-- The boolean type and some operations\n\nopen import Data.Bool.Base public\n\n------------------------------------------------------------------------\n-- Publicly re-export queries\n\nopen import Data.Bool.Properties public\n  using (T?; _\u225f_; _\u2264?_; _&lt;?_)\n</pre>"},{"location":"md/Data/Bool/Base/","title":"Data.Bool.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The type for booleans and some operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Bool.Base where\n\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.Empty using (\u22a5)\nopen import Level using (Level)\n\nprivate\n  variable\n    a : Level\n    A : Set a\n\n------------------------------------------------------------------------\n-- The boolean type\n\nopen import Agda.Builtin.Bool public\n\n------------------------------------------------------------------------\n-- Relations\n\ninfix 4 _\u2264_ _&lt;_\n\ndata _\u2264_ : Bool \u2192 Bool \u2192 Set where\n  f\u2264t : false \u2264 true\n  b\u2264b : \u2200 {b} \u2192 b \u2264 b\n\ndata _&lt;_ : Bool \u2192 Bool \u2192 Set where\n  f&lt;t : false &lt; true\n\n------------------------------------------------------------------------\n-- Boolean operations\n\ninfixr 6 _\u2227_\ninfixr 5 _\u2228_ _xor_\n\nnot : Bool \u2192 Bool\nnot true  = false\nnot false = true\n\n_\u2227_ : Bool \u2192 Bool \u2192 Bool\ntrue  \u2227 b = b\nfalse \u2227 b = false\n\n_\u2228_ : Bool \u2192 Bool \u2192 Bool\ntrue  \u2228 b = true\nfalse \u2228 b = b\n\n_xor_ : Bool \u2192 Bool \u2192 Bool\ntrue  xor b = not b\nfalse xor b = b\n\n------------------------------------------------------------------------\n-- Conversion to Set\n\n-- A function mapping true to an inhabited type and false to an empty\n-- type.\nT : Bool \u2192 Set\nT true  = \u22a4\nT false = \u22a5\n\n------------------------------------------------------------------------\n-- Other operations\n\ninfix 0 if_then_else_\n\nif_then_else_ : Bool \u2192 A \u2192 A \u2192 A\nif true  then t else f = t\nif false then t else f = f\n</pre>"},{"location":"md/Data/Bool/Properties/","title":"Data.Bool.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- A bunch of properties\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Bool.Properties where\nopen import Algebra.Bundles\n  using (Magma; Semigroup; Band; CommutativeMonoid\n        ; IdempotentCommutativeMonoid; CommutativeSemiring; CommutativeRing)\nopen import Algebra.Lattice.Bundles\n  using (Lattice; DistributiveLattice; BooleanAlgebra; Semilattice)\nimport Algebra.Lattice.Properties.BooleanAlgebra as BooleanAlgebraProperties\nopen import Data.Bool.Base\n  using (Bool; true; false; not; _\u2227_; _\u2228_; _xor_ ; if_then_else_; T; _\u2264_; _&lt;_\n        ; b\u2264b; f\u2264t; f&lt;t)\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.Sum.Base using (_\u228e_; inj\u2081; inj\u2082; [_,_])\nopen import Function.Base using (_\u27e8_\u27e9_; const; id)\nopen import Function.Bundles hiding (Inverse; LeftInverse; RightInverse)\nopen import Induction.WellFounded using (Acc; WellFounded; acc)\nopen import Level using (0\u2113; Level)\nopen import Relation.Binary.Bundles using (DecSetoid; DecTotalOrder; Poset;\n  Preorder; Setoid; StrictPartialOrder; StrictTotalOrder; TotalOrder)\nopen import Relation.Binary.Core using (_\u21d2_)\nopen import Relation.Binary.Structures\n  using (IsPreorder; IsPartialOrder; IsTotalOrder; IsDecTotalOrder\n        ; IsStrictPartialOrder; IsStrictTotalOrder)\nopen import Relation.Binary.Bundles\n  using (Setoid; DecSetoid; Poset; Preorder; TotalOrder; DecTotalOrder\n        ; StrictPartialOrder; StrictTotalOrder)\nopen import Relation.Binary.Definitions\n  using (Decidable; DecidableEquality ; Reflexive; Transitive; Antisymmetric\n        ; Minimum; Maximum; Total; Irrelevant ; Irreflexive; Asymmetric; Trans\n        ; Trichotomous; tri\u2248; tri&lt;; tri&gt;; _Respects\u2082_)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; sym; cong; cong\u2082; subst; trans; _\u2262_)\nopen import Relation.Binary.PropositionalEquality.Properties\n  using (module \u2261-Reasoning; setoid; decSetoid; isEquivalence)\nopen import Relation.Nullary.Decidable.Core\n  using (True; yes; no; fromWitness ; toWitness)\nopen import Relation.Nullary.Negation.Core using (contradiction)\nimport Relation.Unary as U\n\nopen import Algebra.Definitions {A = Bool} _\u2261_\nopen import Algebra.Structures {A = Bool} _\u2261_\nopen import Algebra.Lattice.Structures {A = Bool} _\u2261_\n\nopen \u2261-Reasoning\n\nprivate\n  variable\n    a b : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Properties of _\u2261_\n\ninfix 4 _\u225f_\n\n_\u225f_ : DecidableEquality Bool\ntrue  \u225f true  = yes refl\nfalse \u225f false = yes refl\ntrue  \u225f false = no \u03bb()\nfalse \u225f true  = no \u03bb()\n\n\u2261-setoid : Setoid 0\u2113 0\u2113\n\u2261-setoid = setoid Bool\n\n\u2261-decSetoid : DecSetoid 0\u2113 0\u2113\n\u2261-decSetoid = decSetoid _\u225f_\n\n------------------------------------------------------------------------\n-- Properties of _\u2264_\n\n-- Relational properties\n\n\u2264-reflexive : _\u2261_ \u21d2 _\u2264_\n\u2264-reflexive refl = b\u2264b\n\n\u2264-refl : Reflexive _\u2264_\n\u2264-refl = \u2264-reflexive refl\n\n\u2264-trans : Transitive _\u2264_\n\u2264-trans b\u2264b p   = p\n\u2264-trans f\u2264t b\u2264b = f\u2264t\n\n\u2264-antisym : Antisymmetric _\u2261_ _\u2264_\n\u2264-antisym b\u2264b _ = refl\n\n\u2264-minimum : Minimum _\u2264_ false\n\u2264-minimum false = b\u2264b\n\u2264-minimum true  = f\u2264t\n\n\u2264-maximum : Maximum _\u2264_ true\n\u2264-maximum false = f\u2264t\n\u2264-maximum true  = b\u2264b\n\n\u2264-total : Total _\u2264_\n\u2264-total false b = inj\u2081 (\u2264-minimum b)\n\u2264-total true  b = inj\u2082 (\u2264-maximum b)\n\ninfix 4 _\u2264?_\n\n_\u2264?_ : Decidable _\u2264_\nfalse \u2264? b     = yes (\u2264-minimum b)\ntrue  \u2264? false = no \u03bb ()\ntrue  \u2264? true  = yes b\u2264b\n\n\u2264-irrelevant : Irrelevant _\u2264_\n\u2264-irrelevant {_}     f\u2264t f\u2264t = refl\n\u2264-irrelevant {false} b\u2264b b\u2264b = refl\n\u2264-irrelevant {true}  b\u2264b b\u2264b = refl\n\n-- Structures\n\n\u2264-isPreorder : IsPreorder _\u2261_ _\u2264_\n\u2264-isPreorder = record\n  { isEquivalence = isEquivalence\n  ; reflexive     = \u2264-reflexive\n  ; trans         = \u2264-trans\n  }\n\n\u2264-isPartialOrder : IsPartialOrder _\u2261_ _\u2264_\n\u2264-isPartialOrder = record\n  { isPreorder = \u2264-isPreorder\n  ; antisym    = \u2264-antisym\n  }\n\n\u2264-isTotalOrder : IsTotalOrder _\u2261_ _\u2264_\n\u2264-isTotalOrder = record\n  { isPartialOrder = \u2264-isPartialOrder\n  ; total          = \u2264-total\n  }\n\n\u2264-isDecTotalOrder : IsDecTotalOrder _\u2261_ _\u2264_\n\u2264-isDecTotalOrder = record\n  { isTotalOrder = \u2264-isTotalOrder\n  ; _\u225f_          = _\u225f_\n  ; _\u2264?_         = _\u2264?_\n  }\n\n-- Bundles\n\n\u2264-poset : Poset 0\u2113 0\u2113 0\u2113\n\u2264-poset = record\n  { isPartialOrder = \u2264-isPartialOrder\n  }\n\n\u2264-preorder : Preorder 0\u2113 0\u2113 0\u2113\n\u2264-preorder = record\n  { isPreorder = \u2264-isPreorder\n  }\n\n\u2264-totalOrder : TotalOrder 0\u2113 0\u2113 0\u2113\n\u2264-totalOrder = record\n  { isTotalOrder = \u2264-isTotalOrder\n  }\n\n\u2264-decTotalOrder : DecTotalOrder 0\u2113 0\u2113 0\u2113\n\u2264-decTotalOrder = record\n  { isDecTotalOrder = \u2264-isDecTotalOrder\n  }\n\n------------------------------------------------------------------------\n-- Properties of _&lt;_\n\n-- Relational properties\n\n&lt;-irrefl : Irreflexive _\u2261_ _&lt;_\n&lt;-irrefl refl ()\n\n&lt;-asym : Asymmetric _&lt;_\n&lt;-asym f&lt;t ()\n\n&lt;-trans : Transitive _&lt;_\n&lt;-trans f&lt;t ()\n\n&lt;-trans\u02b3 : Trans _\u2264_ _&lt;_ _&lt;_\n&lt;-trans\u02b3 b\u2264b f&lt;t = f&lt;t\n\n&lt;-trans\u02e1 : Trans _&lt;_ _\u2264_ _&lt;_\n&lt;-trans\u02e1 f&lt;t b\u2264b = f&lt;t\n\n&lt;-cmp : Trichotomous _\u2261_ _&lt;_\n&lt;-cmp false false = tri\u2248 (\u03bb()) refl  (\u03bb())\n&lt;-cmp false true  = tri&lt; f&lt;t   (\u03bb()) (\u03bb())\n&lt;-cmp true  false = tri&gt; (\u03bb()) (\u03bb()) f&lt;t\n&lt;-cmp true  true  = tri\u2248 (\u03bb()) refl  (\u03bb())\n\ninfix 4 _&lt;?_\n\n_&lt;?_ : Decidable _&lt;_\nfalse &lt;? false = no  (\u03bb())\nfalse &lt;? true  = yes f&lt;t\ntrue  &lt;? _     = no  (\u03bb())\n\n&lt;-resp\u2082-\u2261 : _&lt;_ Respects\u2082 _\u2261_\n&lt;-resp\u2082-\u2261 = subst (_ &lt;_) , subst (_&lt; _)\n\n&lt;-irrelevant : Irrelevant _&lt;_\n&lt;-irrelevant f&lt;t f&lt;t = refl\n\n&lt;-wellFounded : WellFounded _&lt;_\n&lt;-wellFounded _ = acc &lt;-acc\n  where\n    &lt;-acc : \u2200 {x y} \u2192 y &lt; x \u2192 Acc _&lt;_ y\n    &lt;-acc f&lt;t = acc \u03bb ()\n\n-- Structures\n\n&lt;-isStrictPartialOrder : IsStrictPartialOrder _\u2261_ _&lt;_\n&lt;-isStrictPartialOrder = record\n  { isEquivalence = isEquivalence\n  ; irrefl        = &lt;-irrefl\n  ; trans         = &lt;-trans\n  ; &lt;-resp-\u2248      = &lt;-resp\u2082-\u2261\n  }\n\n&lt;-isStrictTotalOrder : IsStrictTotalOrder _\u2261_ _&lt;_\n&lt;-isStrictTotalOrder = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder\n  ; compare              = &lt;-cmp\n  }\n\n-- Bundles\n\n&lt;-strictPartialOrder : StrictPartialOrder 0\u2113 0\u2113 0\u2113\n&lt;-strictPartialOrder = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder\n  }\n\n&lt;-strictTotalOrder : StrictTotalOrder 0\u2113 0\u2113 0\u2113\n&lt;-strictTotalOrder = record\n  { isStrictTotalOrder = &lt;-isStrictTotalOrder\n  }\n\n------------------------------------------------------------------------\n-- Properties of _\u2228_\n\n\u2228-assoc : Associative _\u2228_\n\u2228-assoc true  y z = refl\n\u2228-assoc false y z = refl\n\n\u2228-comm : Commutative _\u2228_\n\u2228-comm true  true  = refl\n\u2228-comm true  false = refl\n\u2228-comm false true  = refl\n\u2228-comm false false = refl\n\n\u2228-identity\u02e1 : LeftIdentity false _\u2228_\n\u2228-identity\u02e1 _ = refl\n\n\u2228-identity\u02b3 : RightIdentity false _\u2228_\n\u2228-identity\u02b3 false = refl\n\u2228-identity\u02b3 true  = refl\n\n\u2228-identity : Identity false _\u2228_\n\u2228-identity = \u2228-identity\u02e1 , \u2228-identity\u02b3\n\n\u2228-zero\u02e1 : LeftZero true _\u2228_\n\u2228-zero\u02e1 _ = refl\n\n\u2228-zero\u02b3 : RightZero true _\u2228_\n\u2228-zero\u02b3 false = refl\n\u2228-zero\u02b3 true  = refl\n\n\u2228-zero : Zero true _\u2228_\n\u2228-zero = \u2228-zero\u02e1 , \u2228-zero\u02b3\n\n\u2228-inverse\u02e1 : LeftInverse true not _\u2228_\n\u2228-inverse\u02e1 false = refl\n\u2228-inverse\u02e1 true  = refl\n\n\u2228-inverse\u02b3 : RightInverse true not _\u2228_\n\u2228-inverse\u02b3 x = \u2228-comm x (not x) \u27e8 trans \u27e9 \u2228-inverse\u02e1 x\n\n\u2228-inverse : Inverse true not _\u2228_\n\u2228-inverse = \u2228-inverse\u02e1 , \u2228-inverse\u02b3\n\n\u2228-idem : Idempotent _\u2228_\n\u2228-idem false = refl\n\u2228-idem true  = refl\n\n\u2228-sel : Selective _\u2228_\n\u2228-sel false y = inj\u2082 refl\n\u2228-sel true y  = inj\u2081 refl\n\n\u2228-conical\u02e1 : LeftConical false _\u2228_\n\u2228-conical\u02e1 false false _ = refl\n\n\u2228-conical\u02b3 : RightConical false _\u2228_\n\u2228-conical\u02b3 false false _ = refl\n\n\u2228-conical : Conical false _\u2228_\n\u2228-conical = \u2228-conical\u02e1 , \u2228-conical\u02b3\n\n\u2228-isMagma : IsMagma _\u2228_\n\u2228-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = cong\u2082 _\u2228_\n  }\n\n\u2228-magma : Magma 0\u2113 0\u2113\n\u2228-magma = record\n  { isMagma = \u2228-isMagma\n  }\n\n\u2228-isSemigroup : IsSemigroup _\u2228_\n\u2228-isSemigroup = record\n  { isMagma = \u2228-isMagma\n  ; assoc   = \u2228-assoc\n  }\n\n\u2228-semigroup : Semigroup 0\u2113 0\u2113\n\u2228-semigroup = record\n  { isSemigroup = \u2228-isSemigroup\n  }\n\n\u2228-isBand : IsBand _\u2228_\n\u2228-isBand = record\n  { isSemigroup = \u2228-isSemigroup\n  ; idem        = \u2228-idem\n  }\n\n\u2228-band : Band 0\u2113 0\u2113\n\u2228-band = record\n  { isBand = \u2228-isBand\n  }\n\n\u2228-isSemilattice : IsSemilattice _\u2228_\n\u2228-isSemilattice = record\n  { isBand = \u2228-isBand\n  ; comm   = \u2228-comm\n  }\n\n\u2228-semilattice : Semilattice 0\u2113 0\u2113\n\u2228-semilattice = record\n  { isSemilattice = \u2228-isSemilattice\n  }\n\n\u2228-isMonoid : IsMonoid _\u2228_ false\n\u2228-isMonoid = record\n  { isSemigroup = \u2228-isSemigroup\n  ; identity = \u2228-identity\n  }\n\n\u2228-isCommutativeMonoid : IsCommutativeMonoid _\u2228_ false\n\u2228-isCommutativeMonoid = record\n  { isMonoid = \u2228-isMonoid\n  ; comm = \u2228-comm\n  }\n\n\u2228-commutativeMonoid : CommutativeMonoid 0\u2113 0\u2113\n\u2228-commutativeMonoid = record\n  { isCommutativeMonoid = \u2228-isCommutativeMonoid\n  }\n\n\u2228-isIdempotentCommutativeMonoid :\n  IsIdempotentCommutativeMonoid _\u2228_ false\n\u2228-isIdempotentCommutativeMonoid = record\n  { isCommutativeMonoid = \u2228-isCommutativeMonoid\n  ; idem                = \u2228-idem\n  }\n\n\u2228-idempotentCommutativeMonoid : IdempotentCommutativeMonoid 0\u2113 0\u2113\n\u2228-idempotentCommutativeMonoid = record\n  { isIdempotentCommutativeMonoid = \u2228-isIdempotentCommutativeMonoid\n  }\n\n------------------------------------------------------------------------\n-- Properties of _\u2227_\n\n\u2227-assoc : Associative _\u2227_\n\u2227-assoc true  y z = refl\n\u2227-assoc false y z = refl\n\n\u2227-comm : Commutative _\u2227_\n\u2227-comm true  true  = refl\n\u2227-comm true  false = refl\n\u2227-comm false true  = refl\n\u2227-comm false false = refl\n\n\u2227-identity\u02e1 : LeftIdentity true _\u2227_\n\u2227-identity\u02e1 _ = refl\n\n\u2227-identity\u02b3 : RightIdentity true _\u2227_\n\u2227-identity\u02b3 false = refl\n\u2227-identity\u02b3 true  = refl\n\n\u2227-identity : Identity true _\u2227_\n\u2227-identity = \u2227-identity\u02e1 , \u2227-identity\u02b3\n\n\u2227-zero\u02e1 : LeftZero false _\u2227_\n\u2227-zero\u02e1 _ = refl\n\n\u2227-zero\u02b3 : RightZero false _\u2227_\n\u2227-zero\u02b3 false = refl\n\u2227-zero\u02b3 true  = refl\n\n\u2227-zero : Zero false _\u2227_\n\u2227-zero = \u2227-zero\u02e1 , \u2227-zero\u02b3\n\n\u2227-inverse\u02e1 : LeftInverse false not _\u2227_\n\u2227-inverse\u02e1 false = refl\n\u2227-inverse\u02e1 true = refl\n\n\u2227-inverse\u02b3 : RightInverse false not _\u2227_\n\u2227-inverse\u02b3 x = \u2227-comm x (not x) \u27e8 trans \u27e9 \u2227-inverse\u02e1 x\n\n\u2227-inverse : Inverse false not _\u2227_\n\u2227-inverse = \u2227-inverse\u02e1 , \u2227-inverse\u02b3\n\n\u2227-idem : Idempotent _\u2227_\n\u2227-idem false = refl\n\u2227-idem true  = refl\n\n\u2227-sel : Selective _\u2227_\n\u2227-sel false y = inj\u2081 refl\n\u2227-sel true y  = inj\u2082 refl\n\n\u2227-conical\u02e1 : LeftConical true _\u2227_\n\u2227-conical\u02e1 true true _ = refl\n\n\u2227-conical\u02b3 : RightConical true _\u2227_\n\u2227-conical\u02b3 true true _ = refl\n\n\u2227-conical : Conical true _\u2227_\n\u2227-conical = \u2227-conical\u02e1 , \u2227-conical\u02b3\n\n\u2227-distrib\u02e1-\u2228 : _\u2227_ DistributesOver\u02e1 _\u2228_\n\u2227-distrib\u02e1-\u2228 true  y z = refl\n\u2227-distrib\u02e1-\u2228 false y z = refl\n\n\u2227-distrib\u02b3-\u2228 : _\u2227_ DistributesOver\u02b3 _\u2228_\n\u2227-distrib\u02b3-\u2228 x y z = begin\n  (y \u2228 z) \u2227 x     \u2261\u27e8 \u2227-comm (y \u2228 z) x \u27e9\n  x \u2227 (y \u2228 z)     \u2261\u27e8 \u2227-distrib\u02e1-\u2228 x y z \u27e9\n  x \u2227 y \u2228 x \u2227 z   \u2261\u27e8 cong\u2082 _\u2228_ (\u2227-comm x y) (\u2227-comm x z) \u27e9\n  y \u2227 x \u2228 z \u2227 x   \u220e\n\n\u2227-distrib-\u2228 : _\u2227_ DistributesOver _\u2228_\n\u2227-distrib-\u2228 = \u2227-distrib\u02e1-\u2228 , \u2227-distrib\u02b3-\u2228\n\n\u2228-distrib\u02e1-\u2227 : _\u2228_ DistributesOver\u02e1 _\u2227_\n\u2228-distrib\u02e1-\u2227 true  y z = refl\n\u2228-distrib\u02e1-\u2227 false y z = refl\n\n\u2228-distrib\u02b3-\u2227 : _\u2228_ DistributesOver\u02b3 _\u2227_\n\u2228-distrib\u02b3-\u2227 x y z = begin\n  (y \u2227 z) \u2228 x        \u2261\u27e8 \u2228-comm (y \u2227 z) x \u27e9\n  x \u2228 (y \u2227 z)        \u2261\u27e8 \u2228-distrib\u02e1-\u2227 x y z \u27e9\n  (x \u2228 y) \u2227 (x \u2228 z)  \u2261\u27e8 cong\u2082 _\u2227_ (\u2228-comm x y) (\u2228-comm x z) \u27e9\n  (y \u2228 x) \u2227 (z \u2228 x)  \u220e\n\n\u2228-distrib-\u2227 : _\u2228_ DistributesOver _\u2227_\n\u2228-distrib-\u2227 = \u2228-distrib\u02e1-\u2227 , \u2228-distrib\u02b3-\u2227\n\n\u2227-abs-\u2228 : _\u2227_ Absorbs _\u2228_\n\u2227-abs-\u2228 true  y = refl\n\u2227-abs-\u2228 false y = refl\n\n\u2228-abs-\u2227 : _\u2228_ Absorbs _\u2227_\n\u2228-abs-\u2227 true  y = refl\n\u2228-abs-\u2227 false y = refl\n\n\u2228-\u2227-absorptive : Absorptive _\u2228_ _\u2227_\n\u2228-\u2227-absorptive = \u2228-abs-\u2227 , \u2227-abs-\u2228\n\n\u2227-isMagma : IsMagma _\u2227_\n\u2227-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = cong\u2082 _\u2227_\n  }\n\n\u2227-magma : Magma 0\u2113 0\u2113\n\u2227-magma = record\n  { isMagma = \u2227-isMagma\n  }\n\n\u2227-isSemigroup : IsSemigroup _\u2227_\n\u2227-isSemigroup = record\n  { isMagma = \u2227-isMagma\n  ; assoc   = \u2227-assoc\n  }\n\n\u2227-semigroup : Semigroup 0\u2113 0\u2113\n\u2227-semigroup = record\n  { isSemigroup = \u2227-isSemigroup\n  }\n\n\u2227-isBand : IsBand _\u2227_\n\u2227-isBand = record\n  { isSemigroup = \u2227-isSemigroup\n  ; idem        = \u2227-idem\n  }\n\n\u2227-band : Band 0\u2113 0\u2113\n\u2227-band = record\n  { isBand = \u2227-isBand\n  }\n\n\u2227-isSemilattice : IsSemilattice _\u2227_\n\u2227-isSemilattice = record\n  { isBand = \u2227-isBand\n  ; comm   = \u2227-comm\n  }\n\n\u2227-semilattice : Semilattice 0\u2113 0\u2113\n\u2227-semilattice = record\n  { isSemilattice = \u2227-isSemilattice\n  }\n\n\u2227-isMonoid : IsMonoid _\u2227_ true\n\u2227-isMonoid = record\n  { isSemigroup = \u2227-isSemigroup\n  ; identity = \u2227-identity\n  }\n\n\u2227-isCommutativeMonoid : IsCommutativeMonoid _\u2227_ true\n\u2227-isCommutativeMonoid = record\n  { isMonoid = \u2227-isMonoid\n  ; comm = \u2227-comm\n  }\n\n\u2227-commutativeMonoid : CommutativeMonoid 0\u2113 0\u2113\n\u2227-commutativeMonoid = record\n  { isCommutativeMonoid = \u2227-isCommutativeMonoid\n  }\n\n\u2227-isIdempotentCommutativeMonoid :\n  IsIdempotentCommutativeMonoid _\u2227_ true\n\u2227-isIdempotentCommutativeMonoid = record\n  { isCommutativeMonoid = \u2227-isCommutativeMonoid\n  ; idem = \u2227-idem\n  }\n\n\u2227-idempotentCommutativeMonoid : IdempotentCommutativeMonoid 0\u2113 0\u2113\n\u2227-idempotentCommutativeMonoid = record\n  { isIdempotentCommutativeMonoid = \u2227-isIdempotentCommutativeMonoid\n  }\n\n\u2228-\u2227-isSemiring : IsSemiring _\u2228_ _\u2227_ false true\n\u2228-\u2227-isSemiring = record\n  { isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = \u2228-isCommutativeMonoid\n    ; *-cong = cong\u2082 _\u2227_\n    ; *-assoc = \u2227-assoc\n    ; *-identity = \u2227-identity\n    ; distrib = \u2227-distrib-\u2228\n    }\n  ; zero = \u2227-zero\n  }\n\n\u2228-\u2227-isCommutativeSemiring\n  : IsCommutativeSemiring _\u2228_ _\u2227_ false true\n\u2228-\u2227-isCommutativeSemiring = record\n  { isSemiring = \u2228-\u2227-isSemiring\n  ; *-comm = \u2227-comm\n  }\n\n\u2228-\u2227-commutativeSemiring : CommutativeSemiring 0\u2113 0\u2113\n\u2228-\u2227-commutativeSemiring = record\n  { _+_                   = _\u2228_\n  ; _*_                   = _\u2227_\n  ; 0#                    = false\n  ; 1#                    = true\n  ; isCommutativeSemiring = \u2228-\u2227-isCommutativeSemiring\n  }\n\n\u2227-\u2228-isSemiring : IsSemiring _\u2227_ _\u2228_ true false\n\u2227-\u2228-isSemiring = record\n  { isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = \u2227-isCommutativeMonoid\n    ; *-cong = cong\u2082 _\u2228_\n    ; *-assoc = \u2228-assoc\n    ; *-identity = \u2228-identity\n    ; distrib = \u2228-distrib-\u2227\n    }\n  ; zero = \u2228-zero\n  }\n\n\u2227-\u2228-isCommutativeSemiring\n  : IsCommutativeSemiring _\u2227_ _\u2228_ true false\n\u2227-\u2228-isCommutativeSemiring = record\n  { isSemiring = \u2227-\u2228-isSemiring\n  ; *-comm = \u2228-comm\n  }\n\n\u2227-\u2228-commutativeSemiring : CommutativeSemiring 0\u2113 0\u2113\n\u2227-\u2228-commutativeSemiring = record\n  { _+_                   = _\u2227_\n  ; _*_                   = _\u2228_\n  ; 0#                    = true\n  ; 1#                    = false\n  ; isCommutativeSemiring = \u2227-\u2228-isCommutativeSemiring\n  }\n\n\u2228-\u2227-isLattice : IsLattice _\u2228_ _\u2227_\n\u2228-\u2227-isLattice = record\n  { isEquivalence = isEquivalence\n  ; \u2228-comm        = \u2228-comm\n  ; \u2228-assoc       = \u2228-assoc\n  ; \u2228-cong        = cong\u2082 _\u2228_\n  ; \u2227-comm        = \u2227-comm\n  ; \u2227-assoc       = \u2227-assoc\n  ; \u2227-cong        = cong\u2082 _\u2227_\n  ; absorptive    = \u2228-\u2227-absorptive\n  }\n\n\u2228-\u2227-lattice : Lattice 0\u2113 0\u2113\n\u2228-\u2227-lattice = record\n  { isLattice = \u2228-\u2227-isLattice\n  }\n\n\u2228-\u2227-isDistributiveLattice : IsDistributiveLattice _\u2228_ _\u2227_\n\u2228-\u2227-isDistributiveLattice = record\n  { isLattice   = \u2228-\u2227-isLattice\n  ; \u2228-distrib-\u2227 = \u2228-distrib-\u2227\n  ; \u2227-distrib-\u2228 = \u2227-distrib-\u2228\n  }\n\n\u2228-\u2227-distributiveLattice : DistributiveLattice 0\u2113 0\u2113\n\u2228-\u2227-distributiveLattice = record\n  { isDistributiveLattice = \u2228-\u2227-isDistributiveLattice\n  }\n\n\u2228-\u2227-isBooleanAlgebra : IsBooleanAlgebra _\u2228_ _\u2227_ not true false\n\u2228-\u2227-isBooleanAlgebra = record\n  { isDistributiveLattice = \u2228-\u2227-isDistributiveLattice\n  ; \u2228-complement          = \u2228-inverse\n  ; \u2227-complement          = \u2227-inverse\n  ; \u00ac-cong                = cong not\n  }\n\n\u2228-\u2227-booleanAlgebra : BooleanAlgebra 0\u2113 0\u2113\n\u2228-\u2227-booleanAlgebra = record\n  { isBooleanAlgebra = \u2228-\u2227-isBooleanAlgebra\n  }\n\n------------------------------------------------------------------------\n-- Properties of not\n\nnot-involutive : Involutive not\nnot-involutive true  = refl\nnot-involutive false = refl\n\nnot-injective : \u2200 {x y} \u2192 not x \u2261 not y \u2192 x \u2261 y\nnot-injective {false} {false} nx\u2262ny = refl\nnot-injective {true}  {true}  nx\u2262ny = refl\n\nnot-\u00ac : \u2200 {x y} \u2192 x \u2261 y \u2192 x \u2262 not y\nnot-\u00ac {true}  refl ()\nnot-\u00ac {false} refl ()\n\n\u00ac-not : \u2200 {x y} \u2192 x \u2262 y \u2192 x \u2261 not y\n\u00ac-not {true}  {true}  x\u2262y = contradiction refl x\u2262y\n\u00ac-not {true}  {false} _   = refl\n\u00ac-not {false} {true}  _   = refl\n\u00ac-not {false} {false} x\u2262y = contradiction refl x\u2262y\n\n------------------------------------------------------------------------\n-- Properties of _xor_\n\nxor-is-ok : \u2200 x y \u2192 x xor y \u2261 (x \u2228 y) \u2227 not (x \u2227 y)\nxor-is-ok true  y = refl\nxor-is-ok false y = sym (\u2227-identity\u02b3 _)\n\ntrue-xor : \u2200 x \u2192 true xor x \u2261 not x\ntrue-xor false = refl\ntrue-xor true  = refl\n\nxor-same : \u2200 x \u2192 x xor x \u2261 false\nxor-same false = refl\nxor-same true  = refl\n\nnot-distrib\u02e1-xor : \u2200 x y \u2192 not (x xor y) \u2261 (not x) xor y\nnot-distrib\u02e1-xor false y = refl\nnot-distrib\u02e1-xor true  y = not-involutive _\n\nnot-distrib\u02b3-xor : \u2200 x y \u2192 not (x xor y) \u2261 x xor (not y)\nnot-distrib\u02b3-xor false y = refl\nnot-distrib\u02b3-xor true  y = refl\n\nxor-assoc : Associative _xor_\nxor-assoc true  y z = sym (not-distrib\u02e1-xor y z)\nxor-assoc false y z = refl\n\nxor-comm : Commutative _xor_\nxor-comm false false = refl\nxor-comm false true  = refl\nxor-comm true  false = refl\nxor-comm true  true  = refl\n\nxor-identity\u02e1 : LeftIdentity false _xor_\nxor-identity\u02e1 _ = refl\n\nxor-identity\u02b3 : RightIdentity false _xor_\nxor-identity\u02b3 false = refl\nxor-identity\u02b3 true  = refl\n\nxor-identity : Identity false _xor_\nxor-identity = xor-identity\u02e1 , xor-identity\u02b3\n\nxor-inverse\u02e1 : LeftInverse true not _xor_\nxor-inverse\u02e1 false = refl\nxor-inverse\u02e1 true = refl\n\nxor-inverse\u02b3 : RightInverse true not _xor_\nxor-inverse\u02b3 x = xor-comm x (not x) \u27e8 trans \u27e9 xor-inverse\u02e1 x\n\nxor-inverse : Inverse true not _xor_\nxor-inverse = xor-inverse\u02e1 , xor-inverse\u02b3\n\n\u2227-distrib\u02e1-xor : _\u2227_ DistributesOver\u02e1 _xor_\n\u2227-distrib\u02e1-xor false y z = refl\n\u2227-distrib\u02e1-xor true  y z = refl\n\n\u2227-distrib\u02b3-xor : _\u2227_ DistributesOver\u02b3 _xor_\n\u2227-distrib\u02b3-xor x false z    = refl\n\u2227-distrib\u02b3-xor x true false = sym (xor-identity\u02b3 x)\n\u2227-distrib\u02b3-xor x true true  = sym (xor-same x)\n\n\u2227-distrib-xor : _\u2227_ DistributesOver _xor_\n\u2227-distrib-xor = \u2227-distrib\u02e1-xor , \u2227-distrib\u02b3-xor\n\nxor-annihilates-not : \u2200 x y \u2192 (not x) xor (not y) \u2261 x xor y\nxor-annihilates-not false y = not-involutive _\nxor-annihilates-not true  y = refl\n\nxor-\u2227-commutativeRing : CommutativeRing 0\u2113 0\u2113\nxor-\u2227-commutativeRing = \u2295-\u2227-commutativeRing\n  where\n  open BooleanAlgebraProperties \u2228-\u2227-booleanAlgebra\n  open XorRing _xor_ xor-is-ok\n\n------------------------------------------------------------------------\n-- Properties of if_then_else_\n\nif-float : \u2200 (f : A \u2192 B) b {x y} \u2192\n           f (if b then x else y) \u2261 (if b then f x else f y)\nif-float _ true  = refl\nif-float _ false = refl\n\nif-eta : \u2200 b {x : A} \u2192\n         (if b then x else x) \u2261 x\nif-eta false = refl\nif-eta true  = refl\n\nif-idem-then : \u2200 b {x y : A} \u2192\n               (if b then (if b then x else y) else y)\n             \u2261 (if b then x                    else y)\nif-idem-then false = refl\nif-idem-then true  = refl\n\nif-idem-else : \u2200 b {x y : A} \u2192\n               (if b then x else (if b then x else y))\n             \u2261 (if b then x else y)\nif-idem-else false = refl\nif-idem-else true  = refl\n\nif-swap-then : \u2200 b c {x y : A} \u2192\n          (if b then (if c then x else y) else y)\n        \u2261 (if c then (if b then x else y) else y)\nif-swap-then false false = refl\nif-swap-then false true  = refl\nif-swap-then true  _     = refl\n\nif-swap-else : \u2200 b c {x y : A} \u2192\n          (if b then x else (if c then x else y))\n        \u2261 (if c then x else (if b then x else y))\nif-swap-else false _     = refl\nif-swap-else true  false = refl\nif-swap-else true  true  = refl\n\nif-not : \u2200 b {x y : A} \u2192\n         (if not b then x else y) \u2261 (if b then y else x)\nif-not false = refl\nif-not true  = refl\n\nif-\u2227 : \u2200 b {c} {x y : A} \u2192\n       (if b \u2227 c then x else y) \u2261 (if b then (if c then x else y) else y)\nif-\u2227 false = refl\nif-\u2227 true  = refl\n\nif-\u2228 : \u2200 b {c} {x y : A} \u2192\n       (if b \u2228 c then x else y) \u2261 (if b then x else (if c then x else y))\nif-\u2228 false = refl\nif-\u2228 true  = refl\n\nif-xor : \u2200 b {c} {x y : A} \u2192\n         (if b xor c then x else y)\n       \u2261 (if b then (if c then y else x) else (if c then x else y))\nif-xor false = refl\nif-xor true {false} = refl\nif-xor true {true } = refl\n\n-- The following congruence lemmas are short hands for\n--   cong (if_then x else y)\n--   cong (if b then_else y)\n--   cong (if b then x else_)\n--   cong (if b then_else_)\n-- on the different sub-terms in an if_then_else_ expression.\n-- With these short hands, the branches x and y can be inferred\n-- automatically (i.e., they are implicit arguments) whereas\n-- the branches have to be spelled out explicitly when using cong.\n-- (Using underscores as in \"cong (if b then _ else_)\"\n-- unfortunately fails to resolve the omitted argument.)\n\nif-cong : \u2200 {b c} {x y : A} \u2192 b \u2261 c \u2192\n          (if b then x else y)\n        \u2261 (if c then x else y)\nif-cong refl = refl\n\nif-cong-then : \u2200 b {x y z : A} \u2192 x \u2261 z \u2192\n               (if b then x else y)\n             \u2261 (if b then z else y)\nif-cong-then _ refl = refl\n\nif-cong-else : \u2200 b {x y z : A} \u2192 y \u2261 z \u2192\n               (if b then x else y)\n             \u2261 (if b then x else z)\nif-cong-else _ refl = refl\n\nif-cong\u2082 : \u2200 b {x y z w : A} \u2192 x \u2261 z \u2192 y \u2261 w \u2192\n           (if b then x else y)\n         \u2261 (if b then z else w)\nif-cong\u2082 _ refl refl = refl\n\n------------------------------------------------------------------------\n-- Properties of T\n\nopen Relation.Nullary.Decidable.Core public using (T?)\n\nT-\u2261 : \u2200 {x} \u2192 T x \u21d4 x \u2261 true\nT-\u2261 {false} = mk\u21d4 (\u03bb ())       (\u03bb ())\nT-\u2261 {true}  = mk\u21d4 (const refl) (const _)\n\nT-not-\u2261 : \u2200 {x} \u2192 T (not x) \u21d4 x \u2261 false\nT-not-\u2261 {false} = mk\u21d4 (const refl) (const _)\nT-not-\u2261 {true}  = mk\u21d4 (\u03bb ())       (\u03bb ())\n\nT-\u2227 : \u2200 {x y} \u2192 T (x \u2227 y) \u21d4 (T x \u00d7 T y)\nT-\u2227 {true}  {true}  = mk\u21d4 (const (_ , _)) (const _)\nT-\u2227 {true}  {false} = mk\u21d4 (\u03bb ())          proj\u2082\nT-\u2227 {false} {_}     = mk\u21d4 (\u03bb ())          proj\u2081\n\nT-\u2228 : \u2200 {x y} \u2192 T (x \u2228 y) \u21d4 (T x \u228e T y)\nT-\u2228 {true}  {_}     = mk\u21d4 inj\u2081 (const _)\nT-\u2228 {false} {true}  = mk\u21d4 inj\u2082 (const _)\nT-\u2228 {false} {false} = mk\u21d4 inj\u2081 [ id , id ]\n\nT-irrelevant : U.Irrelevant T\nT-irrelevant {true}  _  _  = refl\n\nT?-diag : \u2200 b \u2192 T b \u2192 True (T? b)\nT?-diag b = fromWitness\n\n------------------------------------------------------------------------\n-- Miscellaneous other properties\n\n\u21d4\u2192\u2261 : {x y z : Bool} \u2192 x \u2261 z \u21d4 y \u2261 z \u2192 x \u2261 y\n\u21d4\u2192\u2261 {true } {true }         hyp = refl\n\u21d4\u2192\u2261 {true } {false} {true } hyp = sym (Equivalence.to hyp refl)\n\u21d4\u2192\u2261 {true } {false} {false} hyp = Equivalence.from hyp refl\n\u21d4\u2192\u2261 {false} {true } {true } hyp = Equivalence.from hyp refl\n\u21d4\u2192\u2261 {false} {true } {false} hyp = sym (Equivalence.to hyp refl)\n\u21d4\u2192\u2261 {false} {false}         hyp = refl\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\npush-function-into-if = if-float\n{-# WARNING_ON_USAGE push-function-into-if\n\"Warning: push-function-into-if was deprecated in v2.0.\nPlease use if-float instead.\"\n#-}\n</pre>"},{"location":"md/Data/Char/Base/","title":"Data.Char.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definitions for Characters\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Char.Base where\n\nimport Data.Nat.Base as \u2115 using (_&lt;_; _\u2261\u1d47_)\nopen import Data.Bool.Base using (Bool)\nopen import Function.Base using (_on_)\nopen import Level using (zero)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; _\u2262_)\nopen import Relation.Binary.Construct.Closure.Reflexive using (ReflClosure)\n\n------------------------------------------------------------------------\n-- Re-export the type, and renamed primitives\n\nopen import Agda.Builtin.Char public using ( Char )\n  renaming\n  -- testing\n  ( primIsLower    to isLower\n  ; primIsDigit    to isDigit\n  ; primIsAlpha    to isAlpha\n  ; primIsSpace    to isSpace\n  ; primIsAscii    to isAscii\n  ; primIsLatin1   to isLatin1\n  ; primIsPrint    to isPrint\n  ; primIsHexDigit to isHexDigit\n  -- transforming\n  ; primToUpper to toUpper\n  ; primToLower to toLower\n  -- converting\n  ; primCharToNat to to\u2115\n  ; primNatToChar to from\u2115\n  )\n\nopen import Agda.Builtin.String public using ()\n  renaming ( primShowChar to show )\n\ninfix 4 _\u2248_ _\u2249_\n_\u2248_ : Rel Char zero\n_\u2248_ = _\u2261_ on to\u2115\n\n_\u2249_ : Rel Char zero\n_\u2249_ = _\u2262_ on to\u2115\n\ninfix 4 _\u2248\u1d47_\n_\u2248\u1d47_ : (c d : Char) \u2192 Bool\nc \u2248\u1d47 d = to\u2115 c \u2115.\u2261\u1d47 to\u2115 d\n\ninfix 4 _&lt;_\n_&lt;_ : Rel Char zero\n_&lt;_ = \u2115._&lt;_ on to\u2115\n\ninfix 4 _\u2264_\n_\u2264_ : Rel Char zero\n_\u2264_ = ReflClosure _&lt;_\n</pre>"},{"location":"md/Data/Empty/","title":"Data.Empty","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Empty type, judgementally proof irrelevant, Level-monomorphic\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Empty where\n\nopen import Data.Irrelevant using (Irrelevant)\n\n------------------------------------------------------------------------\n-- Definition\n\n-- Note that by default the empty type is not universe polymorphic as it\n-- often results in unsolved metas. See `Data.Empty.Polymorphic` for a\n-- universe polymorphic variant.\n\nprivate\n  data Empty : Set where\n\n-- \u22a5 is defined via Data.Irrelevant (a record with a single irrelevant\n-- field) so that Agda can judgementally declare that all proofs of \u22a5\n-- are equal to each other. In particular this means that all functions\n-- returning a proof of \u22a5 are equal.\n\n\u22a5 : Set\n\u22a5 = Irrelevant Empty\n\n{-# DISPLAY Irrelevant Empty = \u22a5 #-}\n\n------------------------------------------------------------------------\n-- Functions\n\n\u22a5-elim : \u2200 {w} {Whatever : Set w} \u2192 \u22a5 \u2192 Whatever\n\u22a5-elim ()\n\n\u22a5-elim-irr : \u2200 {w} {Whatever : Set w} \u2192 .\u22a5 \u2192 Whatever\n\u22a5-elim-irr ()\n</pre>"},{"location":"md/Data/Empty/Polymorphic/","title":"Data.Empty.Polymorphic","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Level polymorphic Empty type\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Empty.Polymorphic where\n\nimport Data.Empty as Empty using (\u22a5; \u22a5-elim)\nopen import Level using (Level; Lift; _\u2294_)\n\n\u22a5 : {\u2113 : Level} \u2192 Set \u2113\n\u22a5 {\u2113} = Lift \u2113 Empty.\u22a5\n\n-- make \u22a5-elim dependent too, as it does seem useful\n\u22a5-elim : \u2200 {w \u2113} {Whatever : \u22a5 {\u2113} \u2192 Set w} \u2192 (witness : \u22a5 {\u2113}) \u2192 Whatever witness\n\u22a5-elim ()\n</pre>"},{"location":"md/Data/Fin/Base/","title":"Data.Fin.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Finite sets\n------------------------------------------------------------------------\n\n-- Note that elements of Fin n can be seen as natural numbers in the\n-- set {m | m &lt; n}. The notation \"m\" in comments below refers to this\n-- natural number view.\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Fin.Base where\n\nopen import Data.Nat.Base as \u2115 using (\u2115; zero; suc)\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082; [_,_]\u2032)\nopen import Function.Base using (id; _\u2218_; _on_; flip; _$_)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; _\u2262_; refl; cong)\nopen import Relation.Binary.Indexed.Heterogeneous.Core using (IRel)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\n\nprivate\n  variable\n    m n : \u2115\n\n------------------------------------------------------------------------\n-- Types\n\n-- Fin n is a type with n elements.\n\ndata Fin : \u2115 \u2192 Set where\n  zero : Fin (suc n)\n  suc  : (i : Fin n) \u2192 Fin (suc n)\n\n-- A conversion: to\u2115 \"i\" = i.\n\nto\u2115 : Fin n \u2192 \u2115\nto\u2115 zero    = 0\nto\u2115 (suc i) = suc (to\u2115 i)\n\n-- A Fin-indexed variant of Fin.\n\nFin\u2032 : Fin n \u2192 Set\nFin\u2032 i = Fin (to\u2115 i)\n\n------------------------------------------------------------------------\n-- A cast that actually computes on constructors (as opposed to subst)\n\ncast : .(m \u2261 n) \u2192 Fin m \u2192 Fin n\ncast {zero}  {zero}  eq k       = k\ncast {suc m} {suc n} eq zero    = zero\ncast {suc m} {suc n} eq (suc k) = suc (cast (cong \u2115.pred eq) k)\n\n------------------------------------------------------------------------\n-- Conversions\n\n-- to\u2115 is defined above.\n\n-- from\u2115 n = \"n\".\n\nfrom\u2115 : (n : \u2115) \u2192 Fin (suc n)\nfrom\u2115 zero    = zero\nfrom\u2115 (suc n) = suc (from\u2115 n)\n\n-- from\u2115&lt; {m} _ = \"m\".\n\nfrom\u2115&lt; : .(m \u2115.&lt; n) \u2192 Fin n\nfrom\u2115&lt; {zero}  {suc _} _   = zero\nfrom\u2115&lt; {suc m} {suc _} m&lt;n = suc (from\u2115&lt; (\u2115.s&lt;s\u207b\u00b9 m&lt;n))\n\n-- from\u2115&lt;\u2033 m _ = \"m\".\n\nfrom\u2115&lt;\u2033 : \u2200 m {n} \u2192 .(m \u2115.&lt;\u2033 n) \u2192 Fin n\nfrom\u2115&lt;\u2033 zero    {suc _} _    = zero\nfrom\u2115&lt;\u2033 (suc m) {suc _} m&lt;\u2033n = suc (from\u2115&lt;\u2033 m (\u2115.s&lt;\u2033s\u207b\u00b9 m&lt;\u2033n))\n\n-- canonical liftings of i:Fin m to larger index\n\n-- injection on the left: \"i\" \u2191\u02e1 n = \"i\" in Fin (m + n)\ninfixl 5 _\u2191\u02e1_\n_\u2191\u02e1_ : \u2200 {m} \u2192 Fin m \u2192 \u2200 n \u2192 Fin (m \u2115.+ n)\nzero    \u2191\u02e1 n = zero\n(suc i) \u2191\u02e1 n = suc (i \u2191\u02e1 n)\n\n-- injection on the right: n \u2191\u02b3 \"i\" = \"n + i\" in Fin (n + m)\ninfixr 5 _\u2191\u02b3_\n_\u2191\u02b3_ : \u2200 {m} n \u2192 Fin m \u2192 Fin (n \u2115.+ m)\nzero    \u2191\u02b3 i = i\n(suc n) \u2191\u02b3 i = suc (n \u2191\u02b3 i)\n\n-- reduce\u2265 \"m + i\" _ = \"i\".\n\nreduce\u2265 : \u2200 (i : Fin (m \u2115.+ n)) \u2192 .(m \u2115.\u2264 to\u2115 i) \u2192 Fin n\nreduce\u2265 {zero}  i       _   = i\nreduce\u2265 {suc _} (suc i) m\u2264i = reduce\u2265 i (\u2115.s\u2264s\u207b\u00b9 m\u2264i)\n\n-- inject\u22c6 m \"i\" = \"i\".\n\ninject : \u2200 {i : Fin n} \u2192 Fin\u2032 i \u2192 Fin n\ninject {i = suc i} zero    = zero\ninject {i = suc i} (suc j) = suc (inject j)\n\ninject! : \u2200 {i : Fin (suc n)} \u2192 Fin\u2032 i \u2192 Fin n\ninject! {n = suc _} {i = suc _} zero    = zero\ninject! {n = suc _} {i = suc _} (suc j) = suc (inject! j)\n\ninject\u2081 : Fin n \u2192 Fin (suc n)\ninject\u2081 zero    = zero\ninject\u2081 (suc i) = suc (inject\u2081 i)\n\ninject\u2264 : Fin m \u2192 .(m \u2115.\u2264 n) \u2192 Fin n\ninject\u2264 {n = suc _} zero    _   = zero\ninject\u2264 {n = suc _} (suc i) m\u2264n = suc (inject\u2264 i (\u2115.s\u2264s\u207b\u00b9 m\u2264n))\n\n-- lower\u2081 \"i\" _ = \"i\".\n\nlower\u2081 : \u2200 (i : Fin (suc n)) \u2192 n \u2262 to\u2115 i \u2192 Fin n\nlower\u2081 {zero}  zero    ne = contradiction refl ne\nlower\u2081 {suc n} zero    _  = zero\nlower\u2081 {suc n} (suc i) ne = suc (lower\u2081 i (ne \u2218 cong suc))\n\nlower : \u2200 (i : Fin m) \u2192 .(to\u2115 i \u2115.&lt; n) \u2192 Fin n\nlower {n = suc n} zero    leq = zero\nlower {n = suc n} (suc i) leq = suc (lower i (\u2115.s\u2264s\u207b\u00b9 leq))\n\n-- A strengthening injection into the minimal Fin fibre.\nstrengthen : \u2200 (i : Fin n) \u2192 Fin\u2032 (suc i)\nstrengthen zero    = zero\nstrengthen (suc i) = suc (strengthen i)\n\n-- splitAt m \"i\" = inj\u2081 \"i\"      if i &lt; m\n--                 inj\u2082 \"i - m\"  if i \u2265 m\n-- This is dual to splitAt from Data.Vec.\n\nsplitAt : \u2200 m {n} \u2192 Fin (m \u2115.+ n) \u2192 Fin m \u228e Fin n\nsplitAt zero    i       = inj\u2082 i\nsplitAt (suc m) zero    = inj\u2081 zero\nsplitAt (suc m) (suc i) = Sum.map\u2081 suc (splitAt m i)\n\n-- inverse of above function\njoin : \u2200 m n \u2192 Fin m \u228e Fin n \u2192 Fin (m \u2115.+ n)\njoin m n = [ _\u2191\u02e1 n , m \u2191\u02b3_ ]\u2032\n\n-- quotRem k \"i\" = \"i % k\" , \"i / k\"\n-- This is dual to group from Data.Vec.\n\nquotRem : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin n \u00d7 Fin m\nquotRem {suc m} n i =\n  [ (_, zero)\n  , Product.map\u2082 suc \u2218 quotRem {m} n\n  ]\u2032 $ splitAt n i\n\n-- a variant of quotRem the type of whose result matches the order of multiplication\nremQuot : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin m \u00d7 Fin n\nremQuot i = Product.swap \u2218 quotRem i\n\nquotient : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin m\nquotient n = proj\u2081 \u2218 remQuot n\n\nremainder : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin n\nremainder {m} n = proj\u2082 \u2218 remQuot {m} n\n\n-- inverse of remQuot\ncombine : Fin m \u2192 Fin n \u2192 Fin (m \u2115.* n)\ncombine {suc m} {n} zero    j = j \u2191\u02e1 (m \u2115.* n)\ncombine {suc m} {n} (suc i) j = n \u2191\u02b3 (combine i j)\n\n-- Next in progression after splitAt and remQuot\nfinToFun : Fin (m \u2115.^ n) \u2192 (Fin n \u2192 Fin m)\nfinToFun {m} {suc n} i zero    = quotient (m \u2115.^ n) i\nfinToFun {m} {suc n} i (suc j) = finToFun (remainder {m} (m \u2115.^ n) i) j\n\n-- inverse of above function\nfunToFin : (Fin m \u2192 Fin n) \u2192 Fin (n \u2115.^ m)\nfunToFin {zero}  f = zero\nfunToFin {suc m} f = combine (f zero) (funToFin (f \u2218 suc))\n\n------------------------------------------------------------------------\n-- Operations\n\n-- Folds.\n\nfold : \u2200 {t} (T : \u2115 \u2192 Set t) {m} \u2192\n       (\u2200 {n} \u2192 T n \u2192 T (suc n)) \u2192\n       (\u2200 {n} \u2192 T (suc n)) \u2192\n       Fin m \u2192 T m\nfold T f x zero    = x\nfold T f x (suc i) = f (fold T f x i)\n\nfold\u2032 : \u2200 {n t} (T : Fin (suc n) \u2192 Set t) \u2192\n        (\u2200 i \u2192 T (inject\u2081 i) \u2192 T (suc i)) \u2192\n        T zero \u2192\n        \u2200 i \u2192 T i\nfold\u2032             T f x zero     = x\nfold\u2032 {n = suc n} T f x (suc i)  =\n  f i (fold\u2032 (T \u2218 inject\u2081) (f \u2218 inject\u2081) x i)\n\n-- Lifts functions.\n\nlift : \u2200 k \u2192 (Fin m \u2192 Fin n) \u2192 Fin (k \u2115.+ m) \u2192 Fin (k \u2115.+ n)\nlift zero    f i       = f i\nlift (suc k) f zero    = zero\nlift (suc k) f (suc i) = suc (lift k f i)\n\n-- \"i\" + \"j\" = \"i + j\".\n\ninfixl 6 _+_\n\n_+_ : \u2200 (i : Fin m) (j : Fin n) \u2192 Fin (to\u2115 i \u2115.+ n)\nzero  + j = j\nsuc i + j = suc (i + j)\n\n-- \"i\" - \"j\" = \"i \u2238 j\".\n\ninfixl 6 _-_\n\n_-_ : \u2200 (i : Fin n) (j : Fin\u2032 (suc i)) \u2192 Fin (n \u2115.\u2238 to\u2115 j)\ni     - zero   = i\nsuc i - suc j  = i - j\n\n-- m \u2115- \"i\" = \"m \u2238 i\".\n\ninfixl 6 _\u2115-_\n\n_\u2115-_ : (n : \u2115) (j : Fin (suc n)) \u2192 Fin (suc n \u2115.\u2238 to\u2115 j)\nn     \u2115- zero   = from\u2115 n\nsuc n \u2115- suc i  = n \u2115- i\n\n-- m \u2115-\u2115 \"i\" = m \u2238 i.\n\ninfixl 6 _\u2115-\u2115_\n\n_\u2115-\u2115_ : (n : \u2115) \u2192 Fin (suc n) \u2192 \u2115\nn     \u2115-\u2115 zero   = n\nsuc n \u2115-\u2115 suc i  = n \u2115-\u2115 i\n\n-- pred \"i\" = \"pred i\".\n\npred : Fin n \u2192 Fin n\npred zero    = zero\npred (suc i) = inject\u2081 i\n\n-- opposite \"i\" = \"n - i\" (i.e. the additive inverse).\n\nopposite : Fin n \u2192 Fin n\nopposite {suc n} zero    = from\u2115 n\nopposite {suc n} (suc i) = inject\u2081 (opposite i)\n\n-- The function f(i,j) = if j&gt;i then j-1 else j\n-- This is a variant of the thick function from Conor\n-- McBride's \"First-order unification by structural recursion\".\n\npunchOut : \u2200 {i j : Fin (suc n)} \u2192 i \u2262 j \u2192 Fin n\npunchOut {_}     {zero}   {zero}  i\u2262j = contradiction refl i\u2262j\npunchOut {_}     {zero}   {suc j} _   = j\npunchOut {suc _} {suc i}  {zero}  _   = zero\npunchOut {suc _} {suc i}  {suc j} i\u2262j = suc (punchOut (i\u2262j \u2218 cong suc))\n\n-- The function f(i,j) = if j\u2265i then j+1 else j\n\npunchIn : Fin (suc n) \u2192 Fin n \u2192 Fin (suc n)\npunchIn zero    j       = suc j\npunchIn (suc i) zero    = zero\npunchIn (suc i) (suc j) = suc (punchIn i j)\n\n-- The function f(i,j) such that f(i,j) = if j\u2264i then j else j-1\n\npinch : Fin n \u2192 Fin (suc n) \u2192 Fin n\npinch {suc n} _       zero    = zero\npinch {suc n} zero    (suc j) = j\npinch {suc n} (suc i) (suc j) = suc (pinch i j)\n\n------------------------------------------------------------------------\n-- Order relations\n\ninfix 4 _\u2264_ _\u2265_ _&lt;_ _&gt;_ _\u2270_ _\u226e_\n\n_\u2264_ : IRel Fin 0\u2113\ni \u2264 j = to\u2115 i \u2115.\u2264 to\u2115 j\n\n_\u2265_ : IRel Fin 0\u2113\ni \u2265 j = to\u2115 i \u2115.\u2265 to\u2115 j\n\n_&lt;_ : IRel Fin 0\u2113\ni &lt; j = to\u2115 i \u2115.&lt; to\u2115 j\n\n_&gt;_ : IRel Fin 0\u2113\ni &gt; j = to\u2115 i \u2115.&gt; to\u2115 j\n\n_\u2270_ : \u2200 {n} \u2192 Rel (Fin n) 0\u2113\ni \u2270 j = \u00ac (i \u2264 j)\n\n_\u226e_ : \u2200 {n} \u2192 Rel (Fin n) 0\u2113\ni \u226e j = \u00ac (i &lt; j)\n\n------------------------------------------------------------------------\n-- An ordering view.\n\ndata Ordering {n : \u2115} : Fin n \u2192 Fin n \u2192 Set where\n  less    : \u2200 greatest (least : Fin\u2032 greatest) \u2192\n            Ordering (inject least) greatest\n  equal   : \u2200 i \u2192 Ordering i i\n  greater : \u2200 greatest (least : Fin\u2032 greatest) \u2192\n            Ordering greatest (inject least)\n\ncompare : \u2200 (i j : Fin n) \u2192 Ordering i j\ncompare zero    zero    = equal   zero\ncompare zero    (suc j) = less    (suc j) zero\ncompare (suc i) zero    = greater (suc i) zero\ncompare (suc i) (suc j) with compare i j\n... | less    greatest least = less    (suc greatest) (suc least)\n... | greater greatest least = greater (suc greatest) (suc least)\n... | equal   i              = equal   (suc i)\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nraise = _\u2191\u02b3_\n{-# WARNING_ON_USAGE raise\n\"Warning: raise was deprecated in v2.0.\nPlease use _\u2191\u02b3_ instead.\"\n#-}\ninject+ : \u2200 {m} n \u2192 Fin m \u2192 Fin (m \u2115.+ n)\ninject+ n i = i \u2191\u02e1 n\n{-# WARNING_ON_USAGE inject+\n\"Warning: inject+ was deprecated in v2.0.\nPlease use _\u2191\u02e1_ instead.\nNB argument order has been flipped:\nthe left-hand argument is the Fin m\nthe right-hand is the Nat index increment.\"\n#-}\n\ndata _\u227a_ : \u2115 \u2192 \u2115 \u2192 Set where\n  _\u227bto\u2115_ : \u2200 n (i : Fin n) \u2192 to\u2115 i \u227a n\n\n{-# WARNING_ON_USAGE _\u227a_\n\"Warning: _\u227a_ was deprecated in v2.0.\nPlease use equivalent relation _&lt;_ instead.\"\n#-}\n{-# WARNING_ON_USAGE _\u227bto\u2115_\n\"Warning: _\u227bto\u2115_ was deprecated in v2.0.\nPlease use to\u2115&lt;n from Data.Fin.Properties instead.\"\n#-}\n</pre>"},{"location":"md/Data/Integer/Base/","title":"Data.Integer.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Integers, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.Integer for examples of how to use and reason about\n-- integers.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Integer.Base where\n\nopen import Algebra.Bundles.Raw\n  using (RawMagma; RawMonoid; RawGroup; RawNearSemiring; RawSemiring; RawRing)\nopen import Data.Bool.Base using (Bool; T; true; false)\nopen import Data.Nat.Base as \u2115 using (\u2115; z\u2264n; s\u2264s) hiding (module \u2115)\nopen import Data.Sign.Base as Sign using (Sign)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Unary using (Pred)\n\ninfix  8 -_\ninfixr 8 _^_\ninfixl 7 _*_ _\u2293_ _/\u2115_ _/_ _%\u2115_ _%_\ninfixl 6 _+_ _-_ _\u2296_ _\u2294_\ninfix  4 _\u2264_ _\u2265_ _&lt;_ _&gt;_ _\u2270_ _\u2271_ _\u226e_ _\u226f_\ninfix  4 _\u2264\u1d47_\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.Int public\n  using ()\n  renaming\n  ( Int    to \u2124\n  ; pos    to +_      -- \"+ n\"      stands for \"n\"\n  ; negsuc to -[1+_]  -- \"-[1+ n ]\" stands for \"- (1 + n)\"\n  )\n\n-- Some additional patterns that provide symmetry around 0\n\npattern +0       = + 0\npattern +[1+_] n = + (\u2115.suc n)\n\n------------------------------------------------------------------------\n-- Constants\n\n0\u2124 : \u2124\n0\u2124 = +0\n\n-1\u2124 : \u2124\n-1\u2124 = -[1+ 0 ]\n\n1\u2124 : \u2124\n1\u2124 = +[1+ 0 ]\n\n------------------------------------------------------------------------\n-- Conversion\n\n-- Absolute value.\n\n\u2223_\u2223 : \u2124 \u2192 \u2115\n\u2223 + n      \u2223 = n\n\u2223 -[1+ n ] \u2223 = \u2115.suc n\n\n-- Gives the sign. For zero the sign is arbitrarily chosen to be +.\n\nsign : \u2124 \u2192 Sign\nsign (+ _)    = Sign.+\nsign -[1+ _ ] = Sign.-\n\n------------------------------------------------------------------------\n-- Ordering\n\ndata _\u2264_ : \u2124 \u2192 \u2124 \u2192 Set where\n  -\u2264- : \u2200 {m n} \u2192 (n\u2264m : n \u2115.\u2264 m) \u2192 -[1+ m ] \u2264 -[1+ n ]\n  -\u2264+ : \u2200 {m n} \u2192 -[1+ m ] \u2264 + n\n  +\u2264+ : \u2200 {m n} \u2192 (m\u2264n : m \u2115.\u2264 n) \u2192 + m \u2264 + n\n\ndata _&lt;_ : \u2124 \u2192 \u2124 \u2192 Set where\n  -&lt;- : \u2200 {m n} \u2192 (n&lt;m : n \u2115.&lt; m) \u2192 -[1+ m ] &lt; -[1+ n ]\n  -&lt;+ : \u2200 {m n} \u2192 -[1+ m ] &lt; + n\n  +&lt;+ : \u2200 {m n} \u2192 (m&lt;n : m \u2115.&lt; n) \u2192 + m &lt; + n\n\n_\u2265_ : Rel \u2124 0\u2113\nx \u2265 y = y \u2264 x\n\n_&gt;_ : Rel \u2124 0\u2113\nx &gt; y = y &lt; x\n\n_\u2270_ : Rel \u2124 0\u2113\nx \u2270 y = \u00ac (x \u2264 y)\n\n_\u2271_ : Rel \u2124 0\u2113\nx \u2271 y = \u00ac (x \u2265 y)\n\n_\u226e_ : Rel \u2124 0\u2113\nx \u226e y = \u00ac (x &lt; y)\n\n_\u226f_ : Rel \u2124 0\u2113\nx \u226f y = \u00ac (x &gt; y)\n\n------------------------------------------------------------------------\n-- Boolean ordering\n\n-- A boolean version.\n_\u2264\u1d47_ : \u2124 \u2192 \u2124 \u2192 Bool\n-[1+ m ] \u2264\u1d47 -[1+ n ] = n \u2115.\u2264\u1d47 m\n(+ m)    \u2264\u1d47 -[1+ n ] = false\n-[1+ m ] \u2264\u1d47 (+ n)    = true\n(+ m)    \u2264\u1d47 (+ n)    = m \u2115.\u2264\u1d47 n\n\n------------------------------------------------------------------------\n-- Simple predicates\n\n-- See `Data.Nat.Base` for a discussion on the design of these.\n\nNonZero : Pred \u2124 0\u2113\nNonZero i = \u2115.NonZero \u2223 i \u2223\n\nrecord Positive (i : \u2124) : Set where\n  field\n    pos : T (1\u2124 \u2264\u1d47 i)\n\nrecord NonNegative (i : \u2124) : Set where\n  field\n    nonNeg : T (0\u2124 \u2264\u1d47 i)\n\nrecord NonPositive (i : \u2124) : Set where\n  field\n    nonPos : T (i \u2264\u1d47 0\u2124)\n\nrecord Negative (i : \u2124) : Set where\n  field\n    neg : T (i \u2264\u1d47 -1\u2124)\n\n-- Instances\n\nopen \u2115 public\n  using (nonZero)\n\ninstance\n  pos : \u2200 {n} \u2192 Positive +[1+ n ]\n  pos = _\n\n  nonNeg : \u2200 {n} \u2192 NonNegative (+ n)\n  nonNeg = _\n\n  nonPos0 : NonPositive 0\u2124\n  nonPos0 = _\n\n  nonPos : \u2200 {n} \u2192 NonPositive -[1+ n ]\n  nonPos = _\n\n  neg : \u2200 {n} \u2192 Negative -[1+ n ]\n  neg = _\n\n-- Constructors\n\n\u2262-nonZero : \u2200 {i} \u2192 i \u2262 0\u2124 \u2192 NonZero i\n\u2262-nonZero { +[1+ n ]} _   = _\n\u2262-nonZero { +0}       0\u22620 = contradiction refl 0\u22620\n\u2262-nonZero { -[1+ n ]} _   = _\n\n&gt;-nonZero : \u2200 {i} \u2192 i &gt; 0\u2124 \u2192 NonZero i\n&gt;-nonZero (+&lt;+ (s\u2264s m&lt;n)) = _\n\n&lt;-nonZero : \u2200 {i} \u2192 i &lt; 0\u2124 \u2192 NonZero i\n&lt;-nonZero -&lt;+ = _\n\npositive : \u2200 {i} \u2192 i &gt; 0\u2124 \u2192 Positive i\npositive (+&lt;+ (s\u2264s m&lt;n)) = _\n\nnegative : \u2200 {i} \u2192 i &lt; 0\u2124 \u2192 Negative i\nnegative -&lt;+ = _\n\nnonPositive : \u2200 {i} \u2192 i \u2264 0\u2124 \u2192 NonPositive i\nnonPositive -\u2264+       = _\nnonPositive (+\u2264+ z\u2264n) = _\n\nnonNegative : \u2200 {i} \u2192 i \u2265 0\u2124 \u2192 NonNegative i\nnonNegative {+0}       _ = _\nnonNegative {+[1+ n ]} _ = _\n\n------------------------------------------------------------------------\n-- A view of integers as sign + absolute value\n\ninfix 5 _\u25c2_ _\u25c3_\n\n_\u25c3_ : Sign \u2192 \u2115 \u2192 \u2124\n_      \u25c3 \u2115.zero  = +0\nSign.+ \u25c3 n       = + n\nSign.- \u25c3 \u2115.suc n = -[1+ n ]\n\ndata SignAbs : \u2124 \u2192 Set where\n  _\u25c2_ : (s : Sign) (n : \u2115) \u2192 SignAbs (s \u25c3 n)\n\nsignAbs : \u2200 i \u2192 SignAbs i\nsignAbs -[1+ n ] = Sign.- \u25c2 \u2115.suc n\nsignAbs +0       = Sign.+ \u25c2 \u2115.zero\nsignAbs +[1+ n ] = Sign.+ \u25c2 \u2115.suc n\n\n------------------------------------------------------------------------\n-- Arithmetic\n\n-- Negation.\n\n-_ : \u2124 \u2192 \u2124\n- -[1+ n ] = +[1+ n ]\n- +0       = +0\n- +[1+ n ] = -[1+ n ]\n\n-- Subtraction of natural numbers.\n-- We define it using _&lt;\u1d47_ and _\u2238_ rather than inductively so that it\n-- is backed by builtin operations. This makes it much faster.\n_\u2296_ : \u2115 \u2192 \u2115 \u2192 \u2124\nm \u2296 n with m \u2115.&lt;\u1d47 n\n... | true  = - + (n \u2115.\u2238 m)\n... | false = + (m \u2115.\u2238 n)\n\n-- Addition.\n\n_+_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] + -[1+ n ] = -[1+ \u2115.suc (m \u2115.+ n) ]\n-[1+ m ] + +    n   = n \u2296 \u2115.suc m\n+    m   + -[1+ n ] = m \u2296 \u2115.suc n\n+    m   + +    n   = + (m \u2115.+ n)\n\n-- Subtraction.\n\n_-_ : \u2124 \u2192 \u2124 \u2192 \u2124\ni - j = i + (- j)\n\n-- Successor.\n\nsuc : \u2124 \u2192 \u2124\nsuc i = 1\u2124 + i\n\n-- Predecessor.\n\npred : \u2124 \u2192 \u2124\npred i = -1\u2124 + i\n\n-- Multiplication.\n\n_*_ : \u2124 \u2192 \u2124 \u2192 \u2124\ni * j = sign i Sign.* sign j \u25c3 \u2223 i \u2223 \u2115.* \u2223 j \u2223\n\n-- Na\u00efve exponentiation.\n\n_^_ : \u2124 \u2192 \u2115 \u2192 \u2124\ni ^ \u2115.zero    = 1\u2124\ni ^ (\u2115.suc m) = i * i ^ m\n\n-- Maximum.\n\n_\u2294_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] \u2294 -[1+ n ] = -[1+ \u2115._\u2293_ m n ]\n-[1+ m ] \u2294 +    n   = + n\n+    m   \u2294 -[1+ n ] = + m\n+    m   \u2294 +    n   = + (\u2115._\u2294_ m n)\n\n-- Minimum.\n\n_\u2293_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] \u2293 -[1+ n ] = -[1+ m \u2115.\u2294 n ]\n-[1+ m ] \u2293 +    n   = -[1+ m ]\n+    m   \u2293 -[1+ n ] = -[1+ n ]\n+    m   \u2293 +    n   = + (m \u2115.\u2293 n)\n\n-- Division by a natural\n\n_/\u2115_ : (dividend : \u2124) (divisor : \u2115) .{{_ : \u2115.NonZero divisor}} \u2192 \u2124\n(+ n      /\u2115 d) = + (n \u2115./ d)\n(-[1+ n ] /\u2115 d) with \u2115.suc n \u2115.% d\n... | \u2115.zero  = - (+ (\u2115.suc n \u2115./ d))\n... | \u2115.suc r = -[1+ (\u2115.suc n \u2115./ d) ]\n\n-- Division\n\n_/_ : (dividend divisor : \u2124) .{{_ : NonZero divisor}} \u2192 \u2124\ni / j = (sign j \u25c3 1) * (i /\u2115 \u2223 j \u2223)\n\n-- Modulus by a natural\n\n_%\u2115_ : (dividend : \u2124) (divisor : \u2115) .{{_ : \u2115.NonZero divisor}} \u2192 \u2115\n(+ n      %\u2115 d) = n \u2115.% d\n(-[1+ n ] %\u2115 d) with \u2115.suc n \u2115.% d\n... | \u2115.zero      = 0\n... | r@(\u2115.suc _) = d \u2115.\u2238 r\n\n-- Modulus\n\n_%_ : (dividend divisor : \u2124) .{{_ : NonZero divisor}} \u2192 \u2115\ni % j = i %\u2115 \u2223 j \u2223\n\n------------------------------------------------------------------------\n-- Bundles\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ ; \u03b5 = 0\u2124 }\n\n+-0-rawGroup : RawGroup 0\u2113 0\u2113\n+-0-rawGroup = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ ; _\u207b\u00b9 = -_; \u03b5 = 0\u2124 }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record { _\u2248_ = _\u2261_ ; _\u2219_ = _*_ }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record { _\u2248_ = _\u2261_ ; _\u2219_ = _*_ ; \u03b5 = 1\u2124 }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2124\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2124\n  ; 1# = 1\u2124\n  }\n\n+-*-rawRing : RawRing 0\u2113 0\u2113\n+-*-rawRing = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; -_ = -_\n  ; 0# = 0\u2124\n  ; 1# = 1\u2124\n  }\n\n</pre>"},{"location":"md/Data/Irrelevant/","title":"Data.Irrelevant","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Wrapper for the proof irrelevance modality\n--\n-- This allows us to store proof irrelevant witnesses in a record and\n-- use projections to manipulate them without having to turn on the\n-- unsafe option --irrelevant-projections.\n-- Cf. Data.Refinement for a use case\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Irrelevant where\n\nopen import Level using (Level)\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Type\n\nrecord Irrelevant (A : Set a) : Set a where\n  constructor [_]\n  field .irrelevant : A\nopen Irrelevant public\n\n------------------------------------------------------------------------\n-- Algebraic structure: Functor, Appplicative and Monad-like\n\nmap : (A \u2192 B) \u2192 Irrelevant A \u2192 Irrelevant B\nmap f [ a ] = [ f a ]\n\npure : A \u2192 Irrelevant A\npure x = [ x ]\n\ninfixl 4 _&lt;*&gt;_\n_&lt;*&gt;_ : Irrelevant (A \u2192 B) \u2192 Irrelevant A \u2192 Irrelevant B\n[ f ] &lt;*&gt; [ a ] = [ f a ]\n\ninfixl 1 _&gt;&gt;=_\n_&gt;&gt;=_ : Irrelevant A \u2192 (.A \u2192 Irrelevant B) \u2192 Irrelevant B\n[ a ] &gt;&gt;= f = f a\n\n------------------------------------------------------------------------\n-- Other functions\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Irrelevant A \u2192 Irrelevant B \u2192 Irrelevant C\nzipWith f a b = \u2987 f a b \u2988\n</pre>"},{"location":"md/Data/List/Base/","title":"Data.List.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lists, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.List for examples of how to use and reason about\n-- lists.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid)\nopen import Data.Bool.Base as Bool\n  using (Bool; false; true; not; _\u2227_; _\u2228_; if_then_else_)\nopen import Data.Fin.Base using (Fin; zero; suc)\nopen import Data.Maybe.Base as Maybe using (Maybe; nothing; just; maybe\u2032)\nopen import Data.Nat.Base as \u2115 using (\u2115; zero; suc)\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; map\u2081; map\u2082\u2032)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Function.Base\n  using (id; _\u2218_ ; _\u2218\u2032_; _\u2218\u2082_; _$_; const; flip)\nopen import Level using (Level)\nopen import Relation.Unary using (Pred; Decidable)\nopen import Relation.Binary.Core using (Rel)\nimport Relation.Binary.Definitions as B\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Relation.Nullary.Decidable.Core using (T?; does; \u00ac?)\n\nprivate\n  variable\n    a b c p \u2113 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.List public\n  using (List; []; _\u2237_)\n\n------------------------------------------------------------------------\n-- Operations for transforming lists\n\nmap : (A \u2192 B) \u2192 List A \u2192 List B\nmap f []       = []\nmap f (x \u2237 xs) = f x \u2237 map f xs\n\ninfixr 5 _++_\n\n_++_ : List A \u2192 List A \u2192 List A\n[]       ++ ys = ys\n(x \u2237 xs) ++ ys = x \u2237 (xs ++ ys)\n\nintersperse : A \u2192 List A \u2192 List A\nintersperse x []       = []\nintersperse x (y \u2237 []) = y \u2237 []\nintersperse x (y \u2237 ys) = y \u2237 x \u2237 intersperse x ys\n\nintercalate : List A \u2192 List (List A) \u2192 List A\nintercalate xs []         = []\nintercalate xs (ys \u2237 [])  = ys\nintercalate xs (ys \u2237 yss) = ys ++ xs ++ intercalate xs yss\n\ncartesianProductWith : (A \u2192 B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\ncartesianProductWith f []       _  = []\ncartesianProductWith f (x \u2237 xs) ys = map (f x) ys ++ cartesianProductWith f xs ys\n\ncartesianProduct : List A \u2192 List B \u2192 List (A \u00d7 B)\ncartesianProduct = cartesianProductWith _,_\n\n------------------------------------------------------------------------\n-- Aligning and zipping\n\nalignWith : (These A B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\nalignWith f []       bs       = map (f \u2218\u2032 that) bs\nalignWith f as       []       = map (f \u2218\u2032 this) as\nalignWith f (a \u2237 as) (b \u2237 bs) = f (these a b) \u2237 alignWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\nzipWith f (x \u2237 xs) (y \u2237 ys) = f x y \u2237 zipWith f xs ys\nzipWith f _        _        = []\n\nunalignWith : (A \u2192 These B C) \u2192 List A \u2192 List B \u00d7 List C\nunalignWith f []       = [] , []\nunalignWith f (a \u2237 as) with f a\n... | this b    = Product.map\u2081 (b \u2237_) (unalignWith f as)\n... | that c    = Product.map\u2082 (c \u2237_) (unalignWith f as)\n... | these b c = Product.map (b \u2237_) (c \u2237_) (unalignWith f as)\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 List A \u2192 List B \u00d7 List C\nunzipWith f []         = [] , []\nunzipWith f (xy \u2237 xys) = Product.zip _\u2237_ _\u2237_ (f xy) (unzipWith f xys)\n\npartitionSumsWith : (A \u2192 B \u228e C) \u2192 List A \u2192 List B \u00d7 List C\npartitionSumsWith f = unalignWith (These.fromSum \u2218\u2032 f)\n\nalign : List A \u2192 List B \u2192 List (These A B)\nalign = alignWith id\n\nzip : List A \u2192 List B \u2192 List (A \u00d7 B)\nzip = zipWith (_,_)\n\nunalign : List (These A B) \u2192 List A \u00d7 List B\nunalign = unalignWith id\n\nunzip : List (A \u00d7 B) \u2192 List A \u00d7 List B\nunzip = unzipWith id\n\npartitionSums : List (A \u228e B) \u2192 List A \u00d7 List B\npartitionSums = partitionSumsWith id\n\nmerge : {R : Rel A \u2113} \u2192 B.Decidable R \u2192 List A \u2192 List A \u2192 List A\nmerge R? []           ys           = ys\nmerge R? xs           []           = xs\nmerge R? x\u2237xs@(x \u2237 xs) y\u2237ys@(y \u2237 ys) = if does (R? x y)\n  then x \u2237 merge R? xs   y\u2237ys\n  else y \u2237 merge R? x\u2237xs ys\n\n------------------------------------------------------------------------\n-- Operations for reducing lists\n\nfoldr : (A \u2192 B \u2192 B) \u2192 B \u2192 List A \u2192 B\nfoldr c n []       = n\nfoldr c n (x \u2237 xs) = c x (foldr c n xs)\n\nfoldl : (A \u2192 B \u2192 A) \u2192 A \u2192 List B \u2192 A\nfoldl c n []       = n\nfoldl c n (x \u2237 xs) = foldl c (c n x) xs\n\nconcat : List (List A) \u2192 List A\nconcat = foldr _++_ []\n\nconcatMap : (A \u2192 List B) \u2192 List A \u2192 List B\nconcatMap f = concat \u2218 map f\n\nap : List (A \u2192 B) \u2192 List A \u2192 List B\nap fs as = concatMap (flip map as) fs\n\ncatMaybes : List (Maybe A) \u2192 List A\ncatMaybes = foldr (maybe\u2032 _\u2237_ id) []\n\nmapMaybe : (A \u2192 Maybe B) \u2192 List A \u2192 List B\nmapMaybe p = catMaybes \u2218 map p\n\nnull : List A \u2192 Bool\nnull []       = true\nnull (x \u2237 xs) = false\n\nlength : List A \u2192 \u2115\nlength = foldr (const suc) 0\n\n------------------------------------------------------------------------\n-- Operations for constructing lists\n\n[_] : A \u2192 List A\n[ x ] = x \u2237 []\n\nfromMaybe : Maybe A \u2192 List A\nfromMaybe (just x) = [ x ]\nfromMaybe nothing  = []\n\nreplicate : \u2115 \u2192 A \u2192 List A\nreplicate zero    x = []\nreplicate (suc n) x = x \u2237 replicate n x\n\niterate : (A \u2192 A) \u2192 A \u2192 \u2115 \u2192 List A\niterate f e zero    = []\niterate f e (suc n) = e \u2237 iterate f (f e) n\n\ninits : List A \u2192 List (List A)\ninits {A = A} = \u03bb xs \u2192 [] \u2237 tail xs\n  module Inits where\n    tail : List A \u2192 List (List A)\n    tail []       = []\n    tail (x \u2237 xs) = [ x ] \u2237 map (x \u2237_) (tail xs)\n\ntails : List A \u2192 List (List A)\ntails {A = A} = \u03bb xs \u2192 xs \u2237 tail xs\n  module Tails where\n    tail : List A \u2192 List (List A)\n    tail []       = []\n    tail (_ \u2237 xs) = xs \u2237 tail xs\n\ninsertAt : (xs : List A) \u2192 Fin (suc (length xs)) \u2192 A \u2192 List A\ninsertAt xs       zero    v = v \u2237 xs\ninsertAt (x \u2237 xs) (suc i) v = x \u2237 insertAt xs i v\n\nupdateAt : (xs : List A) \u2192 Fin (length xs) \u2192 (A \u2192 A) \u2192 List A\nupdateAt (x \u2237 xs) zero    f = f x \u2237 xs\nupdateAt (x \u2237 xs) (suc i) f = x \u2237 updateAt xs i f\n\n-- Tabulation\n\napplyUpTo : (\u2115 \u2192 A) \u2192 \u2115 \u2192 List A\napplyUpTo f zero    = []\napplyUpTo f (suc n) = f zero \u2237 applyUpTo (f \u2218 suc) n\n\napplyDownFrom : (\u2115 \u2192 A) \u2192 \u2115 \u2192 List A\napplyDownFrom f zero    = []\napplyDownFrom f (suc n) = f n \u2237 applyDownFrom f n\n\ntabulate : \u2200 {n} (f : Fin n \u2192 A) \u2192 List A\ntabulate {n = zero}  f = []\ntabulate {n = suc n} f = f zero \u2237 tabulate (f \u2218 suc)\n\nlookup : \u2200 (xs : List A) \u2192 Fin (length xs) \u2192 A\nlookup (x \u2237 xs) zero    = x\nlookup (x \u2237 xs) (suc i) = lookup xs i\n\n-- Numerical\n\nupTo : \u2115 \u2192 List \u2115\nupTo = applyUpTo id\n\ndownFrom : \u2115 \u2192 List \u2115\ndownFrom = applyDownFrom id\n\nallFin : \u2200 n \u2192 List (Fin n)\nallFin n = tabulate id\n\nunfold : \u2200 (P : \u2115 \u2192 Set b)\n         (f : \u2200 {n} \u2192 P (suc n) \u2192 Maybe (A \u00d7 P n)) \u2192\n         \u2200 {n} \u2192 P n \u2192 List A\nunfold P f {n = zero}  s = []\nunfold P f {n = suc n} s = maybe\u2032 (\u03bb (x , s\u2032) \u2192 x \u2237 unfold P f s\u2032) [] (f s)\n\n------------------------------------------------------------------------\n-- Operations for reversing lists\n\nreverseAcc : List A \u2192 List A \u2192 List A\nreverseAcc = foldl (flip _\u2237_)\n\nreverse : List A \u2192 List A\nreverse = reverseAcc []\n\n-- \"Reverse append\" xs \u02b3++ ys = reverse xs ++ ys\n\ninfixr 5 _\u02b3++_\n\n_\u02b3++_ : List A \u2192 List A \u2192 List A\n_\u02b3++_ = flip reverseAcc\n\n-- Snoc: Cons, but from the right.\n\ninfixl 6 _\u2237\u02b3_\n\n_\u2237\u02b3_ : List A \u2192 A \u2192 List A\nxs \u2237\u02b3 x = xs ++ [ x ]\n\n\n\n-- Backwards initialisation\n\ninfixl 5 _\u2237\u02b3\u2032_\n\ndata InitLast {A : Set a} : List A \u2192 Set a where\n  []    : InitLast []\n  _\u2237\u02b3\u2032_ : (xs : List A) (x : A) \u2192 InitLast (xs \u2237\u02b3 x)\n\ninitLast : (xs : List A) \u2192 InitLast xs\ninitLast []               = []\ninitLast (x \u2237 xs)         with initLast xs\n... | []       = [] \u2237\u02b3\u2032 x\n... | ys \u2237\u02b3\u2032 y = (x \u2237 ys) \u2237\u02b3\u2032 y\n\n-- uncons, but from the right\nunsnoc : List A \u2192 Maybe (List A \u00d7 A)\nunsnoc as with initLast as\n... | []       = nothing\n... | xs \u2237\u02b3\u2032 x = just (xs , x)\n\n------------------------------------------------------------------------\n-- Operations for deconstructing lists\n\n-- Note that although the following three combinators can be useful for\n-- programming, when proving it is often a better idea to manually\n-- destruct a list argument as each branch of the pattern-matching will\n-- have a refined type.\n\nuncons : List A \u2192 Maybe (A \u00d7 List A)\nuncons []       = nothing\nuncons (x \u2237 xs) = just (x , xs)\n\nhead : List A \u2192 Maybe A\nhead []      = nothing\nhead (x \u2237 _) = just x\n\ntail : List A \u2192 Maybe (List A)\ntail []       = nothing\ntail (_ \u2237 xs) = just xs\n\nlast : List A \u2192 Maybe A\nlast []       = nothing\nlast (x \u2237 []) = just x\nlast (_ \u2237 xs) = last xs\n\ntake : \u2115 \u2192 List A \u2192 List A\ntake zero    xs       = []\ntake (suc n) []       = []\ntake (suc n) (x \u2237 xs) = x \u2237 take n xs\n\ndrop : \u2115 \u2192 List A \u2192 List A\ndrop zero    xs       = xs\ndrop (suc n) []       = []\ndrop (suc n) (x \u2237 xs) = drop n xs\n\nsplitAt : \u2115 \u2192 List A \u2192 List A \u00d7 List A\nsplitAt zero    xs       = ([] , xs)\nsplitAt (suc n) []       = ([] , [])\nsplitAt (suc n) (x \u2237 xs) = Product.map\u2081 (x \u2237_) (splitAt n xs)\n\nremoveAt : (xs : List A) \u2192 Fin (length xs) \u2192 List A\nremoveAt (x \u2237 xs) zero     = xs\nremoveAt (x \u2237 xs) (suc i)  = x \u2237 removeAt xs i\n\n------------------------------------------------------------------------\n-- Operations for filtering lists\n\n-- The following are a variety of functions that can be used to\n-- construct sublists using a predicate.\n--\n-- Each function has two forms. The first main variant uses a\n-- proof-relevant decidable predicate, while the second variant uses\n-- a irrelevant boolean predicate and are suffixed with a `\u1d47` character,\n-- typed as \\^b.\n--\n-- The decidable versions have several advantages: 1) easier to prove\n-- properties, 2) better meta-variable inference and 3) most of the rest\n-- of the library is set-up to work with decidable predicates. However,\n-- in rare cases the boolean versions can be useful, mainly when one\n-- wants to minimise dependencies.\n--\n-- In summary, in most cases you probably want to use the decidable\n-- versions over the boolean versions, e.g. use `takeWhile (_\u2264? 10) xs`\n-- rather than `takeWhile\u1d47 (_\u2264\u1d47 10) xs`.\n\ntakeWhile : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\ntakeWhile P? []       = []\ntakeWhile P? (x \u2237 xs) with does (P? x)\n... | true  = x \u2237 takeWhile P? xs\n... | false = []\n\ntakeWhile\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\ntakeWhile\u1d47 p = takeWhile (T? \u2218 p)\n\ndropWhile : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\ndropWhile P? []       = []\ndropWhile P? (x \u2237 xs) with does (P? x)\n... | true  = dropWhile P? xs\n... | false = x \u2237 xs\n\ndropWhile\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\ndropWhile\u1d47 p = dropWhile (T? \u2218 p)\n\nfilter : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\nfilter P? [] = []\nfilter P? (x \u2237 xs) with does (P? x)\n... | false = filter P? xs\n... | true  = x \u2237 filter P? xs\n\nfilter\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\nfilter\u1d47 p = filter (T? \u2218 p)\n\npartition : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\npartition P? []       = ([] , [])\npartition P? (x \u2237 xs) with does (P? x) | partition P? xs\n... | true  | (ys , zs) = (x \u2237 ys , zs)\n... | false | (ys , zs) = (ys , x \u2237 zs)\n\npartition\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\npartition\u1d47 p = partition (T? \u2218 p)\n\nspan : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\nspan P? []       = ([] , [])\nspan P? ys@(x \u2237 xs) with does (P? x)\n... | true  = Product.map (x \u2237_) id (span P? xs)\n... | false = ([] , ys)\n\n\nspan\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\nspan\u1d47 p = span (T? \u2218 p)\n\nbreak : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\nbreak P? = span (\u00ac? \u2218 P?)\n\nbreak\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\nbreak\u1d47 p = break (T? \u2218 p)\n\n-- The predicate `P` represents the notion of newline character for the\n-- type `A`. It is used to split the input list into a list of lines.\n-- Some lines may be empty if the input contains at least two\n-- consecutive newline characters.\nlinesBy : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List A)\nlinesBy {A = A} P? = go nothing where\n\n  go : Maybe (List A) \u2192 List A \u2192 List (List A)\n  go acc []       = maybe\u2032 ([_] \u2218\u2032 reverse) [] acc\n  go acc (c \u2237 cs) = if does (P? c)\n    then reverse acc\u2032 \u2237 go nothing cs\n    else go (just (c \u2237 acc\u2032)) cs\n    where acc\u2032 = Maybe.fromMaybe [] acc\n\nlinesBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List A)\nlinesBy\u1d47 p = linesBy (T? \u2218 p)\n\n-- The predicate `P` represents the notion of space character for the\n-- type `A`. It is used to split the input list into a list of words.\n-- All the words are non empty and the output does not contain any space\n-- characters.\nwordsBy : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List A)\nwordsBy {A = A} P? = go [] where\n\n  cons : List A \u2192 List (List A) \u2192 List (List A)\n  cons [] ass = ass\n  cons as ass = reverse as \u2237 ass\n\n  go : List A \u2192 List A \u2192 List (List A)\n  go acc []       = cons acc []\n  go acc (c \u2237 cs) = if does (P? c)\n    then cons acc (go [] cs)\n    else go (c \u2237 acc) cs\n\nwordsBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List A)\nwordsBy\u1d47 p = wordsBy (T? \u2218 p)\n\nderun : \u2200 {R : Rel A p} \u2192 B.Decidable R \u2192 List A \u2192 List A\nderun R? [] = []\nderun R? (x \u2237 []) = x \u2237 []\nderun R? (x \u2237 xs@(y \u2237 _)) with does (R? x y) | derun R? xs\n... | true  | ys = ys\n... | false | ys = x \u2237 ys\n\nderun\u1d47 : (A \u2192 A \u2192 Bool) \u2192 List A \u2192 List A\nderun\u1d47 r = derun (T? \u2218\u2082 r)\n\ndeduplicate : \u2200 {R : Rel A p} \u2192 B.Decidable R \u2192 List A \u2192 List A\ndeduplicate R? [] = []\ndeduplicate R? (x \u2237 xs) = x \u2237 filter (\u00ac? \u2218 R? x) (deduplicate R? xs)\n\ndeduplicate\u1d47 : (A \u2192 A \u2192 Bool) \u2192 List A \u2192 List A\ndeduplicate\u1d47 r = deduplicate (T? \u2218\u2082 r)\n\n-- Finds the first element satisfying the boolean predicate\nfind : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 Maybe A\nfind P? []       = nothing\nfind P? (x \u2237 xs) = if does (P? x) then just x else find P? xs\n\nfind\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 Maybe A\nfind\u1d47 p = find (T? \u2218 p)\n\n-- Finds the index of the first element satisfying the boolean predicate\nfindIndex : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 (xs : List A) \u2192 Maybe $ Fin (length xs)\nfindIndex P? [] = nothing\nfindIndex P? (x \u2237 xs) = if does (P? x)\n  then just zero\n  else Maybe.map suc (findIndex P? xs)\n\nfindIndex\u1d47 : (A \u2192 Bool) \u2192 (xs : List A) \u2192 Maybe $ Fin (length xs)\nfindIndex\u1d47 p = findIndex (T? \u2218 p)\n\n-- Finds indices of all the elements satisfying the boolean predicate\nfindIndices : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 (xs : List A) \u2192 List $ Fin (length xs)\nfindIndices P? []       = []\nfindIndices P? (x \u2237 xs) = if does (P? x)\n  then zero \u2237 indices\n  else indices\n    where indices = map suc (findIndices P? xs)\n\nfindIndices\u1d47 : (A \u2192 Bool) \u2192 (xs : List A) \u2192 List $ Fin (length xs)\nfindIndices\u1d47 p = findIndices (T? \u2218 p)\n\n------------------------------------------------------------------------\n-- Actions on single elements\n\ninfixl 5 _[_]%=_ _[_]\u2237=_\n\n-- xs [ i ]%= f  modifies the i-th element of xs according to f\n\n_[_]%=_ : (xs : List A) \u2192 Fin (length xs) \u2192 (A \u2192 A) \u2192 List A\nxs [ i ]%= f = updateAt xs i f\n\n-- xs [ i ]\u2254 y  overwrites the i-th element of xs with y\n\n_[_]\u2237=_ : (xs : List A) \u2192 Fin (length xs) \u2192 A \u2192 List A\nxs [ k ]\u2237= v = xs [ k ]%= const v\n\n------------------------------------------------------------------------\n-- Conditional versions of cons and snoc\n\ninfixr 5 _?\u2237_\n_?\u2237_ : Maybe A \u2192 List A \u2192 List A\n_?\u2237_ = maybe\u2032 _\u2237_ id\n\ninfixl 6 _\u2237\u02b3?_\n_\u2237\u02b3?_ : List A \u2192 Maybe A \u2192 List A\nxs \u2237\u02b3? x = maybe\u2032 (xs \u2237\u02b3_) xs x\n\n------------------------------------------------------------------------\n-- Raw algebraic bundles\n\nmodule _ (A : Set a) where\n  ++-rawMagma : RawMagma a _\n  ++-rawMagma = record\n    { Carrier = List A\n    ; _\u2248_ = _\u2261_\n    ; _\u2219_ = _++_\n    }\n\n  ++-[]-rawMonoid : RawMonoid a _\n  ++-[]-rawMonoid = record\n    { Carrier = List A\n    ; _\u2248_ = _\u2261_\n    ; _\u2219_ = _++_\n    ; \u03b5 = []\n    }\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.4\n\ninfixl 5 _\u2237\u02b3'_\n_\u2237\u02b3'_ : (xs : List A) (x : A) \u2192 InitLast (xs \u2237\u02b3 x)\n_\u2237\u02b3'_ = InitLast._\u2237\u02b3\u2032_\n{-# WARNING_ON_USAGE _\u2237\u02b3'_\n\"Warning: _\u2237\u02b3'_ (ending in an apostrophe) was deprecated in v1.4.\nPlease use _\u2237\u02b3\u2032_ (ending in a prime) instead.\"\n#-}\n\n-- Version 2.0\n\ninfixl 5 _\u2500_\n_\u2500_ = removeAt\n{-# WARNING_ON_USAGE _\u2500_\n\"Warning: _\u2500_ was deprecated in v2.0.\nPlease use removeAt instead.\"\n#-}\n\n-- Version 2.1\n\nscanr : (A \u2192 B \u2192 B) \u2192 B \u2192 List A \u2192 List B\nscanr f e []       = e \u2237 []\nscanr f e (x \u2237 xs) with scanr f e xs\n... | []         = []                -- dead branch\n... | ys@(y \u2237 _) = f x y \u2237 ys\n{-# WARNING_ON_USAGE scanr\n\"Warning: scanr was deprecated in v2.1.\nPlease use Data.List.Scans.Base.scanr instead.\"\n#-}\n\nscanl : (A \u2192 B \u2192 A) \u2192 A \u2192 List B \u2192 List A\nscanl f e []       = e \u2237 []\nscanl f e (x \u2237 xs) = e \u2237 scanl f (f e x) xs\n{-# WARNING_ON_USAGE scanl\n\"Warning: scanl was deprecated in v2.1.\nPlease use Data.List.Scans.Base.scanl instead.\"\n#-}\n\n-- Version 2.3\n\nand : List Bool \u2192 Bool\nand = foldr _\u2227_ true\n\nall : (A \u2192 Bool) \u2192 List A \u2192 Bool\nall p = and \u2218 map p\n{-# WARNING_ON_USAGE and\n\"Warning: and was deprecated in v2.3.\nPlease use Data.Bool.ListAction.and instead.\"\n#-}\n{-# WARNING_ON_USAGE all\n\"Warning: all was deprecated in v2.3.\nPlease use Data.Nat.ListAction.all instead.\"\n#-}\n\nor : List Bool \u2192 Bool\nor = foldr _\u2228_ false\n\nany : (A \u2192 Bool) \u2192 List A \u2192 Bool\nany p = or \u2218 map p\n{-# WARNING_ON_USAGE or\n\"Warning: or was deprecated in v2.3.\nPlease use Data.Bool.ListAction.or instead.\"\n#-}\n{-# WARNING_ON_USAGE any\n\"Warning: any was deprecated in v2.3.\nPlease use Data.Bool.ListAction.any instead.\"\n#-}\n\nsum : List \u2115 \u2192 \u2115\nsum = foldr \u2115._+_ 0\n{-# WARNING_ON_USAGE sum\n\"Warning: sum was deprecated in v2.3.\nPlease use Data.Nat.ListAction.sum instead.\"\n#-}\n\nproduct : List \u2115 \u2192 \u2115\nproduct = foldr \u2115._*_ 1\n{-# WARNING_ON_USAGE product\n\"Warning: product was deprecated in v2.3.\nPlease use Data.Nat.ListAction.product instead.\"\n#-}\n</pre>"},{"location":"md/Data/List/NonEmpty/Base/","title":"Data.List.NonEmpty.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Non-empty lists: base type and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.NonEmpty.Base where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool; false; true)\nopen import Data.List.Base as List using (List; []; _\u2237_)\nopen import Data.Maybe.Base using (Maybe ; nothing; just)\nopen import Data.Nat.Base as \u2115 using (\u2115; suc; zero; pred)\nopen import Data.Product.Base as Prod using (\u2203; _\u00d7_; proj\u2081; proj\u2082; _,_; -,_)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Data.Vec.Base as Vec using (Vec; []; _\u2237_)\nopen import Function.Base using (id; _\u2218\u2032_; _\u2218_; const)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl)\nopen import Relation.Unary using (Pred; Decidable; U; \u2205)\nopen import Relation.Unary.Properties using (U?; \u2205?)\nopen import Relation.Nullary.Decidable using (does)\n\nprivate\n  variable\n    a p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 5 _\u2237_\n\nrecord List\u207a (A : Set a) : Set a where\n  constructor _\u2237_\n  field\n    head : A\n    tail : List A\n\nopen List\u207a public\n\n------------------------------------------------------------------------\n-- Basic combinators\n\nuncons : List\u207a A \u2192 A \u00d7 List A\nuncons (hd \u2237 tl) = hd , tl\n\n[_] : A \u2192 List\u207a A\n[ x ] = x \u2237 []\n\ninfixr 5 _\u2237\u207a_\n\n_\u2237\u207a_ : A \u2192 List\u207a A \u2192 List\u207a A\nx \u2237\u207a y \u2237 xs = x \u2237 y \u2237 xs\n\nlength : List\u207a A \u2192 \u2115\nlength (x \u2237 xs) = suc (List.length xs)\n\n------------------------------------------------------------------------\n-- Conversion\n\ntoList : List\u207a A \u2192 List A\ntoList (x \u2237 xs) = x \u2237 xs\n\nfromList : List A \u2192 Maybe (List\u207a A)\nfromList []       = nothing\nfromList (x \u2237 xs) = just (x \u2237 xs)\n\nfromVec : \u2200 {n} \u2192 Vec A (suc n) \u2192 List\u207a A\nfromVec (x \u2237 xs) = x \u2237 Vec.toList xs\n\ntoVec : (xs : List\u207a A) \u2192 Vec A (length xs)\ntoVec (x \u2237 xs) = x \u2237 Vec.fromList xs\n\nlift : (\u2200 {m} \u2192 Vec A (suc m) \u2192 \u2203 \u03bb n \u2192 Vec B (suc n)) \u2192\n       List\u207a A \u2192 List\u207a B\nlift f xs = fromVec (proj\u2082 (f (toVec xs)))\n\n------------------------------------------------------------------------\n-- Other operations\n\nmap : (A \u2192 B) \u2192 List\u207a A \u2192 List\u207a B\nmap f (x \u2237 xs) = (f x \u2237 List.map f xs)\n\nreplicate : \u2200 n \u2192 n \u2262 0 \u2192 A \u2192 List\u207a A\nreplicate n n\u22620 a = a \u2237 List.replicate (pred n) a\n\n-- when dropping more than the size of the length of the list, the\n-- last element remains\ndrop+ : \u2115 \u2192 List\u207a A \u2192 List\u207a A\ndrop+ zero    xs           = xs\ndrop+ (suc n) (x \u2237 [])     = x \u2237 []\ndrop+ (suc n) (x \u2237 y \u2237 xs) = drop+ n (y \u2237 xs)\n\n-- Right fold. Note that s is only applied to the last element (see\n-- the examples below).\n\nfoldr : (A \u2192 B \u2192 B) \u2192 (A \u2192 B) \u2192 List\u207a A \u2192 B\nfoldr {A = A} {B = B} c s (x \u2237 xs) = foldr\u2032 x xs\n  where\n  foldr\u2032 : A \u2192 List A \u2192 B\n  foldr\u2032 x []       = s x\n  foldr\u2032 x (y \u2237 xs) = c x (foldr\u2032 y xs)\n\n-- Right fold.\n\nfoldr\u2081 : (A \u2192 A \u2192 A) \u2192 List\u207a A \u2192 A\nfoldr\u2081 f = foldr f id\n\n-- Left fold. Note that s is only applied to the first element (see\n-- the examples below).\n\nfoldl : (B \u2192 A \u2192 B) \u2192 (A \u2192 B) \u2192 List\u207a A \u2192 B\nfoldl c s (x \u2237 xs) = List.foldl c (s x) xs\n\n-- Left fold.\n\nfoldl\u2081 : (A \u2192 A \u2192 A) \u2192 List\u207a A \u2192 A\nfoldl\u2081 f = foldl f id\n\n-- Append (several variants).\n\ninfixr 5 _\u207a++\u207a_ _++\u207a_ _\u207a++_\n\n_\u207a++\u207a_ : List\u207a A \u2192 List\u207a A \u2192 List\u207a A\n(x \u2237 xs) \u207a++\u207a (y \u2237 ys) = x \u2237 (xs List.++ y \u2237 ys)\n\n_\u207a++_ : List\u207a A \u2192 List A \u2192 List\u207a A\n(x \u2237 xs) \u207a++ ys = x \u2237 (xs List.++ ys)\n\n_++\u207a_ : List A \u2192 List\u207a A \u2192 List\u207a A\nxs ++\u207a ys = List.foldr _\u2237\u207a_ ys xs\n\nconcat : List\u207a (List\u207a A) \u2192 List\u207a A\nconcat (xs \u2237 xss) = xs \u207a++ List.concat (List.map toList xss)\n\nconcatMap : (A \u2192 List\u207a B) \u2192 List\u207a A \u2192 List\u207a B\nconcatMap f = concat \u2218\u2032 map f\n\nap : List\u207a (A \u2192 B) \u2192 List\u207a A \u2192 List\u207a B\nap fs as = concatMap (\u03bb f \u2192 map f as) fs\n\n-- Inits\n\ninits : List A \u2192 List\u207a (List A)\ninits xs = [] \u2237 List.Inits.tail xs\n\n-- Tails\n\ntails : List A \u2192 List\u207a (List A)\ntails xs = xs \u2237 List.Tails.tail xs\n\n-- Reverse\n\nreverse : List\u207a A \u2192 List\u207a A\nreverse = lift (-,_ \u2218\u2032 Vec.reverse)\n\n-- Align and Zip\n\nalignWith : (These A B \u2192 C) \u2192 List\u207a A \u2192 List\u207a B \u2192 List\u207a C\nalignWith f (a \u2237 as) (b \u2237 bs) = f (these a b) \u2237 List.alignWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 List\u207a A \u2192 List\u207a B \u2192 List\u207a C\nzipWith f (a \u2237 as) (b \u2237 bs) = f a b \u2237 List.zipWith f as bs\n\nunalignWith : (A \u2192 These B C) \u2192 List\u207a A \u2192 These (List\u207a B) (List\u207a C)\nunalignWith f = foldr (These.alignWith mcons mcons \u2218\u2032 f)\n                    (These.map [_] [_] \u2218\u2032 f)\n\n  where mcons : \u2200 {e} {E : Set e} \u2192 These E (List\u207a E) \u2192 List\u207a E\n        mcons = These.fold [_] id _\u2237\u207a_\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 List\u207a A \u2192 List\u207a B \u00d7 List\u207a C\nunzipWith f (a \u2237 as) = Prod.zip _\u2237_ _\u2237_ (f a) (List.unzipWith f as)\n\nalign : List\u207a A \u2192 List\u207a B \u2192 List\u207a (These A B)\nalign = alignWith id\n\nzip : List\u207a A \u2192 List\u207a B \u2192 List\u207a (A \u00d7 B)\nzip = zipWith _,_\n\nunalign : List\u207a (These A B) \u2192 These (List\u207a A) (List\u207a B)\nunalign = unalignWith id\n\nunzip : List\u207a (A \u00d7 B) \u2192 List\u207a A \u00d7 List\u207a B\nunzip = unzipWith id\n\n-- Snoc.\n\ninfixl 5 _\u2237\u02b3_ _\u207a\u2237\u02b3_\n\n_\u2237\u02b3_ : List A \u2192 A \u2192 List\u207a A\n[]       \u2237\u02b3 y = [ y ]\n(x \u2237 xs) \u2237\u02b3 y = x \u2237 (xs List.\u2237\u02b3 y)\n\n_\u207a\u2237\u02b3_ : List\u207a A \u2192 A \u2192 List\u207a A\nxs \u207a\u2237\u02b3 x = toList xs \u2237\u02b3 x\n\n-- A snoc-view of non-empty lists.\n\ninfixl 5 _\u2237\u02b3\u2032_\n\ndata SnocView {A : Set a} : List\u207a A \u2192 Set a where\n  _\u2237\u02b3\u2032_ : (xs : List A) (x : A) \u2192 SnocView (xs \u2237\u02b3 x)\n\nsnocView : (xs : List\u207a A) \u2192 SnocView xs\nsnocView (x \u2237 xs)              with List.initLast xs\nsnocView (x \u2237 .[])             | []            = []       \u2237\u02b3\u2032 x\nsnocView (x \u2237 .(xs List.\u2237\u02b3 y)) | xs List.\u2237\u02b3\u2032 y = (x \u2237 xs) \u2237\u02b3\u2032 y\n\n-- The last element in the list.\n\nprivate\n  last\u2032 : \u2200 {l} \u2192 SnocView {A = A} l \u2192 A\n  last\u2032 (_ \u2237\u02b3\u2032 y) = y\n\nlast : List\u207a A \u2192 A\nlast = last\u2032 \u2218 snocView\n\n-- Groups all contiguous elements for which the predicate returns the\n-- same result into lists. The left sums are the ones for which the\n-- predicate holds, the right ones are the ones for which it doesn't.\ngroupSeqs\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List\u207a A \u228e List\u207a A)\ngroupSeqs\u1d47 p []       = []\ngroupSeqs\u1d47 p (x \u2237 xs) with p x | groupSeqs\u1d47 p xs\n... | true  | inj\u2081 xs\u2032 \u2237 xss = inj\u2081 (x \u2237\u207a xs\u2032) \u2237 xss\n... | true  | xss            = inj\u2081 [ x ]      \u2237 xss\n... | false | inj\u2082 xs\u2032 \u2237 xss = inj\u2082 (x \u2237\u207a xs\u2032) \u2237 xss\n... | false | xss            = inj\u2082 [ x ]      \u2237 xss\n\n-- Groups all contiguous elements /not/ satisfying the predicate into\n-- lists. Elements satisfying the predicate are dropped.\nwordsBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List\u207a A)\nwordsBy\u1d47 p = List.mapMaybe Sum.[ const nothing , just ] \u2218 groupSeqs\u1d47 p\n\ngroupSeqs : {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List\u207a A \u228e List\u207a A)\ngroupSeqs P? = groupSeqs\u1d47 (does \u2218 P?)\n\nwordsBy : {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List\u207a A)\nwordsBy P? = wordsBy\u1d47 (does \u2218 P?)\n\n-- Inverse operation for groupSequences.\nungroupSeqs : List (List\u207a A \u228e List\u207a A) \u2192 List A\nungroupSeqs = List.concat \u2218 List.map Sum.[ toList , toList ]\n\n------------------------------------------------------------------------\n-- Examples\n\n-- Note that these examples are simple unit tests, because the type\n-- checker verifies them.\n\nprivate\n module Examples {A B : Set}\n                 (_\u2295_ : A \u2192 B \u2192 B)\n                 (_\u2297_ : B \u2192 A \u2192 B)\n                 (_\u2299_ : A \u2192 A \u2192 A)\n                 (f : A \u2192 B)\n                 (a b c : A)\n                 where\n\n  hd : head (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 a\n  hd = refl\n\n  tl : tail (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 b \u2237 c \u2237 []\n  tl = refl\n\n  mp : map f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 f a \u2237\u207a f b \u2237\u207a [ f c ]\n  mp = refl\n\n  right : foldr _\u2295_ f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 (a \u2295 (b \u2295 f c))\n  right = refl\n\n  right\u2081 : foldr\u2081 _\u2299_ (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 (a \u2299 (b \u2299 c))\n  right\u2081 = refl\n\n  left : foldl _\u2297_ f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 ((f a \u2297 b) \u2297 c)\n  left = refl\n\n  left\u2081 : foldl\u2081 _\u2299_ (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 ((a \u2299 b) \u2299 c)\n  left\u2081 = refl\n\n  \u207aapp\u207a : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a++\u207a (b \u2237\u207a [ c ]) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  \u207aapp\u207a = refl\n\n  \u207aapp : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a++ (b \u2237 c \u2237 []) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  \u207aapp = refl\n\n  app\u207a : (a \u2237 b \u2237 c \u2237 []) ++\u207a (b \u2237\u207a [ c ]) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  app\u207a = refl\n\n  conc : concat ((a \u2237\u207a b \u2237\u207a [ c ]) \u2237\u207a [ b \u2237\u207a [ c ] ]) \u2261\n         a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  conc = refl\n\n  rev : reverse (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 c \u2237\u207a b \u2237\u207a [ a ]\n  rev = refl\n\n  snoc : (a \u2237 b \u2237 c \u2237 []) \u2237\u02b3 a \u2261 a \u2237\u207a b \u2237\u207a c \u2237\u207a [ a ]\n  snoc = refl\n\n  snoc\u207a : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a\u2237\u02b3 a \u2261 a \u2237\u207a b \u2237\u207a c \u2237\u207a [ a ]\n  snoc\u207a = refl\n\n  groupSeqs-true : groupSeqs U? (a \u2237 b \u2237 c \u2237 []) \u2261\n               inj\u2081 (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  groupSeqs-true = refl\n\n  groupSeqs-false : groupSeqs \u2205? (a \u2237 b \u2237 c \u2237 []) \u2261\n                inj\u2082 (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  groupSeqs-false = refl\n\n  groupSeqs-\u22611 : groupSeqs\u1d47 (\u2115._\u2261\u1d47 1) (1 \u2237 2 \u2237 3 \u2237 1 \u2237 1 \u2237 2 \u2237 1 \u2237 []) \u2261\n                 inj\u2081 [ 1 ] \u2237\n                 inj\u2082 (2 \u2237\u207a [ 3 ]) \u2237\n                 inj\u2081 (1 \u2237\u207a [ 1 ]) \u2237\n                 inj\u2082 [ 2 ] \u2237\n                 inj\u2081 [ 1 ] \u2237\n                 []\n  groupSeqs-\u22611 = refl\n\n  wordsBy-true : wordsBy\u1d47 (const true) (a \u2237 b \u2237 c \u2237 []) \u2261 []\n  wordsBy-true = refl\n\n  wordsBy-false : wordsBy\u1d47 (const false) (a \u2237 b \u2237 c \u2237 []) \u2261\n                  (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  wordsBy-false = refl\n\n  wordsBy-\u22611 : wordsBy\u1d47 (\u2115._\u2261\u1d47 1) (1 \u2237 2 \u2237 3 \u2237 1 \u2237 1 \u2237 2 \u2237 1 \u2237 []) \u2261\n               (2 \u2237\u207a [ 3 ]) \u2237\n               [ 2 ] \u2237\n               []\n  wordsBy-\u22611 = refl\n</pre>"},{"location":"md/Data/List/Relation/Binary/Lex/Core/","title":"Data.List.Relation.Binary.Lex.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lexicographic ordering of lists\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Relation.Binary.Lex.Core where\n\nopen import Data.Empty using (\u22a5)\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082; uncurry)\nopen import Data.List.Base using (List; []; _\u2237_)\nopen import Function.Base using (_\u2218_; flip; id)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Binary.Core using (Rel)\nopen import Data.List.Relation.Binary.Pointwise.Base\n   using (Pointwise; []; _\u2237_; head; tail)\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 : Level\n\n-- The lexicographic ordering itself can be either strict or non-strict,\n-- depending on whether type P is inhabited.\n\ndata Lex {A : Set a} (P : Set)\n         (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) :\n         Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  base : P                             \u2192 Lex P _\u2248_ _\u227a_ []       []\n  halt : \u2200 {y ys}                      \u2192 Lex P _\u2248_ _\u227a_ []       (y \u2237 ys)\n  this : \u2200 {x xs y ys} (x\u227ay : x \u227a y)   \u2192 Lex P _\u2248_ _\u227a_ (x \u2237 xs) (y \u2237 ys)\n  next : \u2200 {x xs y ys} (x\u2248y : x \u2248 y)\n         (xs&lt;ys : Lex P _\u2248_ _\u227a_ xs ys) \u2192 Lex P _\u2248_ _\u227a_ (x \u2237 xs) (y \u2237 ys)\n\n------------------------------------------------------------------------\n-- Lexicographic orderings, using a strict ordering as the base\n\nLex-&lt; : {A : Set a} (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) \u2192\n        Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nLex-&lt; = Lex \u22a5\n\nLex-\u2264 : {A : Set a} (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) \u2192\n        Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nLex-\u2264 = Lex \u22a4\n</pre>"},{"location":"md/Data/List/Relation/Binary/Pointwise/Base/","title":"Data.List.Relation.Binary.Pointwise.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Pointwise lifting of relations to lists\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Relation.Binary.Pointwise.Base where\n\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; &lt;_,_&gt;; \u2203-syntax)\nopen import Data.List.Base using (List; []; _\u2237_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Core using (REL; _\u21d2_)\nopen import Relation.Binary.Construct.Composition using (_\u037e_)\n\nprivate\n  variable\n    a b c \u2113 : Level\n    A B : Set a\n    x y : A\n    xs ys : List A\n    R S : REL A B \u2113\n\n------------------------------------------------------------------------\n-- Definition\n------------------------------------------------------------------------\n\ninfixr 5 _\u2237_\n\ndata Pointwise {A : Set a} {B : Set b} (R : REL A B \u2113)\n               : List A \u2192 List B \u2192 Set (a \u2294 b \u2294 \u2113) where\n  []  : Pointwise R [] []\n  _\u2237_ : (x\u223cy : R x y) (xs\u223cys : Pointwise R xs ys) \u2192\n        Pointwise R (x \u2237 xs) (y \u2237 ys)\n\n------------------------------------------------------------------------\n-- Operations\n------------------------------------------------------------------------\n\nhead : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 R x y\nhead (x\u223cy \u2237 xs\u223cys) = x\u223cy\n\ntail : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 Pointwise R xs ys\ntail (x\u223cy \u2237 xs\u223cys) = xs\u223cys\n\nuncons : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 R x y \u00d7 Pointwise R xs ys\nuncons = &lt; head , tail &gt;\n\nrec : \u2200 (P : \u2200 {xs ys} \u2192 Pointwise R xs ys \u2192 Set c) \u2192\n      (\u2200 {x y xs ys} {Rxsys : Pointwise R xs ys} \u2192\n        (Rxy : R x y) \u2192 P Rxsys \u2192 P (Rxy \u2237 Rxsys)) \u2192\n      P [] \u2192\n      \u2200 {xs ys} (Rxsys : Pointwise R xs ys) \u2192 P Rxsys\nrec P c n []            = n\nrec P c n (Rxy \u2237 Rxsys) = c Rxy (rec P c n Rxsys)\n\nmap : R \u21d2 S \u2192 Pointwise R \u21d2 Pointwise S\nmap R\u21d2S []            = []\nmap R\u21d2S (Rxy \u2237 Rxsys) = R\u21d2S Rxy \u2237 map R\u21d2S Rxsys\n\nunzip : Pointwise (R \u037e S) \u21d2 (Pointwise R \u037e Pointwise S)\nunzip [] = [] , [] , []\nunzip ((y , r , s) \u2237 xs\u223cys) =\n  Product.map (y \u2237_) (Product.map (r \u2237_) (s \u2237_)) (unzip xs\u223cys)\n</pre>"},{"location":"md/Data/Maybe/Base/","title":"Data.Maybe.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The Maybe type and some operations\n------------------------------------------------------------------------\n\n-- The definitions in this file are reexported by Data.Maybe.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Maybe.Base where\n\nopen import Level using (Level; Lift)\nopen import Data.Bool.Base using (Bool; true; false; not)\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.These.Base using (These; this; that; these)\nopen import Data.Product.Base as Prod using (_\u00d7_; _,_)\nopen import Function.Base using (_\u2218_; id; const)\nimport Relation.Nullary.Decidable.Core as Dec\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\nopen import Agda.Builtin.Maybe public\n  using (Maybe; just; nothing)\n\n------------------------------------------------------------------------\n-- Some operations\n\nboolToMaybe : Bool \u2192 Maybe \u22a4\nboolToMaybe true  = just _\nboolToMaybe false = nothing\n\nis-just : Maybe A \u2192 Bool\nis-just (just _) = true\nis-just nothing  = false\n\nis-nothing : Maybe A \u2192 Bool\nis-nothing = not \u2218 is-just\n\n-- A dependent eliminator.\n\nmaybe : \u2200 {A : Set a} {B : Maybe A \u2192 Set b} \u2192\n        ((x : A) \u2192 B (just x)) \u2192 B nothing \u2192 (x : Maybe A) \u2192 B x\nmaybe j n (just x) = j x\nmaybe j n nothing  = n\n\n-- A non-dependent eliminator.\n\nmaybe\u2032 : (A \u2192 B) \u2192 B \u2192 Maybe A \u2192 B\nmaybe\u2032 = maybe\n\n-- A defaulting mechanism\n\nfromMaybe : A \u2192 Maybe A \u2192 A\nfromMaybe = maybe\u2032 id\n\n-- A safe variant of \"fromJust\". If the value is nothing, then the\n-- return type is the unit type.\n\nmodule _ {a} {A : Set a} where\n\n  From-just : Maybe A \u2192 Set a\n  From-just (just _) = A\n  From-just nothing  = Lift a \u22a4\n\n  from-just : (x : Maybe A) \u2192 From-just x\n  from-just (just x) = x\n  from-just nothing  = _\n\n-- Functoriality: map\n\nmap : (A \u2192 B) \u2192 Maybe A \u2192 Maybe B\nmap f = maybe (just \u2218 f) nothing\n\n-- Applicative: ap\n\nap : Maybe (A \u2192 B) \u2192 Maybe A \u2192 Maybe B\nap nothing  = const nothing\nap (just f) = map f\n\n-- Monad: bind\n\ninfixl 1 _&gt;&gt;=_\n_&gt;&gt;=_ : Maybe A \u2192 (A \u2192 Maybe B) \u2192 Maybe B\nnothing &gt;&gt;= f = nothing\njust a  &gt;&gt;= f = f a\n\n-- Alternative: &lt;\u2223&gt;\n\ninfixr 6 _&lt;\u2223&gt;_\n_&lt;\u2223&gt;_ : Maybe A \u2192 Maybe A \u2192 Maybe A\njust x  &lt;\u2223&gt; my = just x\nnothing &lt;\u2223&gt; my = my\n\n-- Just when the boolean is true\n\nwhen : Bool \u2192 A \u2192 Maybe A\nwhen b c = map (const c) (boolToMaybe b)\n\n------------------------------------------------------------------------\n-- Aligning and zipping\n\nalignWith : (These A B \u2192 C) \u2192 Maybe A \u2192 Maybe B \u2192 Maybe C\nalignWith f (just a) (just b) = just (f (these a b))\nalignWith f (just a) nothing  = just (f (this a))\nalignWith f nothing  (just b) = just (f (that b))\nalignWith f nothing  nothing  = nothing\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Maybe A \u2192 Maybe B \u2192 Maybe C\nzipWith f (just a) (just b) = just (f a b)\nzipWith _ _        _        = nothing\n\nalign : Maybe A \u2192 Maybe B \u2192 Maybe (These A B)\nalign = alignWith id\n\nzip : Maybe A \u2192 Maybe B \u2192 Maybe (A \u00d7 B)\nzip = zipWith _,_\n\n------------------------------------------------------------------------\n-- Injections.\n\nthisM : A \u2192 Maybe B \u2192 These A B\nthisM a = maybe\u2032 (these a) (this a)\n\nthatM : Maybe A \u2192 B \u2192 These A B\nthatM = maybe\u2032 these that\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.1\n-- decToMaybe\n\nopen Dec using (decToMaybe) public\n</pre>"},{"location":"md/Data/Nat/","title":"Data.Nat","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Natural numbers\n------------------------------------------------------------------------\n\n-- See README.Data.Nat for examples of how to use and reason about\n-- naturals.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Nat where\n\n------------------------------------------------------------------------\n-- Publicly re-export the contents of the base module\n\nopen import Data.Nat.Base public\n\n------------------------------------------------------------------------\n-- Publicly re-export queries\n\nopen import Data.Nat.Properties public\n  using\n  -- key values\n  ( nonZero?\n  -- equalities\n  ; _\u225f_ ; eq?\n  -- standard orders &amp; their relationship\n  ; _\u2264?_ ; _\u2265?_ ; _&lt;?_ ; _&gt;?_\n  ; \u2264-&lt;-connex ; \u2265-&gt;-connex ; &lt;-\u2264-connex ; &gt;-\u2265-connex\n  ; &lt;-cmp\n  -- alternative definitions of the orders\n  ; _\u2264\u2032?_; _\u2265\u2032?_; _&lt;\u2032?_; _&gt;\u2032?_\n  ; _\u2264\u2033?_; _&lt;\u2033?_; _\u2265\u2033?_; _&gt;\u2033?_\n  ; _&lt;\u2034?_; _\u2264\u2034?_; _\u2265\u2034?_; _&gt;\u2034?_\n  -- bounded predicates\n  ; anyUpTo? ; allUpTo?\n  )\n\n------------------------------------------------------------------------\n-- Deprecated\n\n-- Version 0.17\n\n-- Version 2.0\n\n-- solely for the re-export of this name, formerly in `Data.Nat.Properties.Core`\nopen import Data.Nat.Properties public\n  using (\u2264-pred)\n</pre>"},{"location":"md/Data/Nat/Base/","title":"Data.Nat.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Natural numbers, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.Nat for examples of how to use and reason about\n-- naturals.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Nat.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid; RawNearSemiring; RawSemiring)\nopen import Algebra.Definitions.RawMagma using (_\u2223\u02e1_; _,_)\nopen import Data.Bool.Base using (Bool; true; false; T; not)\nopen import Data.Parity.Base using (Parity; 0\u2119; 1\u2119)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl; cong)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Unary using (Pred)\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.Nat public\n  using (zero; suc) renaming (Nat to \u2115)\n\n--smart constructor\npattern 2+ n = suc (suc n)\n\n------------------------------------------------------------------------\n-- Boolean equality relation\n\nopen import Agda.Builtin.Nat public\n  using () renaming (_==_ to _\u2261\u1d47_)\n\n------------------------------------------------------------------------\n-- Boolean ordering relation\n\nopen import Agda.Builtin.Nat public\n  using () renaming (_&lt;_ to _&lt;\u1d47_)\n\ninfix 4 _\u2264\u1d47_\n_\u2264\u1d47_ : (m n : \u2115) \u2192 Bool\nzero  \u2264\u1d47 n = true\nsuc m \u2264\u1d47 n = m &lt;\u1d47 n\n\n------------------------------------------------------------------------\n-- Standard ordering relations\n\ninfix 4 _\u2264_ _&lt;_ _\u2265_ _&gt;_ _\u2270_ _\u226e_ _\u2271_ _\u226f_\n\ndata _\u2264_ : Rel \u2115 0\u2113 where\n  z\u2264n : \u2200 {n}                 \u2192 zero  \u2264 n\n  s\u2264s : \u2200 {m n} (m\u2264n : m \u2264 n) \u2192 suc m \u2264 suc n\n\n_&lt;_ : Rel \u2115 0\u2113\nm &lt; n = suc m \u2264 n\n\n-- Smart constructors of _&lt;_\n\npattern z&lt;s     {n}     = s\u2264s (z\u2264n {n})\npattern s&lt;s {m} {n} m&lt;n = s\u2264s {m} {n} m&lt;n\npattern sz&lt;ss   {n}     = s&lt;s (z&lt;s {n})\n\n-- Smart destructors of _\u2264_, _&lt;_\n\ns\u2264s\u207b\u00b9 : \u2200 {m n} \u2192 suc m \u2264 suc n \u2192 m \u2264 n\ns\u2264s\u207b\u00b9 (s\u2264s m\u2264n) = m\u2264n\n\ns&lt;s\u207b\u00b9 : \u2200 {m n} \u2192 suc m &lt; suc n \u2192 m &lt; n\ns&lt;s\u207b\u00b9 (s&lt;s m&lt;n) = m&lt;n\n\n\n------------------------------------------------------------------------\n-- Other derived ordering relations\n\n_\u2265_ : Rel \u2115 0\u2113\nm \u2265 n = n \u2264 m\n\n_&gt;_ : Rel \u2115 0\u2113\nm &gt; n = n &lt; m\n\n_\u2270_ : Rel \u2115 0\u2113\na \u2270 b = \u00ac a \u2264 b\n\n_\u226e_ : Rel \u2115 0\u2113\na \u226e b = \u00ac a &lt; b\n\n_\u2271_ : Rel \u2115 0\u2113\na \u2271 b = \u00ac a \u2265 b\n\n_\u226f_ : Rel \u2115 0\u2113\na \u226f b = \u00ac a &gt; b\n\n------------------------------------------------------------------------\n-- Simple predicates\n\n-- Defining these predicates in terms of `T` and therefore ultimately\n-- `\u22a4` and `\u22a5` allows Agda to automatically infer them for any natural\n-- of the correct form. Consequently in many circumstances this\n-- eliminates the need to explicitly pass a proof when the predicate\n-- argument is either an implicit or an instance argument. See `_/_`\n-- and `_%_` further down this file for examples.\n--\n-- Furthermore, defining these predicates as single-field records\n-- (rather defining them directly as the type of their field) is\n-- necessary as the current version of Agda is far better at\n-- reconstructing meta-variable values for the record parameters.\n\n-- A predicate saying that a number is not equal to 0.\n\nrecord NonZero (n : \u2115) : Set where\n  field\n    nonZero : T (not (n \u2261\u1d47 0))\n\n-- Instances\n\ninstance\n  nonZero : \u2200 {n} \u2192 NonZero (suc n)\n  nonZero = _\n\n-- Constructors\n\n\u2262-nonZero : \u2200 {n} \u2192 n \u2262 0 \u2192 NonZero n\n\u2262-nonZero {zero}  0\u22620 = contradiction refl 0\u22620\n\u2262-nonZero {suc n} n\u22620 = _\n\n&gt;-nonZero : \u2200 {n} \u2192 n &gt; 0 \u2192 NonZero n\n&gt;-nonZero z&lt;s = _\n\n-- Destructors\n\n\u2262-nonZero\u207b\u00b9 : \u2200 n \u2192 .{{NonZero n}} \u2192 n \u2262 0\n\u2262-nonZero\u207b\u00b9 (suc n) ()\n\n&gt;-nonZero\u207b\u00b9 : \u2200 n \u2192 .{{NonZero n}} \u2192 n &gt; 0\n&gt;-nonZero\u207b\u00b9 (suc n) = z&lt;s\n\n-- The property of being a non-zero, non-unit\n\nrecord NonTrivial (n : \u2115) : Set where\n  field\n    nonTrivial : T (1 &lt;\u1d47 n)\n\n-- Instances\n\ninstance\n  nonTrivial : \u2200 {n} \u2192 NonTrivial (2+ n)\n  nonTrivial = _\n\n-- Constructors\n\nn&gt;1\u21d2nonTrivial : \u2200 {n} \u2192 n &gt; 1 \u2192 NonTrivial n\nn&gt;1\u21d2nonTrivial sz&lt;ss = _\n\n-- Destructors\n\nnonTrivial\u21d2nonZero : \u2200 n \u2192 .{{NonTrivial n}} \u2192 NonZero n\nnonTrivial\u21d2nonZero (2+ _) = _\n\nnonTrivial\u21d2n&gt;1 : \u2200 n \u2192 .{{NonTrivial n}} \u2192 n &gt; 1\nnonTrivial\u21d2n&gt;1 (2+ _) = sz&lt;ss\n\nnonTrivial\u21d2\u22621 : \u2200 {n} \u2192 .{{NonTrivial n}} \u2192 n \u2262 1\nnonTrivial\u21d2\u22621 {{()}} refl\n\n------------------------------------------------------------------------\n-- Raw bundles\n\nopen import Agda.Builtin.Nat public\n  using (_+_; _*_) renaming (_-_ to _\u2238_)\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; \u03b5   = 0\n  }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = 1\n  }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\n  ; 1# = 1\n  }\n\n------------------------------------------------------------------------\n-- Arithmetic\n\nopen import Agda.Builtin.Nat\n  using (div-helper; mod-helper)\n\npred : \u2115 \u2192 \u2115\npred n = n \u2238 1\n\ninfix  8 _!\ninfixl 7 _\u2293_ _\u2293\u2032_ _/_ _%_\ninfixl 6 _+\u22ce_ _\u2294_ _\u2294\u2032_\n\n-- Argument-swapping addition. Used by Data.Vec._\u22ce_.\n\n_+\u22ce_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  +\u22ce n = n\nsuc m +\u22ce n = suc (n +\u22ce m)\n\n-- Max.\n\n_\u2294_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  \u2294 n     = n\nsuc m \u2294 zero  = suc m\nsuc m \u2294 suc n = suc (m \u2294 n)\n\n-- Max defined in terms of primitive operations.\n-- This is much faster than `_\u2294_` but harder to reason about. For proofs\n-- involving this function, convert it to `_\u2294_` with `Data.Nat.Properties.\u2294\u2261\u2294\u2035`.\n_\u2294\u2032_ : \u2115 \u2192 \u2115 \u2192 \u2115\nm \u2294\u2032 n with m &lt;\u1d47 n\n... | false = m\n... | true  = n\n\n-- Min.\n\n_\u2293_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  \u2293 n     = zero\nsuc m \u2293 zero  = zero\nsuc m \u2293 suc n = suc (m \u2293 n)\n\n-- Min defined in terms of primitive operations.\n-- This is much faster than `_\u2293_` but harder to reason about. For proofs\n-- involving this function, convert it to `_\u2293_` wtih `Data.Nat.properties.\u2293\u2261\u2293\u2032`.\n_\u2293\u2032_ : \u2115 \u2192 \u2115 \u2192 \u2115\nm \u2293\u2032 n with m &lt;\u1d47 n\n... | false = n\n... | true  = m\n\n-- Parity\n\nparity : \u2115 \u2192 Parity\nparity 0             = 0\u2119\nparity 1             = 1\u2119\nparity (suc (suc n)) = parity n\n\n-- Division by 2, rounded downwards.\n\n\u230a_/2\u230b : \u2115 \u2192 \u2115\n\u230a 0 /2\u230b           = 0\n\u230a 1 /2\u230b           = 0\n\u230a suc (suc n) /2\u230b = suc \u230a n /2\u230b\n\n-- Division by 2, rounded upwards.\n\n\u2308_/2\u2309 : \u2115 \u2192 \u2115\n\u2308 n /2\u2309 = \u230a suc n /2\u230b\n\n-- Na\u00efve exponentiation\n\ninfixr 8 _^_\n\n_^_ : \u2115 \u2192 \u2115 \u2192 \u2115\nx ^ zero  = 1\nx ^ suc n = x * x ^ n\n\n-- Distance\n\n\u2223_-_\u2223 : \u2115 \u2192 \u2115 \u2192 \u2115\n\u2223 zero  - y     \u2223 = y\n\u2223 x     - zero  \u2223 = x\n\u2223 suc x - suc y \u2223 = \u2223 x - y \u2223\n\n-- Distance in terms of primitive operations.\n-- This is much faster than `\u2223_-_\u2223` but harder to reason about.\n-- For proofs involving this function, convert it to `\u2223_-_\u2223` with\n-- `Data.Nat.Properties.\u2223-\u2223\u2261\u2223-\u2223\u2032`.\n\u2223_-_\u2223\u2032 : \u2115 \u2192 \u2115 \u2192 \u2115\n\u2223 x - y \u2223\u2032 with x &lt;\u1d47 y\n... | false = x \u2238 y\n... | true  = y \u2238 x\n\n-- Division\n-- Note properties of these are in `Nat.DivMod` not `Nat.Properties`\n\n_/_ : (dividend divisor : \u2115) .{{_ : NonZero divisor}} \u2192 \u2115\nm / (suc n) = div-helper 0 n m n\n\n-- Remainder/modulus\n-- Note properties of these are in `Nat.DivMod` not `Nat.Properties`\n\n_%_ : (dividend divisor : \u2115) .{{_ : NonZero divisor}} \u2192 \u2115\nm % (suc n) = mod-helper 0 n m n\n\n-- Factorial\n\n_! : \u2115 \u2192 \u2115\nzero  ! = 1\nsuc n ! = suc n * n !\n\n------------------------------------------------------------------------\n-- Extensionally equivalent alternative definitions of _\u2264_/_&lt;_ etc.\n\n-- _\u2264\u2032_: this definition is more suitable for well-founded induction\n-- (see Data.Nat.Induction)\n\ninfix 4 _\u2264\u2032_ _&lt;\u2032_ _\u2265\u2032_ _&gt;\u2032_\n\ndata _\u2264\u2032_ (m : \u2115) : \u2115 \u2192 Set where\n  \u2264\u2032-reflexive : \u2200 {n} \u2192 m \u2261 n \u2192 m \u2264\u2032 n\n  \u2264\u2032-step : \u2200 {n} \u2192 m \u2264\u2032 n \u2192 m \u2264\u2032 suc n\n\npattern \u2264\u2032-refl {m} = \u2264\u2032-reflexive {n = m} refl\n\n_&lt;\u2032_ : Rel \u2115 0\u2113\nm &lt;\u2032 n = suc m \u2264\u2032 n\n\n-- Smart constructors of _&lt;\u2032_\n\npattern &lt;\u2032-base          = \u2264\u2032-refl\npattern &lt;\u2032-step {n} m&lt;\u2032n = \u2264\u2032-step {n} m&lt;\u2032n\n\n_\u2265\u2032_ : Rel \u2115 0\u2113\nm \u2265\u2032 n = n \u2264\u2032 m\n\n_&gt;\u2032_ : Rel \u2115 0\u2113\nm &gt;\u2032 n = n &lt;\u2032 m\n\n-- _\u2264\u2033_: this definition of _\u2264_ is used for proof-irrelevant \u2035DivMod`\n-- and is a specialised instance of a general algebraic construction\n\ninfix 4 _\u2264\u2033_ _&lt;\u2033_ _\u2265\u2033_ _&gt;\u2033_\n\n_\u2264\u2033_ : (m n : \u2115)  \u2192 Set\n_\u2264\u2033_ = _\u2223\u02e1_ +-rawMagma\n\n_&lt;\u2033_ : Rel \u2115 0\u2113\nm &lt;\u2033 n = suc m \u2264\u2033 n\n\n_\u2265\u2033_ : Rel \u2115 0\u2113\nm \u2265\u2033 n = n \u2264\u2033 m\n\n_&gt;\u2033_ : Rel \u2115 0\u2113\nm &gt;\u2033 n = n &lt;\u2033 m\n\n-- Smart destructor of _&lt;\u2033_\n\ns&lt;\u2033s\u207b\u00b9 : \u2200 {m n} \u2192 suc m &lt;\u2033 suc n \u2192 m &lt;\u2033 n\ns&lt;\u2033s\u207b\u00b9 (k , eq) = k , cong pred eq\n\n-- _\u2264\u2034_: this definition is useful for induction with an upper bound.\n\ninfix 4 _\u2264\u2034_ _&lt;\u2034_ _\u2265\u2034_ _&gt;\u2034_\n\ndata _\u2264\u2034_ (m n : \u2115) : Set\n\n_&lt;\u2034_ : Rel \u2115 0\u2113\nm &lt;\u2034 n = suc m \u2264\u2034 n\n\ndata _\u2264\u2034_ m n where\n  \u2264\u2034-reflexive : m \u2261 n \u2192 m \u2264\u2034 n\n  \u2264\u2034-step      : m &lt;\u2034 n \u2192 m \u2264\u2034 n\n\npattern \u2264\u2034-refl = \u2264\u2034-reflexive refl\n\n_\u2265\u2034_ : Rel \u2115 0\u2113\nm \u2265\u2034 n = n \u2264\u2034 m\n\n_&gt;\u2034_ : Rel \u2115 0\u2113\nm &gt;\u2034 n = n &lt;\u2034 m\n\n------------------------------------------------------------------------\n-- A comparison view. Taken from \"View from the left\"\n-- (McBride/McKinna); details may differ.\n\ndata Ordering : Rel \u2115 0\u2113 where\n  less    : \u2200 m k \u2192 Ordering m (suc (m + k))\n  equal   : \u2200 m   \u2192 Ordering m m\n  greater : \u2200 m k \u2192 Ordering (suc (m + k)) m\n\ncompare : \u2200 m n \u2192 Ordering m n\ncompare zero    zero    = equal   zero\ncompare (suc m) zero    = greater zero m\ncompare zero    (suc n) = less    zero n\ncompare (suc m) (suc n) with compare m n\n... | less    m k = less (suc m) k\n... | equal   m   = equal (suc m)\n... | greater n k = greater (suc n) k\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.1\n\n-- Smart constructors of _\u2264\u2033_ and _&lt;\u2033_\npattern less-than-or-equal {k} eq = k , eq\n{-# WARNING_ON_USAGE less-than-or-equal\n\"Warning: less-than-or-equal was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using constructor Algebra.Definitions.RawMagma._\u2223\u02e1_._,_ instead. \"\n#-}\npattern \u2264\u2033-offset k = k , refl\n{-# WARNING_ON_USAGE \u2264\u2033-offset\n\"Warning: \u2264\u2033-offset was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using pattern (_, refl) from Algebra.Definitions.RawMagma._\u2223\u02e1_ instead. \"\n#-}\npattern &lt;\u2033-offset k = k , refl\n{-# WARNING_ON_USAGE &lt;\u2033-offset\n\"Warning: &lt;\u2033-offset was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using pattern (_, refl) from Algebra.Definitions.RawMagma._\u2223\u02e1_ instead. \"\n#-}\n\n-- Smart destructor of _\u2264\u2033_\n\ns\u2264\u2033s\u207b\u00b9 : \u2200 {m n} \u2192 suc m \u2264\u2033 suc n \u2192 m \u2264\u2033 n\ns\u2264\u2033s\u207b\u00b9 (k , eq) = k , cong pred eq\n{-# WARNING_ON_USAGE s\u2264\u2033s\u207b\u00b9\n\"Warning: s\u2264\u2033s\u207b\u00b9 was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using constructor Algebra.Definitions.RawMagma._\u2223\u02e1_._,_ instead. \"\n#-}\n</pre>"},{"location":"md/Data/Nat/Properties/","title":"Data.Nat.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- A bunch of properties about natural number operations\n------------------------------------------------------------------------\n\n-- See README.Data.Nat for some examples showing how this module can be\n-- used.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Nat.Properties where\n\nopen import Axiom.UniquenessOfIdentityProofs using (module Decidable\u21d2UIP)\nopen import Algebra.Bundles\n  using (Magma; Semigroup; CommutativeSemigroup; CommutativeMonoid; Monoid\n        ; Semiring; CommutativeSemiring; CommutativeSemiringWithoutOne)\nopen import Algebra.Definitions.RawMagma using (_,_)\nopen import Algebra.Morphism\nopen import Algebra.Consequences.Propositional\n  using (comm\u2227cancel\u02e1\u21d2cancel\u02b3; comm\u2227distr\u02b3\u21d2distr\u02e1; comm\u2227distr\u02e1\u21d2distr\u02b3\n        ; comm\u21d2sym[distrib\u02e1])\nopen import Algebra.Construct.NaturalChoice.Base\n  using (MinOperator; MaxOperator)\nimport Algebra.Construct.NaturalChoice.MinMaxOp as MinMaxOp\nimport Algebra.Lattice.Construct.NaturalChoice.MinMaxOp as LatticeMinMaxOp\nimport Algebra.Properties.CommutativeSemigroup as CommSemigroupProperties\nopen import Data.Bool.Base using (Bool; false; true; T)\nopen import Data.Bool.Properties using (T?)\nopen import Data.Nat.Base\nopen import Data.Product.Base using (\u2203; _\u00d7_; _,_)\nopen import Data.Sum.Base as Sum using (inj\u2081; inj\u2082; _\u228e_; [_,_]\u2032)\nopen import Data.Unit.Base using (tt)\nopen import Function.Base using (_\u2218_; flip; _$_; id; _\u2218\u2032_; _$\u2032_)\nopen import Function.Bundles using (_\u21a3_)\nopen import Function.Metric.Nat\n  using (TriangleInequality; IsProtoMetric; IsPreMetric; IsQuasiSemiMetric\n        ; IsSemiMetric; IsMetric; PreMetric; QuasiSemiMetric\n        ; SemiMetric; Metric)\nopen import Level using (0\u2113)\nopen import Relation.Unary as U using (Pred)\nopen import Relation.Binary.Core\n  using (_\u21d2_; _Preserves_\u27f6_; _Preserves\u2082_\u27f6_\u27f6_)\nopen import Relation.Binary.Bundles\nopen import Relation.Binary.Definitions\nopen import Relation.Binary.Consequences\n  using (mono\u2082\u21d2mono\u02e1; mono\u2082\u21d2mono\u02b3; flip-Connex; wlog)\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary.Structures\nopen import Relation.Binary.Structures.Biased\nopen import Relation.Nullary.Decidable\n  using (True; via-injection; map\u2032; recompute; no; yes; Dec; _because_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Nullary.Reflects\n  using (fromEquivalence; Reflects; invert)\n\nopen import Algebra.Definitions {A = \u2115} _\u2261_\n  hiding (LeftCancellative; RightCancellative; Cancellative)\nopen import Algebra.Definitions\n  using (LeftCancellative; RightCancellative; Cancellative)\nopen import Algebra.Structures {A = \u2115} _\u2261_\n\n\nprivate\n  variable\n    m n o k : \u2115\n\n\n------------------------------------------------------------------------\n-- Properties of NonZero\n------------------------------------------------------------------------\n\nnonZero? : U.Decidable NonZero\nnonZero? zero    = no NonZero.nonZero\nnonZero? (suc n) = yes _\n\n------------------------------------------------------------------------\n-- Properties of NonTrivial\n------------------------------------------------------------------------\n\nnonTrivial? : U.Decidable NonTrivial\nnonTrivial? 0      = no \u03bb()\nnonTrivial? 1      = no \u03bb()\nnonTrivial? (2+ n) = yes _\n\n------------------------------------------------------------------------\n-- Properties of _\u2261_\n------------------------------------------------------------------------\n\nsuc-injective : suc m \u2261 suc n \u2192 m \u2261 n\nsuc-injective = cong pred\n\n\u2261\u1d47\u21d2\u2261 : \u2200 m n \u2192 T (m \u2261\u1d47 n) \u2192 m \u2261 n\n\u2261\u1d47\u21d2\u2261 zero    zero    _  = refl\n\u2261\u1d47\u21d2\u2261 (suc m) (suc n) eq = cong suc (\u2261\u1d47\u21d2\u2261 m n eq)\n\n\u2261\u21d2\u2261\u1d47 : \u2200 m n \u2192 m \u2261 n \u2192 T (m \u2261\u1d47 n)\n\u2261\u21d2\u2261\u1d47 zero    zero    eq = _\n\u2261\u21d2\u2261\u1d47 (suc m) (suc n) eq = \u2261\u21d2\u2261\u1d47 m n (suc-injective eq)\n\n-- NB: we use the builtin function `_\u2261\u1d47_` here so that the function\n-- quickly decides whether to return `yes` or `no`. It still takes\n-- a linear amount of time to generate the proof if it is inspected.\n-- We expect the main benefit to be visible in compiled code as the\n-- backend erases proofs.\n\ninfix 4 _\u225f_\n_\u225f_ : DecidableEquality \u2115\nm \u225f n = map\u2032 (\u2261\u1d47\u21d2\u2261 m n) (\u2261\u21d2\u2261\u1d47 m n) (T? (m \u2261\u1d47 n))\n\n\u2261-irrelevant : Irrelevant {A = \u2115} _\u2261_\n\u2261-irrelevant = Decidable\u21d2UIP.\u2261-irrelevant _\u225f_\n\n\u225f-diag : (eq : m \u2261 n) \u2192 (m \u225f n) \u2261 yes eq\n\u225f-diag = \u2261-\u225f-identity _\u225f_\n\n\u2261-isDecEquivalence : IsDecEquivalence (_\u2261_ {A = \u2115})\n\u2261-isDecEquivalence = record\n  { isEquivalence = isEquivalence\n  ; _\u225f_           = _\u225f_\n  }\n\n\u2261-decSetoid : DecSetoid 0\u2113 0\u2113\n\u2261-decSetoid = record\n  { Carrier          = \u2115\n  ; _\u2248_              = _\u2261_\n  ; isDecEquivalence = \u2261-isDecEquivalence\n  }\n\n0\u22621+n : 0 \u2262 suc n\n0\u22621+n ()\n\n1+n\u22620 : suc n \u2262 0\n1+n\u22620 ()\n\n1+n\u2262n : suc n \u2262 n\n1+n\u2262n {suc n} = 1+n\u2262n \u2218 suc-injective\n\n------------------------------------------------------------------------\n-- Properties of _&lt;\u1d47_\n------------------------------------------------------------------------\n\n&lt;\u1d47\u21d2&lt; : \u2200 m n \u2192 T (m &lt;\u1d47 n) \u2192 m &lt; n\n&lt;\u1d47\u21d2&lt; zero    (suc n) m&lt;n = z&lt;s\n&lt;\u1d47\u21d2&lt; (suc m) (suc n) m&lt;n = s&lt;s (&lt;\u1d47\u21d2&lt; m n m&lt;n)\n\n&lt;\u21d2&lt;\u1d47 : m &lt; n \u2192 T (m &lt;\u1d47 n)\n&lt;\u21d2&lt;\u1d47 z&lt;s               = tt\n&lt;\u21d2&lt;\u1d47 (s&lt;s m&lt;n@(s\u2264s _)) = &lt;\u21d2&lt;\u1d47 m&lt;n\n\n&lt;\u1d47-reflects-&lt; : \u2200 m n \u2192 Reflects (m &lt; n) (m &lt;\u1d47 n)\n&lt;\u1d47-reflects-&lt; m n = fromEquivalence (&lt;\u1d47\u21d2&lt; m n) &lt;\u21d2&lt;\u1d47\n\n------------------------------------------------------------------------\n-- Properties of _\u2264\u1d47_\n------------------------------------------------------------------------\n\n\u2264\u1d47\u21d2\u2264 : \u2200 m n \u2192 T (m \u2264\u1d47 n) \u2192 m \u2264 n\n\u2264\u1d47\u21d2\u2264 zero    n m\u2264n = z\u2264n\n\u2264\u1d47\u21d2\u2264 (suc m) n m\u2264n = &lt;\u1d47\u21d2&lt; m n m\u2264n\n\n\u2264\u21d2\u2264\u1d47 : m \u2264 n \u2192 T (m \u2264\u1d47 n)\n\u2264\u21d2\u2264\u1d47 z\u2264n         = tt\n\u2264\u21d2\u2264\u1d47 m\u2264n@(s\u2264s _) = &lt;\u21d2&lt;\u1d47 m\u2264n\n\n\u2264\u1d47-reflects-\u2264 : \u2200 m n \u2192 Reflects (m \u2264 n) (m \u2264\u1d47 n)\n\u2264\u1d47-reflects-\u2264 m n = fromEquivalence (\u2264\u1d47\u21d2\u2264 m n) \u2264\u21d2\u2264\u1d47\n\n------------------------------------------------------------------------\n-- Properties of _\u2264_\n------------------------------------------------------------------------\n\n\u2270\u21d2\u2265 : _\u2270_ \u21d2 _\u2265_\n\u2270\u21d2\u2265 {m} {zero} m\u2270n = z\u2264n\n\u2270\u21d2\u2265 {zero} {suc n} m\u2270n = contradiction z\u2264n m\u2270n\n\u2270\u21d2\u2265 {suc m} {suc n} m\u2270n = s\u2264s (\u2270\u21d2\u2265 (m\u2270n \u2218 s\u2264s))\n\n------------------------------------------------------------------------\n-- Relational properties of _\u2264_\n\n\u2264-reflexive : _\u2261_ \u21d2 _\u2264_\n\u2264-reflexive {zero}  refl = z\u2264n\n\u2264-reflexive {suc m} refl = s\u2264s (\u2264-reflexive refl)\n\n\u2264-refl : Reflexive _\u2264_\n\u2264-refl = \u2264-reflexive refl\n\n\u2264-antisym : Antisymmetric _\u2261_ _\u2264_\n\u2264-antisym z\u2264n       z\u2264n       = refl\n\u2264-antisym (s\u2264s m\u2264n) (s\u2264s n\u2264m) = cong suc (\u2264-antisym m\u2264n n\u2264m)\n\n\u2264-trans : Transitive _\u2264_\n\u2264-trans z\u2264n       _         = z\u2264n\n\u2264-trans (s\u2264s m\u2264n) (s\u2264s n\u2264o) = s\u2264s (\u2264-trans m\u2264n n\u2264o)\n\n\u2264-irrelevant : Irrelevant _\u2264_\n\u2264-irrelevant z\u2264n        z\u2264n        = refl\n\u2264-irrelevant (s\u2264s m\u2264n\u2081) (s\u2264s m\u2264n\u2082) = cong s\u2264s (\u2264-irrelevant m\u2264n\u2081 m\u2264n\u2082)\n\n-- NB: we use the builtin function `_&lt;\u1d47_` here so that the function\n-- quickly decides whether to return `yes` or `no`. It still takes\n-- a linear amount of time to generate the proof if it is inspected.\n-- We expect the main benefit to be visible in compiled code as the\n-- backend erases proofs.\n\ninfix 4 _\u2264?_ _\u2265?_\n\n_\u2264?_ : Decidable _\u2264_\nm \u2264? n = map\u2032 (\u2264\u1d47\u21d2\u2264 m n) \u2264\u21d2\u2264\u1d47 (T? (m \u2264\u1d47 n))\n\n_\u2265?_ : Decidable _\u2265_\n_\u2265?_ = flip _\u2264?_\n\n\u2264-total : Total _\u2264_\n\u2264-total m n with m \u2264? n\n... | true because m\u2264n = inj\u2081 (invert m\u2264n)\n... | false because m\u2270n = inj\u2082 (\u2270\u21d2\u2265 (invert m\u2270n))\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2264-isPreorder : IsPreorder _\u2261_ _\u2264_\n\u2264-isPreorder = record\n  { isEquivalence = isEquivalence\n  ; reflexive     = \u2264-reflexive\n  ; trans         = \u2264-trans\n  }\n\n\u2264-isTotalPreorder : IsTotalPreorder _\u2261_ _\u2264_\n\u2264-isTotalPreorder = record\n  { isPreorder = \u2264-isPreorder\n  ; total      = \u2264-total\n  }\n\n\u2264-isPartialOrder : IsPartialOrder _\u2261_ _\u2264_\n\u2264-isPartialOrder = record\n  { isPreorder = \u2264-isPreorder\n  ; antisym    = \u2264-antisym\n  }\n\n\u2264-isTotalOrder : IsTotalOrder _\u2261_ _\u2264_\n\u2264-isTotalOrder = record\n  { isPartialOrder = \u2264-isPartialOrder\n  ; total          = \u2264-total\n  }\n\n\u2264-isDecTotalOrder : IsDecTotalOrder _\u2261_ _\u2264_\n\u2264-isDecTotalOrder = record\n  { isTotalOrder = \u2264-isTotalOrder\n  ; _\u225f_          = _\u225f_\n  ; _\u2264?_         = _\u2264?_\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2264-preorder : Preorder 0\u2113 0\u2113 0\u2113\n\u2264-preorder = record\n  { isPreorder = \u2264-isPreorder\n  }\n\n\u2264-totalPreorder : TotalPreorder 0\u2113 0\u2113 0\u2113\n\u2264-totalPreorder = record\n  { isTotalPreorder = \u2264-isTotalPreorder\n  }\n\n\u2264-poset : Poset 0\u2113 0\u2113 0\u2113\n\u2264-poset = record\n  { isPartialOrder = \u2264-isPartialOrder\n  }\n\n\u2264-totalOrder : TotalOrder 0\u2113 0\u2113 0\u2113\n\u2264-totalOrder = record\n  { isTotalOrder = \u2264-isTotalOrder\n  }\n\n\u2264-decTotalOrder : DecTotalOrder 0\u2113 0\u2113 0\u2113\n\u2264-decTotalOrder = record\n  { isDecTotalOrder = \u2264-isDecTotalOrder\n  }\n\n------------------------------------------------------------------------\n-- Other properties of _\u2264_\n\ns\u2264s-injective : {p q : m \u2264 n} \u2192 s\u2264s p \u2261 s\u2264s q \u2192 p \u2261 q\ns\u2264s-injective refl = refl\n\nsuc[m]\u2264n\u21d2m\u2264pred[n] : suc m \u2264 n \u2192 m \u2264 pred n\nsuc[m]\u2264n\u21d2m\u2264pred[n] {n = suc _} = s\u2264s\u207b\u00b9\n\nm\u2264pred[n]\u21d2suc[m]\u2264n : .{{NonZero n}} \u2192 m \u2264 pred n \u2192 suc m \u2264 n\nm\u2264pred[n]\u21d2suc[m]\u2264n {n = suc _} = s\u2264s\n\n\u2264-pred : suc m \u2264 suc n \u2192 m \u2264 n\n\u2264-pred = suc[m]\u2264n\u21d2m\u2264pred[n]\n\nm\u2264n\u21d2m\u22641+n : m \u2264 n \u2192 m \u2264 1 + n\nm\u2264n\u21d2m\u22641+n z\u2264n       = z\u2264n\nm\u2264n\u21d2m\u22641+n (s\u2264s m\u2264n) = s\u2264s (m\u2264n\u21d2m\u22641+n m\u2264n)\n\nn\u22641+n : \u2200 n \u2192 n \u2264 1 + n\nn\u22641+n _ = m\u2264n\u21d2m\u22641+n \u2264-refl\n\n1+n\u2270n : 1 + n \u2270 n\n1+n\u2270n (s\u2264s 1+n\u2264n) = 1+n\u2270n 1+n\u2264n\n\nn\u22640\u21d2n\u22610 : n \u2264 0 \u2192 n \u2261 0\nn\u22640\u21d2n\u22610 z\u2264n = refl\n\nn\u22641\u21d2n\u22610\u2228n\u22611 : n \u2264 1 \u2192 n \u2261 0 \u228e n \u2261 1\nn\u22641\u21d2n\u22610\u2228n\u22611 z\u2264n       = inj\u2081 refl\nn\u22641\u21d2n\u22610\u2228n\u22611 (s\u2264s z\u2264n) = inj\u2082 refl\n\n------------------------------------------------------------------------\n-- Properties of _&lt;_\n------------------------------------------------------------------------\n\n-- Relationships between the various relations\n\n&lt;\u21d2\u2264 : _&lt;_ \u21d2 _\u2264_\n&lt;\u21d2\u2264 z&lt;s               = z\u2264n\n&lt;\u21d2\u2264 (s&lt;s m&lt;n@(s\u2264s _)) = s\u2264s (&lt;\u21d2\u2264 m&lt;n)\n\n&lt;\u21d2\u2262 : _&lt;_ \u21d2 _\u2262_\n&lt;\u21d2\u2262 m&lt;n refl = 1+n\u2270n m&lt;n\n\n&gt;\u21d2\u2262 : _&gt;_ \u21d2 _\u2262_\n&gt;\u21d2\u2262 = \u2262-sym \u2218 &lt;\u21d2\u2262\n\n\u2264\u21d2\u226f : _\u2264_ \u21d2 _\u226f_\n\u2264\u21d2\u226f (s\u2264s m\u2264n) (s\u2264s n\u2264m) = \u2264\u21d2\u226f m\u2264n n\u2264m\n\n&lt;\u21d2\u2271 : _&lt;_ \u21d2 _\u2271_\n&lt;\u21d2\u2271 (s\u2264s m+1\u2264n) (s\u2264s n\u2264m) = &lt;\u21d2\u2271 m+1\u2264n n\u2264m\n\n&lt;\u21d2\u226f : _&lt;_ \u21d2 _\u226f_\n&lt;\u21d2\u226f (s\u2264s m&lt;n) (s\u2264s n&lt;m) = &lt;\u21d2\u226f m&lt;n n&lt;m\n\n\u2270\u21d2\u226e : _\u2270_ \u21d2 _\u226e_\n\u2270\u21d2\u226e m\u2270n 1+m\u2264n = m\u2270n (&lt;\u21d2\u2264 1+m\u2264n)\n\n\u2270\u21d2&gt; : _\u2270_ \u21d2 _&gt;_\n\u2270\u21d2&gt; {zero}          z\u2270n = contradiction z\u2264n z\u2270n\n\u2270\u21d2&gt; {suc m} {zero}  _   = z&lt;s\n\u2270\u21d2&gt; {suc m} {suc n} m\u2270n = s&lt;s (\u2270\u21d2&gt; (m\u2270n \u2218 s\u2264s))\n\n\u226e\u21d2\u2265 : _\u226e_ \u21d2 _\u2265_\n\u226e\u21d2\u2265 {_}     {zero}  _       = z\u2264n\n\u226e\u21d2\u2265 {zero}  {suc j} 1\u226ej+1   = contradiction z&lt;s 1\u226ej+1\n\u226e\u21d2\u2265 {suc i} {suc j} i+1\u226ej+1 = s\u2264s (\u226e\u21d2\u2265 (i+1\u226ej+1 \u2218 s&lt;s))\n\n\u2264\u2227\u2262\u21d2&lt; : \u2200 {m n} \u2192 m \u2264 n \u2192 m \u2262 n \u2192 m &lt; n\n\u2264\u2227\u2262\u21d2&lt; {_} {zero}  z\u2264n       m\u2262n     = contradiction refl m\u2262n\n\u2264\u2227\u2262\u21d2&lt; {_} {suc n} z\u2264n       m\u2262n     = z&lt;s\n\u2264\u2227\u2262\u21d2&lt; {_} {suc n} (s\u2264s m\u2264n) 1+m\u22621+n =\n  s&lt;s (\u2264\u2227\u2262\u21d2&lt; m\u2264n (1+m\u22621+n \u2218 cong suc))\n\n\u2264\u2227\u226e\u21d2\u2261 : \u2200 {m n} \u2192 m \u2264 n \u2192 m \u226e n \u2192 m \u2261 n\n\u2264\u2227\u226e\u21d2\u2261 m\u2264n m\u226en = \u2264-antisym m\u2264n (\u226e\u21d2\u2265 m\u226en)\n\n\u2264-&lt;-connex : Connex _\u2264_ _&lt;_\n\u2264-&lt;-connex m n with m \u2264? n\n... | yes m\u2264n = inj\u2081 m\u2264n\n... | no \u00acm\u2264n = inj\u2082 (\u2270\u21d2&gt; \u00acm\u2264n)\n\n\u2265-&gt;-connex : Connex _\u2265_ _&gt;_\n\u2265-&gt;-connex = flip \u2264-&lt;-connex\n\n&lt;-\u2264-connex : Connex _&lt;_ _\u2264_\n&lt;-\u2264-connex = flip-Connex \u2264-&lt;-connex\n\n&gt;-\u2265-connex : Connex _&gt;_ _\u2265_\n&gt;-\u2265-connex = flip-Connex \u2265-&gt;-connex\n\n------------------------------------------------------------------------\n-- Relational properties of _&lt;_\n\n&lt;-irrefl : Irreflexive _\u2261_ _&lt;_\n&lt;-irrefl refl (s&lt;s n&lt;n) = &lt;-irrefl refl n&lt;n\n\n&lt;-asym : Asymmetric _&lt;_\n&lt;-asym (s&lt;s n&lt;m) (s&lt;s m&lt;n) = &lt;-asym n&lt;m m&lt;n\n\n&lt;-trans : Transitive _&lt;_\n&lt;-trans (s\u2264s i\u2264j) (s\u2264s j&lt;k) = s\u2264s (\u2264-trans i\u2264j (\u2264-trans (n\u22641+n _) j&lt;k))\n\n\u2264-&lt;-trans : LeftTrans _\u2264_ _&lt;_\n\u2264-&lt;-trans m\u2264n (s&lt;s n\u2264o) = s\u2264s (\u2264-trans m\u2264n n\u2264o)\n\n&lt;-\u2264-trans : RightTrans _&lt;_ _\u2264_\n&lt;-\u2264-trans (s&lt;s m\u2264n) (s\u2264s n\u2264o) = s\u2264s (\u2264-trans m\u2264n n\u2264o)\n\n-- NB: we use the builtin function `_&lt;\u1d47_` here so that the function\n-- quickly decides which constructor to return. It still takes a\n-- linear amount of time to generate the proof if it is inspected.\n-- We expect the main benefit to be visible in compiled code as the\n-- backend erases proofs.\n\n&lt;-cmp : Trichotomous _\u2261_ _&lt;_\n&lt;-cmp m n with m \u225f n | T? (m &lt;\u1d47 n)\n... | yes m\u2261n | _       = tri\u2248 (&lt;-irrefl m\u2261n) m\u2261n (&lt;-irrefl (sym m\u2261n))\n... | no  m\u2262n | yes m&lt;n = tri&lt; (&lt;\u1d47\u21d2&lt; m n m&lt;n) m\u2262n (&lt;\u21d2\u226f (&lt;\u1d47\u21d2&lt; m n m&lt;n))\n... | no  m\u2262n | no  m\u226en = tri&gt; (m\u226en \u2218 &lt;\u21d2&lt;\u1d47)   m\u2262n (\u2264\u2227\u2262\u21d2&lt; (\u226e\u21d2\u2265 (m\u226en \u2218 &lt;\u21d2&lt;\u1d47)) (m\u2262n \u2218 sym))\n\ninfix 4 _&lt;?_ _&gt;?_\n\n_&lt;?_ : Decidable _&lt;_\nm &lt;? n = suc m \u2264? n\n\n_&gt;?_ : Decidable _&gt;_\n_&gt;?_ = flip _&lt;?_\n\n&lt;-irrelevant : Irrelevant _&lt;_\n&lt;-irrelevant = \u2264-irrelevant\n\n&lt;-resp\u2082-\u2261 : _&lt;_ Respects\u2082 _\u2261_\n&lt;-resp\u2082-\u2261 = subst (_ &lt;_) , subst (_&lt; _)\n\n------------------------------------------------------------------------\n-- Bundles\n\n&lt;-isStrictPartialOrder : IsStrictPartialOrder _\u2261_ _&lt;_\n&lt;-isStrictPartialOrder = record\n  { isEquivalence = isEquivalence\n  ; irrefl        = &lt;-irrefl\n  ; trans         = &lt;-trans\n  ; &lt;-resp-\u2248      = &lt;-resp\u2082-\u2261\n  }\n\n&lt;-isStrictTotalOrder : IsStrictTotalOrder _\u2261_ _&lt;_\n&lt;-isStrictTotalOrder = isStrictTotalOrder\u1d9c record\n  { isEquivalence = isEquivalence\n  ; trans         = &lt;-trans\n  ; compare       = &lt;-cmp\n  }\n\n&lt;-strictPartialOrder : StrictPartialOrder 0\u2113 0\u2113 0\u2113\n&lt;-strictPartialOrder = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder\n  }\n\n&lt;-strictTotalOrder : StrictTotalOrder 0\u2113 0\u2113 0\u2113\n&lt;-strictTotalOrder = record\n  { isStrictTotalOrder = &lt;-isStrictTotalOrder\n  }\n\n------------------------------------------------------------------------\n-- Other properties of _&lt;_\n\ns&lt;s-injective : {p q : m &lt; n} \u2192 s&lt;s p \u2261 s&lt;s q \u2192 p \u2261 q\ns&lt;s-injective refl = refl\n\n&lt;-pred : suc m &lt; suc n \u2192 m &lt; n\n&lt;-pred = s&lt;s\u207b\u00b9\n\nm&lt;n\u21d2m&lt;1+n : m &lt; n \u2192 m &lt; 1 + n\nm&lt;n\u21d2m&lt;1+n z&lt;s               = z&lt;s\nm&lt;n\u21d2m&lt;1+n (s&lt;s m&lt;n@(s\u2264s _)) = s&lt;s (m&lt;n\u21d2m&lt;1+n m&lt;n)\n\nn\u226e0 : n \u226e 0\nn\u226e0 ()\n\nn\u226en : \u2200 n \u2192 n \u226e n -- implicit?\nn\u226en n = &lt;-irrefl (refl {x = n})\n\n0&lt;1+n : 0 &lt; suc n\n0&lt;1+n = z&lt;s\n\nn&lt;1+n : \u2200 n \u2192 n &lt; suc n\nn&lt;1+n n = \u2264-refl\n\nn&lt;1\u21d2n\u22610 : n &lt; 1 \u2192 n \u2261 0\nn&lt;1\u21d2n\u22610 (s\u2264s n\u22640) = n\u22640\u21d2n\u22610 n\u22640\n\nn&gt;0\u21d2n\u22620 : n &gt; 0 \u2192 n \u2262 0\nn&gt;0\u21d2n\u22620 {suc n} _ ()\n\nn\u22620\u21d2n&gt;0 : n \u2262 0 \u2192 n &gt; 0\nn\u22620\u21d2n&gt;0 {zero}  0\u22620 =  contradiction refl 0\u22620\nn\u22620\u21d2n&gt;0 {suc n} _   =  0&lt;1+n\n\nm&lt;n\u21d20&lt;n : m &lt; n \u2192 0 &lt; n\nm&lt;n\u21d20&lt;n = \u2264-trans 0&lt;1+n\n\nm&lt;n\u21d2n\u22620 : m &lt; n \u2192 n \u2262 0\nm&lt;n\u21d2n\u22620 (s\u2264s m\u2264n) ()\n\nm&lt;n\u21d2m\u22641+n : m &lt; n \u2192 m \u2264 suc n\nm&lt;n\u21d2m\u22641+n = m\u2264n\u21d2m\u22641+n \u2218 &lt;\u21d2\u2264\n\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n :  \u2200 {m n} \u2192 m &lt; suc n \u2192 m &lt; n \u228e m \u2261 n\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n {0}     {0}     _           = inj\u2082 refl\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n {0}     {suc n} _           = inj\u2081 0&lt;1+n\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n {suc m} {suc n} (s&lt;s m&lt;1+n) = Sum.map s&lt;s (cong suc) (m&lt;1+n\u21d2m&lt;n\u2228m\u2261n m&lt;1+n)\n\nm\u2264n\u21d2m&lt;n\u2228m\u2261n : m \u2264 n \u2192 m &lt; n \u228e m \u2261 n\nm\u2264n\u21d2m&lt;n\u2228m\u2261n m\u2264n = m&lt;1+n\u21d2m&lt;n\u2228m\u2261n (s\u2264s m\u2264n)\n\nm&lt;1+n\u21d2m\u2264n : m &lt; suc n \u2192 m \u2264 n\nm&lt;1+n\u21d2m\u2264n (s\u2264s m\u2264n) = m\u2264n\n\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o : \u2200 n o \u2192 (\u2200 {m} \u2192 m \u2264 n \u2192 m \u2262 o) \u2192 n &lt; o\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o _       zero    m\u2264n\u21d2n\u22620 = contradiction refl (m\u2264n\u21d2n\u22620 z\u2264n)\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o zero    (suc o) _       = 0&lt;1+n\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o (suc n) (suc o) m\u2264n\u21d2n\u2262o = s\u2264s (\u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o n o rec)\n  where\n  rec : \u2200 {m} \u2192 m \u2264 n \u2192 m \u2262 o\n  rec m\u2264n refl = m\u2264n\u21d2n\u2262o (s\u2264s m\u2264n) refl\n\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o : \u2200 n o \u2192 (\u2200 {m} \u2192 m &lt; n \u2192 m \u2262 o) \u2192 n \u2264 o\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o zero    n       _       = z\u2264n\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o (suc n) zero    m&lt;n\u21d2m\u22620 = contradiction refl (m&lt;n\u21d2m\u22620 0&lt;1+n)\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o (suc n) (suc o) m&lt;n\u21d2m\u2262o = s\u2264s (\u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o n o rec)\n  where\n  rec : \u2200 {m} \u2192 m &lt; n \u2192 m \u2262 o\n  rec o&lt;n refl = m&lt;n\u21d2m\u2262o (s&lt;s o&lt;n) refl\n\n------------------------------------------------------------------------\n-- A module for reasoning about the _\u2264_ and _&lt;_ relations\n------------------------------------------------------------------------\n\nmodule \u2264-Reasoning where\n  open import Relation.Binary.Reasoning.Base.Triple\n    \u2264-isPreorder\n    &lt;-asym\n    &lt;-trans\n    (resp\u2082 _&lt;_)\n    &lt;\u21d2\u2264\n    &lt;-\u2264-trans\n    \u2264-&lt;-trans\n    public\n    hiding (step-\u2248; step-\u2248\u02d8; step-\u2248-\u27e9; step-\u2248-\u27e8)\n\nopen \u2264-Reasoning\n\n------------------------------------------------------------------------\n-- Properties of _+_\n------------------------------------------------------------------------\n\n+-suc : \u2200 m n \u2192 m + suc n \u2261 suc (m + n)\n+-suc zero    n = refl\n+-suc (suc m) n = cong suc (+-suc m n)\n\n------------------------------------------------------------------------\n-- Algebraic properties of _+_\n\n+-assoc : Associative _+_\n+-assoc zero    _ _ = refl\n+-assoc (suc m) n o = cong suc (+-assoc m n o)\n\n+-identity\u02e1 : LeftIdentity 0 _+_\n+-identity\u02e1 _ = refl\n\n+-identity\u02b3 : RightIdentity 0 _+_\n+-identity\u02b3 zero    = refl\n+-identity\u02b3 (suc n) = cong suc (+-identity\u02b3 n)\n\n+-identity : Identity 0 _+_\n+-identity = +-identity\u02e1 , +-identity\u02b3\n\n+-comm : Commutative _+_\n+-comm zero    n = sym (+-identity\u02b3 n)\n+-comm (suc m) n = begin-equality\n  suc m + n   \u2261\u27e8\u27e9\n  suc (m + n) \u2261\u27e8 cong suc (+-comm m n) \u27e9\n  suc (n + m) \u2261\u27e8 sym (+-suc n m) \u27e9\n  n + suc m   \u220e\n\n+-cancel\u02e1-\u2261 : LeftCancellative _\u2261_ _+_\n+-cancel\u02e1-\u2261 zero    _ _ eq = eq\n+-cancel\u02e1-\u2261 (suc m) _ _ eq = +-cancel\u02e1-\u2261 m _ _ (cong pred eq)\n\n+-cancel\u02b3-\u2261 : RightCancellative _\u2261_ _+_\n+-cancel\u02b3-\u2261 = comm\u2227cancel\u02e1\u21d2cancel\u02b3 +-comm +-cancel\u02e1-\u2261\n\n+-cancel-\u2261 : Cancellative _\u2261_ _+_\n+-cancel-\u2261 = +-cancel\u02e1-\u2261 , +-cancel\u02b3-\u2261\n\n------------------------------------------------------------------------\n-- Structures\n\n+-isMagma : IsMagma _+_\n+-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = cong\u2082 _+_\n  }\n\n+-isSemigroup : IsSemigroup _+_\n+-isSemigroup = record\n  { isMagma = +-isMagma\n  ; assoc   = +-assoc\n  }\n\n+-isCommutativeSemigroup : IsCommutativeSemigroup _+_\n+-isCommutativeSemigroup = record\n  { isSemigroup = +-isSemigroup\n  ; comm        = +-comm\n  }\n\n+-0-isMonoid : IsMonoid _+_ 0\n+-0-isMonoid = record\n  { isSemigroup = +-isSemigroup\n  ; identity    = +-identity\n  }\n\n+-0-isCommutativeMonoid : IsCommutativeMonoid _+_ 0\n+-0-isCommutativeMonoid = record\n  { isMonoid = +-0-isMonoid\n  ; comm     = +-comm\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n+-magma : Magma 0\u2113 0\u2113\n+-magma = record\n  { isMagma = +-isMagma\n  }\n\n+-semigroup : Semigroup 0\u2113 0\u2113\n+-semigroup = record\n  { isSemigroup = +-isSemigroup\n  }\n\n+-commutativeSemigroup : CommutativeSemigroup 0\u2113 0\u2113\n+-commutativeSemigroup = record\n  { isCommutativeSemigroup = +-isCommutativeSemigroup\n  }\n\n+-0-monoid : Monoid 0\u2113 0\u2113\n+-0-monoid = record\n  { isMonoid = +-0-isMonoid\n  }\n\n+-0-commutativeMonoid : CommutativeMonoid 0\u2113 0\u2113\n+-0-commutativeMonoid = record\n  { isCommutativeMonoid = +-0-isCommutativeMonoid\n  }\n\n\u2238-magma : Magma 0\u2113 0\u2113\n\u2238-magma = magma _\u2238_\n\n\n------------------------------------------------------------------------\n-- Other properties of _+_ and _\u2261_\n\nm\u22621+m+n : \u2200 m {n} \u2192 m \u2262 suc (m + n)\nm\u22621+m+n (suc m) eq = m\u22621+m+n m (cong pred eq)\n\nm\u22621+n+m : \u2200 m {n} \u2192 m \u2262 suc (n + m)\nm\u22621+n+m m m\u22611+n+m = m\u22621+m+n m (trans m\u22611+n+m (cong suc (+-comm _ m)))\n\nm+1+n\u2262m : \u2200 m {n} \u2192 m + suc n \u2262 m\nm+1+n\u2262m (suc m) = (m+1+n\u2262m m) \u2218 suc-injective\n\nm+1+n\u2262n : \u2200 m {n} \u2192 m + suc n \u2262 n\nm+1+n\u2262n m {n} rewrite +-suc m n = \u2262-sym (m\u22621+n+m n)\n\nm+1+n\u22620 : \u2200 m {n} \u2192 m + suc n \u2262 0\nm+1+n\u22620 m {n} rewrite +-suc m n = \u03bb()\n\nm+n\u22610\u21d2m\u22610 : \u2200 m {n} \u2192 m + n \u2261 0 \u2192 m \u2261 0\nm+n\u22610\u21d2m\u22610 zero eq = refl\n\nm+n\u22610\u21d2n\u22610 : \u2200 m {n} \u2192 m + n \u2261 0 \u2192 n \u2261 0\nm+n\u22610\u21d2n\u22610 m {n} m+n\u22610 = m+n\u22610\u21d2m\u22610 n (trans (+-comm n m) (m+n\u22610))\n\n------------------------------------------------------------------------\n-- Properties of _+_ and _\u2264_/_&lt;_\n\n+-cancel\u02e1-\u2264 : LeftCancellative _\u2264_ _+_\n+-cancel\u02e1-\u2264 zero    _ _ le       = le\n+-cancel\u02e1-\u2264 (suc m) _ _ (s\u2264s le) = +-cancel\u02e1-\u2264 m _ _ le\n\n+-cancel\u02b3-\u2264 : RightCancellative _\u2264_ _+_\n+-cancel\u02b3-\u2264 m n o le =\n  +-cancel\u02e1-\u2264 m _ _ (subst\u2082 _\u2264_ (+-comm n m) (+-comm o m) le)\n\n+-cancel-\u2264 : Cancellative _\u2264_ _+_\n+-cancel-\u2264 = +-cancel\u02e1-\u2264 , +-cancel\u02b3-\u2264\n\n+-cancel\u02e1-&lt; : LeftCancellative _&lt;_ _+_\n+-cancel\u02e1-&lt; m n o = +-cancel\u02e1-\u2264 m (suc n) o \u2218 subst (_\u2264 m + o) (sym (+-suc m n))\n\n+-cancel\u02b3-&lt; : RightCancellative _&lt;_ _+_\n+-cancel\u02b3-&lt; m n o n+m&lt;o+m = +-cancel\u02b3-\u2264 m (suc n) o n+m&lt;o+m\n\n+-cancel-&lt; : Cancellative _&lt;_ _+_\n+-cancel-&lt; = +-cancel\u02e1-&lt; , +-cancel\u02b3-&lt;\n\nm\u2264n\u21d2m\u2264o+n : \u2200 o \u2192 m \u2264 n \u2192 m \u2264 o + n\nm\u2264n\u21d2m\u2264o+n zero    m\u2264n = m\u2264n\nm\u2264n\u21d2m\u2264o+n (suc o) m\u2264n = m\u2264n\u21d2m\u22641+n (m\u2264n\u21d2m\u2264o+n o m\u2264n)\n\nm\u2264n\u21d2m\u2264n+o : \u2200 o \u2192 m \u2264 n \u2192 m \u2264 n + o\nm\u2264n\u21d2m\u2264n+o {m} o m\u2264n = subst (m \u2264_) (+-comm o _) (m\u2264n\u21d2m\u2264o+n o m\u2264n)\n\nm\u2264m+n : \u2200 m n \u2192 m \u2264 m + n\nm\u2264m+n zero    n = z\u2264n\nm\u2264m+n (suc m) n = s\u2264s (m\u2264m+n m n)\n\nm\u2264n+m : \u2200 m n \u2192 m \u2264 n + m\nm\u2264n+m m n = subst (m \u2264_) (+-comm m n) (m\u2264m+n m n)\n\nm+n\u2264o\u21d2m\u2264o : \u2200 m {n o} \u2192 m + n \u2264 o \u2192 m \u2264 o\nm+n\u2264o\u21d2m\u2264o zero    m+n\u2264o       = z\u2264n\nm+n\u2264o\u21d2m\u2264o (suc m) (s\u2264s m+n\u2264o) = s\u2264s (m+n\u2264o\u21d2m\u2264o m m+n\u2264o)\n\nm+n\u2264o\u21d2n\u2264o : \u2200 m {n o} \u2192 m + n \u2264 o \u2192 n \u2264 o\nm+n\u2264o\u21d2n\u2264o zero    n\u2264o   = n\u2264o\nm+n\u2264o\u21d2n\u2264o (suc m) m+n&lt;o = m+n\u2264o\u21d2n\u2264o m (&lt;\u21d2\u2264 m+n&lt;o)\n\n+-mono-\u2264 : Monotonic\u2082 _\u2264_ _\u2264_ _\u2264_ _+_\n+-mono-\u2264 {_} {m} z\u2264n       o\u2264p = \u2264-trans o\u2264p (m\u2264n+m _ m)\n+-mono-\u2264 {_} {_} (s\u2264s m\u2264n) o\u2264p = s\u2264s (+-mono-\u2264 m\u2264n o\u2264p)\n\n+-mono\u02e1-\u2264 : RightMonotonic _\u2264_ _\u2264_ _+_\n+-mono\u02e1-\u2264 = mono\u2082\u21d2mono\u02b3 _ _ _\u2264_ \u2264-refl +-mono-\u2264\n\n+-mono\u02b3-\u2264 : LeftMonotonic _\u2264_ _\u2264_ _+_\n+-mono\u02b3-\u2264 = mono\u2082\u21d2mono\u02e1 _ _ _\u2264_ \u2264-refl +-mono-\u2264\n\n+-mono-&lt;-\u2264 : Monotonic\u2082 _&lt;_ _\u2264_ _&lt;_ _+_\n+-mono-&lt;-\u2264 {_} {suc n} z&lt;s               o\u2264p = s\u2264s (m\u2264n\u21d2m\u2264o+n n o\u2264p)\n+-mono-&lt;-\u2264 {_} {_}     (s&lt;s m&lt;n@(s\u2264s _)) o\u2264p = s\u2264s (+-mono-&lt;-\u2264 m&lt;n o\u2264p)\n\n+-mono-\u2264-&lt; : Monotonic\u2082 _\u2264_ _&lt;_ _&lt;_ _+_\n+-mono-\u2264-&lt; {_} {n} z\u2264n       o&lt;p = \u2264-trans o&lt;p (m\u2264n+m _ n)\n+-mono-\u2264-&lt; {_} {_} (s\u2264s m\u2264n) o&lt;p = s\u2264s (+-mono-\u2264-&lt; m\u2264n o&lt;p)\n\n+-mono-&lt; : Monotonic\u2082 _&lt;_ _&lt;_ _&lt;_ _+_\n+-mono-&lt; m\u2264n = +-mono-\u2264-&lt; (&lt;\u21d2\u2264 m\u2264n)\n\n+-mono\u02e1-&lt; : RightMonotonic _&lt;_ _&lt;_ _+_\n+-mono\u02e1-&lt; n = +-mono\u02e1-\u2264 n\n\n+-mono\u02b3-&lt; : LeftMonotonic _&lt;_ _&lt;_ _+_\n+-mono\u02b3-&lt; zero    m\u2264o = m\u2264o\n+-mono\u02b3-&lt; (suc n) m\u2264o = s\u2264s (+-mono\u02b3-&lt; n m\u2264o)\n\nm+1+n\u2270m : \u2200 m {n} \u2192 m + suc n \u2270 m\nm+1+n\u2270m (suc m) m+1+n\u2264m = m+1+n\u2270m m (s\u2264s\u207b\u00b9 m+1+n\u2264m)\n\nm&lt;m+n : \u2200 m {n} \u2192 n &gt; 0 \u2192 m &lt; m + n\nm&lt;m+n zero    n&gt;0 = n&gt;0\nm&lt;m+n (suc m) n&gt;0 = s&lt;s (m&lt;m+n m n&gt;0)\n\nm&lt;n+m : \u2200 m {n} \u2192 n &gt; 0 \u2192 m &lt; n + m\nm&lt;n+m m {n} n&gt;0 rewrite +-comm n m = m&lt;m+n m n&gt;0\n\nm+n\u226en : \u2200 m n \u2192 m + n \u226e n\nm+n\u226en zero    n                = n\u226en n\nm+n\u226en (suc m) n@(suc _) sm+n&lt;n = m+n\u226en m n (m&lt;n\u21d2m&lt;1+n (s&lt;s\u207b\u00b9 sm+n&lt;n))\n\nm+n\u226em : \u2200 m n \u2192 m + n \u226e m\nm+n\u226em m n = subst (_\u226e m) (+-comm n m) (m+n\u226en n m)\n\n------------------------------------------------------------------------\n-- Properties of _*_\n------------------------------------------------------------------------\n\n*-suc : \u2200 m n \u2192 m * suc n \u2261 m + m * n\n*-suc zero    n = refl\n*-suc (suc m) n = begin-equality\n  suc m * suc n         \u2261\u27e8\u27e9\n  suc n + m * suc n     \u2261\u27e8 cong (suc n +_) (*-suc m n) \u27e9\n  suc n + (m + m * n)   \u2261\u27e8\u27e9\n  suc (n + (m + m * n)) \u2261\u27e8 cong suc (sym (+-assoc n m (m * n))) \u27e9\n  suc (n + m + m * n)   \u2261\u27e8 cong (\u03bb x \u2192 suc (x + m * n)) (+-comm n m) \u27e9\n  suc (m + n + m * n)   \u2261\u27e8 cong suc (+-assoc m n (m * n)) \u27e9\n  suc (m + (n + m * n)) \u2261\u27e8\u27e9\n  suc m + suc m * n     \u220e\n\n------------------------------------------------------------------------\n-- Algebraic properties of _*_\n\n*-identity\u02e1 : LeftIdentity 1 _*_\n*-identity\u02e1 n = +-identity\u02b3 n\n\n*-identity\u02b3 : RightIdentity 1 _*_\n*-identity\u02b3 zero    = refl\n*-identity\u02b3 (suc n) = cong suc (*-identity\u02b3 n)\n\n*-identity : Identity 1 _*_\n*-identity = *-identity\u02e1 , *-identity\u02b3\n\n*-zero\u02e1 : LeftZero 0 _*_\n*-zero\u02e1 _ = refl\n\n*-zero\u02b3 : RightZero 0 _*_\n*-zero\u02b3 zero    = refl\n*-zero\u02b3 (suc n) = *-zero\u02b3 n\n\n*-zero : Zero 0 _*_\n*-zero = *-zero\u02e1 , *-zero\u02b3\n\n*-comm : Commutative _*_\n*-comm zero    n = sym (*-zero\u02b3 n)\n*-comm (suc m) n = begin-equality\n  suc m * n  \u2261\u27e8\u27e9\n  n + m * n  \u2261\u27e8 cong (n +_) (*-comm m n) \u27e9\n  n + n * m  \u2261\u27e8 sym (*-suc n m) \u27e9\n  n * suc m  \u220e\n\n*-distrib\u02b3-+ : _*_ DistributesOver\u02b3 _+_\n*-distrib\u02b3-+ m zero    o = refl\n*-distrib\u02b3-+ m (suc n) o = begin-equality\n  (suc n + o) * m     \u2261\u27e8\u27e9\n  m + (n + o) * m     \u2261\u27e8 cong (m +_) (*-distrib\u02b3-+ m n o) \u27e9\n  m + (n * m + o * m) \u2261\u27e8 sym (+-assoc m (n * m) (o * m)) \u27e9\n  m + n * m + o * m   \u2261\u27e8\u27e9\n  suc n * m + o * m   \u220e\n\n*-distrib\u02e1-+ : _*_ DistributesOver\u02e1 _+_\n*-distrib\u02e1-+ = comm\u2227distr\u02b3\u21d2distr\u02e1 *-comm *-distrib\u02b3-+\n\n*-distrib-+ : _*_ DistributesOver _+_\n*-distrib-+ = *-distrib\u02e1-+ , *-distrib\u02b3-+\n\n*-assoc : Associative _*_\n*-assoc zero    n o = refl\n*-assoc (suc m) n o = begin-equality\n  (suc m * n) * o     \u2261\u27e8\u27e9\n  (n + m * n) * o     \u2261\u27e8 *-distrib\u02b3-+ o n (m * n) \u27e9\n  n * o + (m * n) * o \u2261\u27e8 cong (n * o +_) (*-assoc m n o) \u27e9\n  n * o + m * (n * o) \u2261\u27e8\u27e9\n  suc m * (n * o)     \u220e\n\n------------------------------------------------------------------------\n-- Structures\n\n*-isMagma : IsMagma _*_\n*-isMagma = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = cong\u2082 _*_\n  }\n\n*-isSemigroup : IsSemigroup _*_\n*-isSemigroup = record\n  { isMagma = *-isMagma\n  ; assoc   = *-assoc\n  }\n\n*-isCommutativeSemigroup : IsCommutativeSemigroup _*_\n*-isCommutativeSemigroup = record\n  { isSemigroup = *-isSemigroup\n  ; comm        = *-comm\n  }\n\n*-1-isMonoid : IsMonoid _*_ 1\n*-1-isMonoid = record\n  { isSemigroup = *-isSemigroup\n  ; identity    = *-identity\n  }\n\n*-1-isCommutativeMonoid : IsCommutativeMonoid _*_ 1\n*-1-isCommutativeMonoid = record\n  { isMonoid = *-1-isMonoid\n  ; comm     = *-comm\n  }\n\n+-*-isSemiring : IsSemiring _+_ _*_ 0 1\n+-*-isSemiring = record\n  { isSemiringWithoutAnnihilatingZero = record\n    { +-isCommutativeMonoid = +-0-isCommutativeMonoid\n    ; *-cong                = cong\u2082 _*_\n    ; *-assoc               = *-assoc\n    ; *-identity            = *-identity\n    ; distrib               = *-distrib-+\n    }\n  ; zero = *-zero\n  }\n\n+-*-isCommutativeSemiring : IsCommutativeSemiring _+_ _*_ 0 1\n+-*-isCommutativeSemiring = record\n  { isSemiring = +-*-isSemiring\n  ; *-comm     = *-comm\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n*-magma : Magma 0\u2113 0\u2113\n*-magma = record\n  { isMagma = *-isMagma\n  }\n\n*-semigroup : Semigroup 0\u2113 0\u2113\n*-semigroup = record\n  { isSemigroup = *-isSemigroup\n  }\n\n*-commutativeSemigroup : CommutativeSemigroup 0\u2113 0\u2113\n*-commutativeSemigroup = record\n  { isCommutativeSemigroup = *-isCommutativeSemigroup\n  }\n\n*-1-monoid : Monoid 0\u2113 0\u2113\n*-1-monoid = record\n  { isMonoid = *-1-isMonoid\n  }\n\n*-1-commutativeMonoid : CommutativeMonoid 0\u2113 0\u2113\n*-1-commutativeMonoid = record\n  { isCommutativeMonoid = *-1-isCommutativeMonoid\n  }\n\n+-*-semiring : Semiring 0\u2113 0\u2113\n+-*-semiring = record\n  { isSemiring = +-*-isSemiring\n  }\n\n+-*-commutativeSemiring : CommutativeSemiring 0\u2113 0\u2113\n+-*-commutativeSemiring = record\n  { isCommutativeSemiring = +-*-isCommutativeSemiring\n  }\n\n------------------------------------------------------------------------\n-- Other properties of _*_ and _\u2261_\n\n*-cancel\u02b3-\u2261 : \u2200 m n o .{{_ : NonZero o}} \u2192 m * o \u2261 n * o \u2192 m \u2261 n\n*-cancel\u02b3-\u2261 zero    zero    (suc o) eq = refl\n*-cancel\u02b3-\u2261 (suc m) (suc n) (suc o) eq =\n  cong suc (*-cancel\u02b3-\u2261 m n (suc o) (+-cancel\u02e1-\u2261 (suc o) (m * suc o) (n * suc o) eq))\n\n*-cancel\u02e1-\u2261 : \u2200 m n o .{{_ : NonZero o}} \u2192 o * m \u2261 o * n \u2192 m \u2261 n\n*-cancel\u02e1-\u2261 m n o rewrite *-comm o m | *-comm o n = *-cancel\u02b3-\u2261 m n o\n\nm*n\u22610\u21d2m\u22610\u2228n\u22610 : \u2200 m {n} \u2192 m * n \u2261 0 \u2192 m \u2261 0 \u228e n \u2261 0\nm*n\u22610\u21d2m\u22610\u2228n\u22610 zero    {n}     eq = inj\u2081 refl\nm*n\u22610\u21d2m\u22610\u2228n\u22610 (suc m) {zero}  eq = inj\u2082 refl\n\nm*n\u22620 : \u2200 m n .{{_ : NonZero m}} .{{_ : NonZero n}} \u2192 NonZero (m * n)\nm*n\u22620 (suc m) (suc n) = _\n\nm*n\u22620\u21d2m\u22620 : \u2200 m {n} \u2192 .{{NonZero (m * n)}} \u2192 NonZero m\nm*n\u22620\u21d2m\u22620 (suc _) = _\n\nm*n\u22620\u21d2n\u22620 : \u2200 m {n} \u2192 .{{NonZero (m * n)}} \u2192 NonZero n\nm*n\u22620\u21d2n\u22620 m {n} rewrite *-comm m n = m*n\u22620\u21d2m\u22620 n {m}\n\nm*n\u22610\u21d2m\u22610 : \u2200 m n .{{_ : NonZero n}} \u2192 m * n \u2261 0 \u2192 m \u2261 0\nm*n\u22610\u21d2m\u22610 zero (suc _) eq = refl\n\nm*n\u22611\u21d2m\u22611 : \u2200 m n \u2192 m * n \u2261 1 \u2192 m \u2261 1\nm*n\u22611\u21d2m\u22611 (suc zero)    n          _  = refl\nm*n\u22611\u21d2m\u22611 (suc (suc m)) (suc zero) ()\nm*n\u22611\u21d2m\u22611 (suc (suc m)) zero       eq =\n  contradiction (trans (sym $ *-zero\u02b3 m) eq) \u03bb()\n\nm*n\u22611\u21d2n\u22611 : \u2200 m n \u2192 m * n \u2261 1 \u2192 n \u2261 1\nm*n\u22611\u21d2n\u22611 m n eq = m*n\u22611\u21d2m\u22611 n m (trans (*-comm n m) eq)\n\n[m*n]*[o*p]\u2261[m*o]*[n*p] : \u2200 m n o p \u2192 (m * n) * (o * p) \u2261 (m * o) * (n * p)\n[m*n]*[o*p]\u2261[m*o]*[n*p] m n o p = begin-equality\n  (m * n) * (o * p) \u2261\u27e8  *-assoc m n (o * p) \u27e9\n  m * (n * (o * p)) \u2261\u27e8  cong (m *_) (x\u2219yz\u2248y\u2219xz n o p) \u27e9\n  m * (o * (n * p)) \u2261\u27e8 *-assoc m o (n * p) \u27e8\n  (m * o) * (n * p) \u220e\n  where open CommSemigroupProperties *-commutativeSemigroup\n\nm\u22620\u2227n&gt;1\u21d2m*n&gt;1 : \u2200 m n .{{_ : NonZero m}} .{{_ : NonTrivial n}} \u2192 NonTrivial (m * n)\nm\u22620\u2227n&gt;1\u21d2m*n&gt;1 (suc m) (2+ n) = _\n\nn\u22620\u2227m&gt;1\u21d2m*n&gt;1 : \u2200 m n .{{_ : NonZero n}} .{{_ : NonTrivial m}} \u2192 NonTrivial (m * n)\nn\u22620\u2227m&gt;1\u21d2m*n&gt;1 m n rewrite *-comm m n = m\u22620\u2227n&gt;1\u21d2m*n&gt;1 n m\n\n------------------------------------------------------------------------\n-- Other properties of _*_ and _\u2264_/_&lt;_\n\n*-cancel\u02b3-\u2264 : \u2200 m n o .{{_ : NonZero o}} \u2192 m * o \u2264 n * o \u2192 m \u2264 n\n*-cancel\u02b3-\u2264 zero    _       _         _  = z\u2264n\n*-cancel\u02b3-\u2264 (suc m) (suc n) o@(suc _) le =\n  s\u2264s (*-cancel\u02b3-\u2264 m n o (+-cancel\u02e1-\u2264 _ _ _ le))\n\n*-cancel\u02e1-\u2264 : \u2200 o .{{_ : NonZero o}} \u2192 o * m \u2264 o * n \u2192 m \u2264 n\n*-cancel\u02e1-\u2264 {m} {n} o rewrite *-comm o m | *-comm o n = *-cancel\u02b3-\u2264 m n o\n\n*-mono-\u2264 : Monotonic\u2082 _\u2264_ _\u2264_ _\u2264_ _*_\n*-mono-\u2264 z\u2264n       u\u2264v = z\u2264n\n*-mono-\u2264 (s\u2264s m\u2264n) u\u2264v = +-mono-\u2264 u\u2264v (*-mono-\u2264 m\u2264n u\u2264v)\n\n*-mono\u02e1-\u2264 : RightMonotonic _\u2264_ _\u2264_ _*_\n*-mono\u02e1-\u2264 = mono\u2082\u21d2mono\u02b3 _ _ _\u2264_ \u2264-refl *-mono-\u2264\n\n*-mono\u02b3-\u2264 : LeftMonotonic _\u2264_ _\u2264_ _*_\n*-mono\u02b3-\u2264 = mono\u2082\u21d2mono\u02e1 _\u2264_ _\u2264_ _\u2264_ \u2264-refl *-mono-\u2264\n\n*-mono-&lt; : Monotonic\u2082 _&lt;_ _&lt;_ _&lt;_ _*_\n*-mono-&lt; z&lt;s               u&lt;v@(s\u2264s _) = 0&lt;1+n\n*-mono-&lt; (s&lt;s m&lt;n@(s\u2264s _)) u&lt;v@(s\u2264s _) = +-mono-&lt; u&lt;v (*-mono-&lt; m&lt;n u&lt;v)\n\n*-mono\u02e1-&lt; : \u2200 n .{{_ : NonZero n}} \u2192 Monotonic\u2081 _&lt;_ _&lt;_ (_* n)\n*-mono\u02e1-&lt; n@(suc _) z&lt;s               = 0&lt;1+n\n*-mono\u02e1-&lt; n@(suc _) (s&lt;s m&lt;o@(s\u2264s _)) = +-mono-\u2264-&lt; \u2264-refl (*-mono\u02e1-&lt; n m&lt;o)\n\n*-mono\u02b3-&lt; : \u2200 n .{{_ : NonZero n}} \u2192 Monotonic\u2081 _&lt;_ _&lt;_ (n *_)\n*-mono\u02b3-&lt; (suc zero)      m&lt;o@(s\u2264s _) = +-mono-\u2264 m&lt;o z\u2264n\n*-mono\u02b3-&lt; (suc n@(suc _)) m&lt;o@(s\u2264s _) = +-mono-\u2264 m&lt;o (&lt;\u21d2\u2264 (*-mono\u02b3-&lt; n m&lt;o))\n\nm\u2264m*n : \u2200 m n .{{_ : NonZero n}} \u2192 m \u2264 m * n\nm\u2264m*n m n@(suc _) = begin\n  m     \u2261\u27e8 sym (*-identity\u02b3 m) \u27e9\n  m * 1 \u2264\u27e8 *-mono\u02b3-\u2264 m 0&lt;1+n \u27e9\n  m * n \u220e\n\nm\u2264n*m : \u2200 m n .{{_ : NonZero n}} \u2192 m \u2264 n * m\nm\u2264n*m m n@(suc _) = begin\n  m     \u2264\u27e8 m\u2264m*n m n \u27e9\n  m * n \u2261\u27e8 *-comm m n \u27e9\n  n * m \u220e\n\nm\u2264n\u21d2m\u2264o*n : \u2200 o .{{_ : NonZero o}} \u2192 m \u2264 n \u2192 m \u2264 o * n\nm\u2264n\u21d2m\u2264o*n o m\u2264n = \u2264-trans m\u2264n (m\u2264n*m _ o)\n\nm\u2264n\u21d2m\u2264n*o : \u2200 o .{{_ : NonZero o}} \u2192 m \u2264 n \u2192 m \u2264 n * o\nm\u2264n\u21d2m\u2264n*o o m\u2264n = \u2264-trans m\u2264n (m\u2264m*n _ o)\n\nm&lt;m*n : \u2200 m n .{{_ : NonZero m}} \u2192 1 &lt; n \u2192 m &lt; m * n\nm&lt;m*n m@(suc m-1) n@(suc (suc n-2)) (s\u2264s (s\u2264s _)) = begin-strict\n  m           &lt;\u27e8 s\u2264s (s\u2264s (m\u2264n+m m-1 n-2)) \u27e9\n  n + m-1     \u2264\u27e8 +-mono\u02b3-\u2264 n (m\u2264m*n m-1 n) \u27e9\n  n + m-1 * n \u2261\u27e8\u27e9\n  m * n       \u220e\n\nm&lt;n\u21d2m&lt;n*o : \u2200 o .{{_ : NonZero o}} \u2192 m &lt; n \u2192 m &lt; n * o\nm&lt;n\u21d2m&lt;n*o = m\u2264n\u21d2m\u2264n*o\n\nm&lt;n\u21d2m&lt;o*n : \u2200 {m n} o .{{_ : NonZero o}} \u2192 m &lt; n \u2192 m &lt; o * n\nm&lt;n\u21d2m&lt;o*n = m\u2264n\u21d2m\u2264o*n\n\n*-cancel\u02b3-&lt; : RightCancellative _&lt;_ _*_\n*-cancel\u02b3-&lt; zero    zero    (suc o) _     = 0&lt;1+n\n*-cancel\u02b3-&lt; (suc m) zero    (suc o) _     = 0&lt;1+n\n*-cancel\u02b3-&lt; m       (suc n) (suc o) nm&lt;om =\n  s\u2264s (*-cancel\u02b3-&lt; m n o (+-cancel\u02e1-&lt; m _ _ nm&lt;om))\n\n*-cancel\u02e1-&lt; : LeftCancellative _&lt;_ _*_\n*-cancel\u02e1-&lt; x y z rewrite *-comm x y | *-comm x z = *-cancel\u02b3-&lt; x y z\n\n*-cancel-&lt; : Cancellative _&lt;_ _*_\n*-cancel-&lt; = *-cancel\u02e1-&lt; , *-cancel\u02b3-&lt;\n\n------------------------------------------------------------------------\n-- Properties of _^_\n------------------------------------------------------------------------\n\n^-identity\u02b3 : RightIdentity 1 _^_\n^-identity\u02b3 zero    = refl\n^-identity\u02b3 (suc n) = cong suc (^-identity\u02b3 n)\n\n^-zero\u02e1 : LeftZero 1 _^_\n^-zero\u02e1 zero    = refl\n^-zero\u02e1 (suc n) = begin-equality\n  1 ^ suc n   \u2261\u27e8\u27e9\n  1 * (1 ^ n) \u2261\u27e8 *-identity\u02e1 (1 ^ n) \u27e9\n  1 ^ n       \u2261\u27e8 ^-zero\u02e1 n \u27e9\n  1           \u220e\n\n^-distrib\u02e1-+-* : \u2200 m n o \u2192 m ^ (n + o) \u2261 m ^ n * m ^ o\n^-distrib\u02e1-+-* m zero    o = sym (+-identity\u02b3 (m ^ o))\n^-distrib\u02e1-+-* m (suc n) o = begin-equality\n  m * (m ^ (n + o))       \u2261\u27e8 cong (m *_) (^-distrib\u02e1-+-* m n o) \u27e9\n  m * ((m ^ n) * (m ^ o)) \u2261\u27e8 sym (*-assoc m _ _) \u27e9\n  (m * (m ^ n)) * (m ^ o) \u220e\n\n^-semigroup-morphism : \u2200 {n} \u2192 (n ^_) Is +-semigroup -Semigroup\u27f6 *-semigroup\n^-semigroup-morphism = record\n  { \u27e6\u27e7-cong = cong (_ ^_)\n  ; \u2219-homo  = ^-distrib\u02e1-+-* _\n  }\n\n^-monoid-morphism : \u2200 {n} \u2192 (n ^_) Is +-0-monoid -Monoid\u27f6 *-1-monoid\n^-monoid-morphism = record\n  { sm-homo = ^-semigroup-morphism\n  ; \u03b5-homo  = refl\n  }\n\n^-*-assoc : \u2200 m n o \u2192 (m ^ n) ^ o \u2261 m ^ (n * o)\n^-*-assoc m n zero    = cong (m ^_) (sym $ *-zero\u02b3 n)\n^-*-assoc m n (suc o) = begin-equality\n  (m ^ n) * ((m ^ n) ^ o) \u2261\u27e8 cong ((m ^ n) *_) (^-*-assoc m n o) \u27e9\n  (m ^ n) * (m ^ (n * o)) \u2261\u27e8 sym (^-distrib\u02e1-+-* m n (n * o)) \u27e9\n  m ^ (n + n * o)         \u2261\u27e8 cong (m ^_) (sym (*-suc n o)) \u27e9\n  m ^ (n * (suc o)) \u220e\n\nm^n\u22610\u21d2m\u22610 : \u2200 m n \u2192 m ^ n \u2261 0 \u2192 m \u2261 0\nm^n\u22610\u21d2m\u22610 m (suc n) eq = [ id , m^n\u22610\u21d2m\u22610 m n ]\u2032 (m*n\u22610\u21d2m\u22610\u2228n\u22610 m eq)\n\nm^n\u22611\u21d2n\u22610\u2228m\u22611 : \u2200 m n \u2192 m ^ n \u2261 1 \u2192 n \u2261 0 \u228e m \u2261 1\nm^n\u22611\u21d2n\u22610\u2228m\u22611 m zero    _  = inj\u2081 refl\nm^n\u22611\u21d2n\u22610\u2228m\u22611 m (suc n) eq = inj\u2082 (m*n\u22611\u21d2m\u22611 m (m ^ n) eq)\n\nm^n\u22620 : \u2200 m n .{{_ : NonZero m}} \u2192 NonZero (m ^ n)\nm^n\u22620 m n = \u2262-nonZero (\u2262-nonZero\u207b\u00b9 m \u2218\u2032 m^n\u22610\u21d2m\u22610 m n)\n\nm^n&gt;0 : \u2200 m .{{_ : NonZero m}} n \u2192 m ^ n &gt; 0\nm^n&gt;0 m n = &gt;-nonZero\u207b\u00b9 (m ^ n) {{m^n\u22620 m n}}\n\n^-mono\u02e1-\u2264 : RightMonotonic _\u2264_ _\u2264_ _^_\n^-mono\u02e1-\u2264 zero m\u2264o = s\u2264s z\u2264n\n^-mono\u02e1-\u2264 (suc n) m\u2264o = *-mono-\u2264 m\u2264o (^-mono\u02e1-\u2264 n m\u2264o)\n\n^-mono\u02b3-\u2264 : \u2200 m .{{_ : NonZero m}} \u2192 Monotonic\u2081 _\u2264_ _\u2264_ (m ^_)\n^-mono\u02b3-\u2264 m {_} {o} z\u2264n = n\u22620\u21d2n&gt;0 (\u2262-nonZero\u207b\u00b9 (m ^ o) {{m^n\u22620 m o}})\n^-mono\u02b3-\u2264 m (s\u2264s n\u2264o) = *-mono\u02b3-\u2264 m (^-mono\u02b3-\u2264 m n\u2264o)\n\n^-mono\u02e1-&lt; : \u2200 n .{{_ : NonZero n}} \u2192 Monotonic\u2081 _&lt;_ _&lt;_ (_^ n)\n^-mono\u02e1-&lt; (suc zero)      m&lt;o = *-mono\u02e1-&lt; 1 m&lt;o\n^-mono\u02e1-&lt; (suc n@(suc _)) m&lt;o = *-mono-&lt; m&lt;o (^-mono\u02e1-&lt; n m&lt;o)\n\n^-mono\u02b3-&lt; : \u2200 m \u2192 1 &lt; m \u2192 Monotonic\u2081 _&lt;_ _&lt;_ (m ^_)\n^-mono\u02b3-&lt; m@(suc _) 1&lt;m {zero}  {suc o} z&lt;s       = *-mono-\u2264 1&lt;m (m^n&gt;0 m o)\n^-mono\u02b3-&lt; m@(suc _) 1&lt;m {suc n} {suc o} (s&lt;s n&lt;o) = *-mono\u02b3-&lt; m (^-mono\u02b3-&lt; m 1&lt;m n&lt;o)\n\n------------------------------------------------------------------------\n-- Properties of _\u2293_ and _\u2294_\n------------------------------------------------------------------------\n-- Basic specification in terms of _\u2264_\n\nm\u2264n\u21d2m\u2294n\u2261n : m \u2264 n \u2192 m \u2294 n \u2261 n\nm\u2264n\u21d2m\u2294n\u2261n {zero}  _         = refl\nm\u2264n\u21d2m\u2294n\u2261n {suc m} (s\u2264s m\u2264n) = cong suc (m\u2264n\u21d2m\u2294n\u2261n m\u2264n)\n\nm\u2265n\u21d2m\u2294n\u2261m : m \u2265 n \u2192 m \u2294 n \u2261 m\nm\u2265n\u21d2m\u2294n\u2261m {zero}  {zero}  z\u2264n       = refl\nm\u2265n\u21d2m\u2294n\u2261m {suc m} {zero}  z\u2264n       = refl\nm\u2265n\u21d2m\u2294n\u2261m {suc m} {suc n} (s\u2264s m\u2265n) = cong suc (m\u2265n\u21d2m\u2294n\u2261m m\u2265n)\n\nm\u2264n\u21d2m\u2293n\u2261m : m \u2264 n \u2192 m \u2293 n \u2261 m\nm\u2264n\u21d2m\u2293n\u2261m {zero}  z\u2264n       = refl\nm\u2264n\u21d2m\u2293n\u2261m {suc m} (s\u2264s m\u2264n) = cong suc (m\u2264n\u21d2m\u2293n\u2261m m\u2264n)\n\nm\u2265n\u21d2m\u2293n\u2261n : m \u2265 n \u2192 m \u2293 n \u2261 n\nm\u2265n\u21d2m\u2293n\u2261n {zero}  {zero}  z\u2264n       = refl\nm\u2265n\u21d2m\u2293n\u2261n {suc m} {zero}  z\u2264n       = refl\nm\u2265n\u21d2m\u2293n\u2261n {suc m} {suc n} (s\u2264s m\u2264n) = cong suc (m\u2265n\u21d2m\u2293n\u2261n m\u2264n)\n\n\u2293-operator : MinOperator \u2264-totalPreorder\n\u2293-operator = record\n  { x\u2264y\u21d2x\u2293y\u2248x = m\u2264n\u21d2m\u2293n\u2261m\n  ; x\u2265y\u21d2x\u2293y\u2248y = m\u2265n\u21d2m\u2293n\u2261n\n  }\n\n\u2294-operator : MaxOperator \u2264-totalPreorder\n\u2294-operator = record\n  { x\u2264y\u21d2x\u2294y\u2248y = m\u2264n\u21d2m\u2294n\u2261n\n  ; x\u2265y\u21d2x\u2294y\u2248x = m\u2265n\u21d2m\u2294n\u2261m\n  }\n\n------------------------------------------------------------------------\n-- Equality to their counterparts defined in terms of primitive operations\n\n\u2294\u2261\u2294\u2032 : \u2200 m n \u2192 m \u2294 n \u2261 m \u2294\u2032 n\n\u2294\u2261\u2294\u2032 m n with m &lt;\u1d47 n in eq\n... | false = m\u2265n\u21d2m\u2294n\u2261m (\u226e\u21d2\u2265 (\u03bb m&lt;n \u2192 subst T eq (&lt;\u21d2&lt;\u1d47 m&lt;n)))\n... | true  = m\u2264n\u21d2m\u2294n\u2261n (&lt;\u21d2\u2264 (&lt;\u1d47\u21d2&lt; m n (subst T (sym eq) _)))\n\n\u2293\u2261\u2293\u2032 : \u2200 m n \u2192 m \u2293 n \u2261 m \u2293\u2032 n\n\u2293\u2261\u2293\u2032 m n with m &lt;\u1d47 n in eq\n... | false = m\u2265n\u21d2m\u2293n\u2261n (\u226e\u21d2\u2265 (\u03bb m&lt;n \u2192 subst T eq (&lt;\u21d2&lt;\u1d47 m&lt;n)))\n... | true  = m\u2264n\u21d2m\u2293n\u2261m (&lt;\u21d2\u2264 (&lt;\u1d47\u21d2&lt; m n (subst T (sym eq) _)))\n\n------------------------------------------------------------------------\n-- Derived properties of _\u2293_ and _\u2294_\n\nprivate\n  module \u2293-\u2294-properties        = MinMaxOp        \u2293-operator \u2294-operator\n  module \u2293-\u2294-latticeProperties = LatticeMinMaxOp \u2293-operator \u2294-operator\n\nopen \u2293-\u2294-properties public\n  using\n  ( \u2293-idem                    -- : Idempotent _\u2293_\n  ; \u2293-sel                     -- : Selective _\u2293_\n  ; \u2293-assoc                   -- : Associative _\u2293_\n  ; \u2293-comm                    -- : Commutative _\u2293_\n\n  ; \u2294-idem                    -- : Idempotent _\u2294_\n  ; \u2294-sel                     -- : Selective _\u2294_\n  ; \u2294-assoc                   -- : Associative _\u2294_\n  ; \u2294-comm                    -- : Commutative _\u2294_\n\n  ; \u2293-distrib\u02e1-\u2294              -- : _\u2293_ DistributesOver\u02e1 _\u2294_\n  ; \u2293-distrib\u02b3-\u2294              -- : _\u2293_ DistributesOver\u02b3 _\u2294_\n  ; \u2293-distrib-\u2294               -- : _\u2293_ DistributesOver  _\u2294_\n  ; \u2294-distrib\u02e1-\u2293              -- : _\u2294_ DistributesOver\u02e1 _\u2293_\n  ; \u2294-distrib\u02b3-\u2293              -- : _\u2294_ DistributesOver\u02b3 _\u2293_\n  ; \u2294-distrib-\u2293               -- : _\u2294_ DistributesOver  _\u2293_\n  ; \u2293-absorbs-\u2294               -- : _\u2293_ Absorbs _\u2294_\n  ; \u2294-absorbs-\u2293               -- : _\u2294_ Absorbs _\u2293_\n  ; \u2294-\u2293-absorptive            -- : Absorptive _\u2294_ _\u2293_\n  ; \u2293-\u2294-absorptive            -- : Absorptive _\u2293_ _\u2294_\n\n  ; \u2293-isMagma                 -- : IsMagma _\u2293_\n  ; \u2293-isSemigroup             -- : IsSemigroup _\u2293_\n  ; \u2293-isCommutativeSemigroup  -- : IsCommutativeSemigroup _\u2293_\n  ; \u2293-isBand                  -- : IsBand _\u2293_\n  ; \u2293-isSelectiveMagma        -- : IsSelectiveMagma _\u2293_\n\n  ; \u2294-isMagma                 -- : IsMagma _\u2294_\n  ; \u2294-isSemigroup             -- : IsSemigroup _\u2294_\n  ; \u2294-isCommutativeSemigroup  -- : IsCommutativeSemigroup _\u2294_\n  ; \u2294-isBand                  -- : IsBand _\u2294_\n  ; \u2294-isSelectiveMagma        -- : IsSelectiveMagma _\u2294_\n\n  ; \u2293-magma                   -- : Magma _ _\n  ; \u2293-semigroup               -- : Semigroup _ _\n  ; \u2293-band                    -- : Band _ _\n  ; \u2293-commutativeSemigroup    -- : CommutativeSemigroup _ _\n  ; \u2293-selectiveMagma          -- : SelectiveMagma _ _\n\n  ; \u2294-magma                   -- : Magma _ _\n  ; \u2294-semigroup               -- : Semigroup _ _\n  ; \u2294-band                    -- : Band _ _\n  ; \u2294-commutativeSemigroup    -- : CommutativeSemigroup _ _\n  ; \u2294-selectiveMagma          -- : SelectiveMagma _ _\n\n  ; \u2293-glb                     -- : \u2200 {m n o} \u2192 m \u2265 o \u2192 n \u2265 o \u2192 m \u2293 n \u2265 o\n  ; \u2293-triangulate             -- : \u2200 m n o \u2192 m \u2293 n \u2293 o \u2261 (m \u2293 n) \u2293 (n \u2293 o)\n  ; \u2293-mono-\u2264                  -- : _\u2293_ Preserves\u2082 _\u2264_ \u27f6 _\u2264_ \u27f6 _\u2264_\n  ; \u2293-mono\u02e1-\u2264                 -- : \u2200 n \u2192 (_\u2293 n) Preserves _\u2264_ \u27f6 _\u2264_\n  ; \u2293-mono\u02b3-\u2264                 -- : \u2200 n \u2192 (n \u2293_) Preserves _\u2264_ \u27f6 _\u2264_\n\n  ; \u2294-lub                     -- : \u2200 {m n o} \u2192 m \u2264 o \u2192 n \u2264 o \u2192 m \u2294 n \u2264 o\n  ; \u2294-triangulate             -- : \u2200 m n o \u2192 m \u2294 n \u2294 o \u2261 (m \u2294 n) \u2294 (n \u2294 o)\n  ; \u2294-mono-\u2264                  -- : _\u2294_ Preserves\u2082 _\u2264_ \u27f6 _\u2264_ \u27f6 _\u2264_\n  ; \u2294-mono\u02e1-\u2264                 -- : \u2200 n \u2192 (_\u2294 n) Preserves _\u2264_ \u27f6 _\u2264_\n  ; \u2294-mono\u02b3-\u2264                 -- : \u2200 n \u2192 (n \u2294_) Preserves _\u2264_ \u27f6 _\u2264_\n  )\n  renaming\n  ( x\u2293y\u2248y\u21d2y\u2264x to m\u2293n\u2261n\u21d2n\u2264m    -- : \u2200 {m n} \u2192 m \u2293 n \u2261 n \u2192 n \u2264 m\n  ; x\u2293y\u2248x\u21d2x\u2264y to m\u2293n\u2261m\u21d2m\u2264n    -- : \u2200 {m n} \u2192 m \u2293 n \u2261 m \u2192 m \u2264 n\n  ; x\u2293y\u2264x     to m\u2293n\u2264m        -- : \u2200 m n \u2192 m \u2293 n \u2264 m\n  ; x\u2293y\u2264y     to m\u2293n\u2264n        -- : \u2200 m n \u2192 m \u2293 n \u2264 n\n  ; x\u2264y\u21d2x\u2293z\u2264y to m\u2264n\u21d2m\u2293o\u2264n    -- : \u2200 {m n} o \u2192 m \u2264 n \u2192 m \u2293 o \u2264 n\n  ; x\u2264y\u21d2z\u2293x\u2264y to m\u2264n\u21d2o\u2293m\u2264n    -- : \u2200 {m n} o \u2192 m \u2264 n \u2192 o \u2293 m \u2264 n\n  ; x\u2264y\u2293z\u21d2x\u2264y to m\u2264n\u2293o\u21d2m\u2264n    -- : \u2200 {m} n o \u2192 m \u2264 n \u2293 o \u2192 m \u2264 n\n  ; x\u2264y\u2293z\u21d2x\u2264z to m\u2264n\u2293o\u21d2m\u2264o    -- : \u2200 {m} n o \u2192 m \u2264 n \u2293 o \u2192 m \u2264 o\n\n  ; x\u2294y\u2248y\u21d2x\u2264y to m\u2294n\u2261n\u21d2m\u2264n    -- : \u2200 {m n} \u2192 m \u2294 n \u2261 n \u2192 m \u2264 n\n  ; x\u2294y\u2248x\u21d2y\u2264x to m\u2294n\u2261m\u21d2n\u2264m    -- : \u2200 {m n} \u2192 m \u2294 n \u2261 m \u2192 n \u2264 m\n  ; x\u2264x\u2294y     to m\u2264m\u2294n        -- : \u2200 m n \u2192 m \u2264 m \u2294 n\n  ; x\u2264y\u2294x     to m\u2264n\u2294m        -- : \u2200 m n \u2192 m \u2264 n \u2294 m\n  ; x\u2264y\u21d2x\u2264y\u2294z to m\u2264n\u21d2m\u2264n\u2294o    -- : \u2200 {m n} o \u2192 m \u2264 n \u2192 m \u2264 n \u2294 o\n  ; x\u2264y\u21d2x\u2264z\u2294y to m\u2264n\u21d2m\u2264o\u2294n    -- : \u2200 {m n} o \u2192 m \u2264 n \u2192 m \u2264 o \u2294 n\n  ; x\u2294y\u2264z\u21d2x\u2264z to m\u2294n\u2264o\u21d2m\u2264o    -- : \u2200 m n {o} \u2192 m \u2294 n \u2264 o \u2192 m \u2264 o\n  ; x\u2294y\u2264z\u21d2y\u2264z to m\u2294n\u2264o\u21d2n\u2264o    -- : \u2200 m n {o} \u2192 m \u2294 n \u2264 o \u2192 n \u2264 o\n\n  ; x\u2293y\u2264x\u2294y   to m\u2293n\u2264m\u2294n      -- : \u2200 m n \u2192 m \u2293 n \u2264 m \u2294 n\n  )\n\nopen \u2293-\u2294-latticeProperties public\n  using\n  ( \u2293-isSemilattice           -- : IsSemilattice _\u2293_\n  ; \u2294-isSemilattice           -- : IsSemilattice _\u2294_\n  ; \u2294-\u2293-isLattice             -- : IsLattice _\u2294_ _\u2293_\n  ; \u2293-\u2294-isLattice             -- : IsLattice _\u2293_ _\u2294_\n  ; \u2294-\u2293-isDistributiveLattice -- : IsDistributiveLattice _\u2294_ _\u2293_\n  ; \u2293-\u2294-isDistributiveLattice -- : IsDistributiveLattice _\u2293_ _\u2294_\n\n  ; \u2293-semilattice             -- : Semilattice _ _\n  ; \u2294-semilattice             -- : Semilattice _ _\n  ; \u2294-\u2293-lattice               -- : Lattice _ _\n  ; \u2293-\u2294-lattice               -- : Lattice _ _\n  ; \u2294-\u2293-distributiveLattice   -- : DistributiveLattice _ _\n  ; \u2293-\u2294-distributiveLattice   -- : DistributiveLattice _ _\n  )\n\n------------------------------------------------------------------------\n-- Automatically derived properties of _\u2293_ and _\u2294_\n\n\u2294-identity\u02e1 : LeftIdentity 0 _\u2294_\n\u2294-identity\u02e1 _ = refl\n\n\u2294-identity\u02b3 : RightIdentity 0 _\u2294_\n\u2294-identity\u02b3 zero    = refl\n\u2294-identity\u02b3 (suc n) = refl\n\n\u2294-identity : Identity 0 _\u2294_\n\u2294-identity = \u2294-identity\u02e1 , \u2294-identity\u02b3\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2294-0-isMonoid : IsMonoid _\u2294_ 0\n\u2294-0-isMonoid = record\n  { isSemigroup = \u2294-isSemigroup\n  ; identity    = \u2294-identity\n  }\n\n\u2294-0-isCommutativeMonoid : IsCommutativeMonoid _\u2294_ 0\n\u2294-0-isCommutativeMonoid = record\n  { isMonoid = \u2294-0-isMonoid\n  ; comm     = \u2294-comm\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2294-0-monoid : Monoid 0\u2113 0\u2113\n\u2294-0-monoid = record\n  { isMonoid = \u2294-0-isMonoid\n  }\n\n\u2294-0-commutativeMonoid : CommutativeMonoid 0\u2113 0\u2113\n\u2294-0-commutativeMonoid = record\n  { isCommutativeMonoid = \u2294-0-isCommutativeMonoid\n  }\n\n------------------------------------------------------------------------\n-- Other properties of _\u2294_ and _\u2264_/_&lt;_\n\nmono-\u2264-distrib-\u2294 : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2264_ \u2192\n                   \u2200 m n \u2192 f (m \u2294 n) \u2261 f m \u2294 f n\nmono-\u2264-distrib-\u2294 {f} = \u2293-\u2294-properties.mono-\u2264-distrib-\u2294 (cong f)\n\nmono-\u2264-distrib-\u2293 : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2264_ \u2192\n                   \u2200 m n \u2192 f (m \u2293 n) \u2261 f m \u2293 f n\nmono-\u2264-distrib-\u2293 {f} = \u2293-\u2294-properties.mono-\u2264-distrib-\u2293 (cong f)\n\nantimono-\u2264-distrib-\u2293 : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2265_ \u2192\n                       \u2200 m n \u2192 f (m \u2293 n) \u2261 f m \u2294 f n\nantimono-\u2264-distrib-\u2293 {f} = \u2293-\u2294-properties.antimono-\u2264-distrib-\u2293 (cong f)\n\nantimono-\u2264-distrib-\u2294 : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2265_ \u2192\n                       \u2200 m n \u2192 f (m \u2294 n) \u2261 f m \u2293 f n\nantimono-\u2264-distrib-\u2294 {f} = \u2293-\u2294-properties.antimono-\u2264-distrib-\u2294 (cong f)\n\nm&lt;n\u21d2m&lt;n\u2294o : \u2200 o \u2192 m &lt; n \u2192 m &lt; n \u2294 o\nm&lt;n\u21d2m&lt;n\u2294o = m\u2264n\u21d2m\u2264n\u2294o\n\nm&lt;n\u21d2m&lt;o\u2294n : \u2200 o \u2192 m &lt; n \u2192 m &lt; o \u2294 n\nm&lt;n\u21d2m&lt;o\u2294n = m\u2264n\u21d2m\u2264o\u2294n\n\nm\u2294n&lt;o\u21d2m&lt;o : \u2200 m n {o} \u2192 m \u2294 n &lt; o \u2192 m &lt; o\nm\u2294n&lt;o\u21d2m&lt;o m n m\u2294n&lt;o = \u2264-&lt;-trans (m\u2264m\u2294n m n) m\u2294n&lt;o\n\nm\u2294n&lt;o\u21d2n&lt;o : \u2200 m n {o} \u2192 m \u2294 n &lt; o \u2192 n &lt; o\nm\u2294n&lt;o\u21d2n&lt;o m n m\u2294n&lt;o = \u2264-&lt;-trans (m\u2264n\u2294m m n) m\u2294n&lt;o\n\n\u2294-mono-&lt; : _\u2294_ Preserves\u2082 _&lt;_ \u27f6 _&lt;_ \u27f6 _&lt;_\n\u2294-mono-&lt; = \u2294-mono-\u2264\n\n\u2294-pres-&lt;m : n &lt; m \u2192 o &lt; m \u2192 n \u2294 o &lt; m\n\u2294-pres-&lt;m {m = m} n&lt;m o&lt;m = subst (_ &lt;_) (\u2294-idem m) (\u2294-mono-&lt; n&lt;m o&lt;m)\n\n------------------------------------------------------------------------\n-- Other properties of _\u2294_ and _+_\n\n+-distrib\u02e1-\u2294 : _+_ DistributesOver\u02e1 _\u2294_\n+-distrib\u02e1-\u2294 zero    n o = refl\n+-distrib\u02e1-\u2294 (suc m) n o = cong suc (+-distrib\u02e1-\u2294 m n o)\n\n+-distrib\u02b3-\u2294 : _+_ DistributesOver\u02b3 _\u2294_\n+-distrib\u02b3-\u2294 = comm\u2227distr\u02e1\u21d2distr\u02b3 +-comm +-distrib\u02e1-\u2294\n\n+-distrib-\u2294 : _+_ DistributesOver _\u2294_\n+-distrib-\u2294 = +-distrib\u02e1-\u2294 , +-distrib\u02b3-\u2294\n\nm\u2294n\u2264m+n : \u2200 m n \u2192 m \u2294 n \u2264 m + n\nm\u2294n\u2264m+n m n with \u2294-sel m n\n... | inj\u2081 m\u2294n\u2261m rewrite m\u2294n\u2261m = m\u2264m+n m n\n... | inj\u2082 m\u2294n\u2261n rewrite m\u2294n\u2261n = m\u2264n+m n m\n\n------------------------------------------------------------------------\n-- Other properties of _\u2294_ and _*_\n\n*-distrib\u02e1-\u2294 : _*_ DistributesOver\u02e1 _\u2294_\n*-distrib\u02e1-\u2294 m zero o = sym (cong (_\u2294 m * o) (*-zero\u02b3 m))\n*-distrib\u02e1-\u2294 m (suc n) zero = begin-equality\n  m * (suc n \u2294 zero)         \u2261\u27e8\u27e9\n  m * suc n                  \u2261\u27e8 \u2294-identity\u02b3 (m * suc n) \u27e8\n  m * suc n \u2294 zero           \u2261\u27e8 cong (m * suc n \u2294_) (*-zero\u02b3 m) \u27e8\n  m * suc n \u2294 m * zero       \u220e\n*-distrib\u02e1-\u2294 m (suc n) (suc o) = begin-equality\n  m * (suc n \u2294 suc o)        \u2261\u27e8\u27e9\n  m * suc (n \u2294 o)            \u2261\u27e8 *-suc m (n \u2294 o) \u27e9\n  m + m * (n \u2294 o)            \u2261\u27e8 cong (m +_) (*-distrib\u02e1-\u2294 m n o) \u27e9\n  m + (m * n \u2294 m * o)        \u2261\u27e8 +-distrib\u02e1-\u2294 m (m * n) (m * o) \u27e9\n  (m + m * n) \u2294 (m + m * o)  \u2261\u27e8 cong\u2082 _\u2294_ (*-suc m n) (*-suc m o) \u27e8\n  (m * suc n) \u2294 (m * suc o)  \u220e\n\n*-distrib\u02b3-\u2294 : _*_ DistributesOver\u02b3 _\u2294_\n*-distrib\u02b3-\u2294 = comm\u2227distr\u02e1\u21d2distr\u02b3 *-comm *-distrib\u02e1-\u2294\n\n*-distrib-\u2294 : _*_ DistributesOver _\u2294_\n*-distrib-\u2294 = *-distrib\u02e1-\u2294 , *-distrib\u02b3-\u2294\n\n------------------------------------------------------------------------\n-- Properties of _\u2293_\n------------------------------------------------------------------------\n\n------------------------------------------------------------------------\n-- Algebraic properties\n\n\u2293-zero\u02e1 : LeftZero 0 _\u2293_\n\u2293-zero\u02e1 _ = refl\n\n\u2293-zero\u02b3 : RightZero 0 _\u2293_\n\u2293-zero\u02b3 zero    = refl\n\u2293-zero\u02b3 (suc n) = refl\n\n\u2293-zero : Zero 0 _\u2293_\n\u2293-zero = \u2293-zero\u02e1 , \u2293-zero\u02b3\n\n------------------------------------------------------------------------\n-- Structures\n\n\u2294-\u2293-isSemiringWithoutOne : IsSemiringWithoutOne _\u2294_ _\u2293_ 0\n\u2294-\u2293-isSemiringWithoutOne = record\n  { +-isCommutativeMonoid = \u2294-0-isCommutativeMonoid\n  ; *-cong                = cong\u2082 _\u2293_\n  ; *-assoc               = \u2293-assoc\n  ; distrib               = \u2293-distrib-\u2294\n  ; zero                  = \u2293-zero\n  }\n\n\u2294-\u2293-isCommutativeSemiringWithoutOne\n  : IsCommutativeSemiringWithoutOne _\u2294_ _\u2293_ 0\n\u2294-\u2293-isCommutativeSemiringWithoutOne = record\n  { isSemiringWithoutOne = \u2294-\u2293-isSemiringWithoutOne\n  ; *-comm               = \u2293-comm\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\n\u2294-\u2293-commutativeSemiringWithoutOne : CommutativeSemiringWithoutOne 0\u2113 0\u2113\n\u2294-\u2293-commutativeSemiringWithoutOne = record\n  { isCommutativeSemiringWithoutOne =\n      \u2294-\u2293-isCommutativeSemiringWithoutOne\n  }\n\n------------------------------------------------------------------------\n-- Other properties of _\u2293_ and _\u2264_/_&lt;_\n\nm&lt;n\u21d2m\u2293o&lt;n : \u2200 o \u2192 m &lt; n \u2192 m \u2293 o &lt; n\nm&lt;n\u21d2m\u2293o&lt;n o m&lt;n = \u2264-&lt;-trans (m\u2293n\u2264m _ o) m&lt;n\n\nm&lt;n\u21d2o\u2293m&lt;n : \u2200 o \u2192 m &lt; n \u2192 o \u2293 m &lt; n\nm&lt;n\u21d2o\u2293m&lt;n o m&lt;n = \u2264-&lt;-trans (m\u2293n\u2264n o _) m&lt;n\n\nm&lt;n\u2293o\u21d2m&lt;n : \u2200 n o \u2192 m &lt; n \u2293 o \u2192 m &lt; n\nm&lt;n\u2293o\u21d2m&lt;n = m\u2264n\u2293o\u21d2m\u2264n\n\nm&lt;n\u2293o\u21d2m&lt;o : \u2200 n o \u2192 m &lt; n \u2293 o \u2192 m &lt; o\nm&lt;n\u2293o\u21d2m&lt;o = m\u2264n\u2293o\u21d2m\u2264o\n\n\u2293-mono-&lt; : _\u2293_ Preserves\u2082 _&lt;_ \u27f6 _&lt;_ \u27f6 _&lt;_\n\u2293-mono-&lt; = \u2293-mono-\u2264\n\n\u2293-pres-m&lt; : m &lt; n \u2192 m &lt; o \u2192 m &lt; n \u2293 o\n\u2293-pres-m&lt; {m} m&lt;n m&lt;o = subst (_&lt; _) (\u2293-idem m) (\u2293-mono-&lt; m&lt;n m&lt;o)\n\n------------------------------------------------------------------------\n-- Other properties of _\u2293_ and _+_\n\n+-distrib\u02e1-\u2293 : _+_ DistributesOver\u02e1 _\u2293_\n+-distrib\u02e1-\u2293 zero    n o = refl\n+-distrib\u02e1-\u2293 (suc m) n o = cong suc (+-distrib\u02e1-\u2293 m n o)\n\n+-distrib\u02b3-\u2293 : _+_ DistributesOver\u02b3 _\u2293_\n+-distrib\u02b3-\u2293 = comm\u2227distr\u02e1\u21d2distr\u02b3 +-comm +-distrib\u02e1-\u2293\n\n+-distrib-\u2293 : _+_ DistributesOver _\u2293_\n+-distrib-\u2293 = +-distrib\u02e1-\u2293 , +-distrib\u02b3-\u2293\n\nm\u2293n\u2264m+n : \u2200 m n \u2192 m \u2293 n \u2264 m + n\nm\u2293n\u2264m+n m n with \u2293-sel m n\n... | inj\u2081 m\u2293n\u2261m rewrite m\u2293n\u2261m = m\u2264m+n m n\n... | inj\u2082 m\u2293n\u2261n rewrite m\u2293n\u2261n = m\u2264n+m n m\n\n------------------------------------------------------------------------\n-- Other properties of _\u2293_ and _*_\n\n*-distrib\u02e1-\u2293 : _*_ DistributesOver\u02e1 _\u2293_\n*-distrib\u02e1-\u2293 m 0 o = begin-equality\n  m * (0 \u2293 o)               \u2261\u27e8\u27e9\n  m * 0                     \u2261\u27e8 *-zero\u02b3 m \u27e9\n  0                         \u2261\u27e8\u27e9\n  0 \u2293 (m * o)               \u2261\u27e8 cong (_\u2293 (m * o)) (*-zero\u02b3 m) \u27e8\n  (m * 0) \u2293 (m * o)         \u220e\n*-distrib\u02e1-\u2293 m (suc n) 0 = begin-equality\n  m * (suc n \u2293 0)           \u2261\u27e8\u27e9\n  m * 0                     \u2261\u27e8 *-zero\u02b3 m \u27e9\n  0                         \u2261\u27e8 \u2293-zero\u02b3 (m * suc n) \u27e8\n  (m * suc n) \u2293 0           \u2261\u27e8 cong (m * suc n \u2293_) (*-zero\u02b3 m) \u27e8\n  (m * suc n) \u2293 (m * 0)     \u220e\n*-distrib\u02e1-\u2293 m (suc n) (suc o) = begin-equality\n  m * (suc n \u2293 suc o)       \u2261\u27e8\u27e9\n  m * suc (n \u2293 o)           \u2261\u27e8 *-suc m (n \u2293 o) \u27e9\n  m + m * (n \u2293 o)           \u2261\u27e8 cong (m +_) (*-distrib\u02e1-\u2293 m n o) \u27e9\n  m + (m * n) \u2293 (m * o)     \u2261\u27e8 +-distrib\u02e1-\u2293 m (m * n) (m * o) \u27e9\n  (m + m * n) \u2293 (m + m * o) \u2261\u27e8 cong\u2082 _\u2293_ (*-suc m n) (*-suc m o) \u27e8\n  (m * suc n) \u2293 (m * suc o) \u220e\n\n*-distrib\u02b3-\u2293 : _*_ DistributesOver\u02b3 _\u2293_\n*-distrib\u02b3-\u2293 = comm\u2227distr\u02e1\u21d2distr\u02b3 *-comm *-distrib\u02e1-\u2293\n\n*-distrib-\u2293 : _*_ DistributesOver _\u2293_\n*-distrib-\u2293 = *-distrib\u02e1-\u2293 , *-distrib\u02b3-\u2293\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_\n------------------------------------------------------------------------\n\n0\u2238n\u22610 : LeftZero zero _\u2238_\n0\u2238n\u22610 zero    = refl\n0\u2238n\u22610 (suc _) = refl\n\nn\u2238n\u22610 : \u2200 n \u2192 n \u2238 n \u2261 0\nn\u2238n\u22610 zero    = refl\nn\u2238n\u22610 (suc n) = n\u2238n\u22610 n\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_ and pred\n\npred[m\u2238n]\u2261m\u2238[1+n] : \u2200 m n \u2192 pred (m \u2238 n) \u2261 m \u2238 suc n\npred[m\u2238n]\u2261m\u2238[1+n] zero    zero    = refl\npred[m\u2238n]\u2261m\u2238[1+n] (suc m) zero    = refl\npred[m\u2238n]\u2261m\u2238[1+n] zero (suc n)    = refl\npred[m\u2238n]\u2261m\u2238[1+n] (suc m) (suc n) = pred[m\u2238n]\u2261m\u2238[1+n] m n\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_ and _\u2264_/_&lt;_\n\nm\u2238n\u2264m : \u2200 m n \u2192 m \u2238 n \u2264 m\nm\u2238n\u2264m n       zero    = \u2264-refl\nm\u2238n\u2264m zero    (suc n) = \u2264-refl\nm\u2238n\u2264m (suc m) (suc n) = \u2264-trans (m\u2238n\u2264m m n) (n\u22641+n m)\n\nm\u226em\u2238n : \u2200 m n \u2192 m \u226e m \u2238 n\nm\u226em\u2238n m       zero    = n\u226en m\nm\u226em\u2238n (suc m) (suc n) = m\u226em\u2238n m n \u2218 \u2264-trans (n\u22641+n (suc m))\n\n1+m\u2262m\u2238n : \u2200 {m} n \u2192 suc m \u2262 m \u2238 n\n1+m\u2262m\u2238n {m} n eq = m\u226em\u2238n m n (\u2264-reflexive eq)\n\n\u2238-mono : _\u2238_ Preserves\u2082 _\u2264_ \u27f6 _\u2265_ \u27f6 _\u2264_\n\u2238-mono z\u2264n         (s\u2264s n\u2081\u2265n\u2082)    = z\u2264n\n\u2238-mono (s\u2264s m\u2081\u2264m\u2082) (s\u2264s n\u2081\u2265n\u2082)    = \u2238-mono m\u2081\u2264m\u2082 n\u2081\u2265n\u2082\n\u2238-mono m\u2081\u2264m\u2082       (z\u2264n {n = n\u2081}) = \u2264-trans (m\u2238n\u2264m _ n\u2081) m\u2081\u2264m\u2082\n\n\u2238-mono\u02e1-\u2264 : \u2200 o \u2192 m \u2264 n \u2192 m \u2238 o \u2264 n \u2238 o\n\u2238-mono\u02e1-\u2264 o m\u2264n = \u2238-mono {u = o} m\u2264n \u2264-refl\n\n\u2238-mono\u02b3-\u2264 : \u2200 o \u2192 m \u2264 n \u2192 o \u2238 m \u2265 o \u2238 n\n\u2238-mono\u02b3-\u2264 _ m\u2264n = \u2238-mono \u2264-refl m\u2264n\n\n\u2238-mono\u02e1-&lt; : \u2200 {m n o} \u2192 m &lt; o \u2192 n \u2264 m \u2192 m \u2238 n &lt; o \u2238 n\n\u2238-mono\u02e1-&lt; {m}     {zero}  {o}     m&lt;o       n\u2264m       = m&lt;o\n\u2238-mono\u02e1-&lt; {suc m} {suc n} {suc o} (s\u2264s m&lt;o) (s\u2264s n\u2264m) = \u2238-mono\u02e1-&lt; m&lt;o n\u2264m\n\n\u2238-mono\u02b3-&lt; : \u2200 {m n o} \u2192 o &lt; n \u2192 n \u2264 m \u2192 m \u2238 n &lt; m \u2238 o\n\u2238-mono\u02b3-&lt; {n = suc n} {zero}  (s\u2264s o&lt;n) (s\u2264s n&lt;m) = s\u2264s (m\u2238n\u2264m _ n)\n\u2238-mono\u02b3-&lt; {n = suc n} {suc o} (s\u2264s o&lt;n) (s\u2264s n&lt;m) = \u2238-mono\u02b3-&lt; o&lt;n n&lt;m\n\n\u2238-cancel\u02b3-\u2264 : \u2200 {m n o} \u2192 m \u2264 o \u2192 o \u2238 n \u2264 o \u2238 m \u2192 m \u2264 n\n\u2238-cancel\u02b3-\u2264 {_}     {_}     z\u2264n       _       = z\u2264n\n\u2238-cancel\u02b3-\u2264 {suc m} {zero}  (s\u2264s _)   o&lt;o\u2238m   = contradiction o&lt;o\u2238m (m\u226em\u2238n _ m)\n\u2238-cancel\u02b3-\u2264 {suc m} {suc n} (s\u2264s m\u2264o) o\u2238n&lt;o\u2238m = s\u2264s (\u2238-cancel\u02b3-\u2264 m\u2264o o\u2238n&lt;o\u2238m)\n\n\u2238-cancel\u02b3-&lt; : \u2200 {m n o} \u2192 o \u2238 m &lt; o \u2238 n \u2192 n &lt; m\n\u2238-cancel\u02b3-&lt; {zero}  {n}     {o}     o&lt;o\u2238n   = contradiction o&lt;o\u2238n (m\u226em\u2238n o n)\n\u2238-cancel\u02b3-&lt; {suc m} {zero}  {_}     o\u2238n&lt;o\u2238m = 0&lt;1+n\n\u2238-cancel\u02b3-&lt; {suc m} {suc n} {suc o} o\u2238n&lt;o\u2238m = s\u2264s (\u2238-cancel\u02b3-&lt; o\u2238n&lt;o\u2238m)\n\n\u2238-cancel\u02e1-\u2261 :  n \u2264 m \u2192 o \u2264 m \u2192 m \u2238 n \u2261 m \u2238 o \u2192 n \u2261 o\n\u2238-cancel\u02e1-\u2261 {_}         z\u2264n       z\u2264n       _  = refl\n\u2238-cancel\u02e1-\u2261 {o = suc o} z\u2264n       (s\u2264s _)   eq = contradiction eq (1+m\u2262m\u2238n o)\n\u2238-cancel\u02e1-\u2261 {n = suc n} (s\u2264s _)   z\u2264n       eq = contradiction (sym eq) (1+m\u2262m\u2238n n)\n\u2238-cancel\u02e1-\u2261 {_}         (s\u2264s n\u2264m) (s\u2264s o\u2264m) eq = cong suc (\u2238-cancel\u02e1-\u2261 n\u2264m o\u2264m eq)\n\n\u2238-cancel\u02b3-\u2261 :  o \u2264 m \u2192 o \u2264 n \u2192 m \u2238 o \u2261 n \u2238 o \u2192 m \u2261 n\n\u2238-cancel\u02b3-\u2261  z\u2264n       z\u2264n      eq = eq\n\u2238-cancel\u02b3-\u2261 (s\u2264s o\u2264m) (s\u2264s o\u2264n) eq = cong suc (\u2238-cancel\u02b3-\u2261 o\u2264m o\u2264n eq)\n\nm\u2238n\u22610\u21d2m\u2264n : m \u2238 n \u2261 0 \u2192 m \u2264 n\nm\u2238n\u22610\u21d2m\u2264n {zero}  {_}    _   = z\u2264n\nm\u2238n\u22610\u21d2m\u2264n {suc m} {suc n} eq = s\u2264s (m\u2238n\u22610\u21d2m\u2264n eq)\n\nm\u2264n\u21d2m\u2238n\u22610 : m \u2264 n \u2192 m \u2238 n \u2261 0\nm\u2264n\u21d2m\u2238n\u22610 {n = n} z\u2264n      = 0\u2238n\u22610 n\nm\u2264n\u21d2m\u2238n\u22610 {_}    (s\u2264s m\u2264n) = m\u2264n\u21d2m\u2238n\u22610 m\u2264n\n\nm&lt;n\u21d20&lt;n\u2238m : m &lt; n \u2192 0 &lt; n \u2238 m\nm&lt;n\u21d20&lt;n\u2238m {zero}  {suc n} _         = 0&lt;1+n\nm&lt;n\u21d20&lt;n\u2238m {suc m} {suc n} (s\u2264s m&lt;n) = m&lt;n\u21d20&lt;n\u2238m m&lt;n\n\nm\u2238n\u22620\u21d2n&lt;m : m \u2238 n \u2262 0 \u2192 n &lt; m\nm\u2238n\u22620\u21d2n&lt;m {m} {n} m\u2238n\u22620 with n &lt;? m\n... | yes n&lt;m = n&lt;m\n... | no  n\u226em = contradiction (m\u2264n\u21d2m\u2238n\u22610 (\u226e\u21d2\u2265 n\u226em)) m\u2238n\u22620\n\nm&gt;n\u21d2m\u2238n\u22620 : m &gt; n \u2192 m \u2238 n \u2262 0\nm&gt;n\u21d2m\u2238n\u22620 {n = suc n} (s\u2264s m&gt;n) = m&gt;n\u21d2m\u2238n\u22620 m&gt;n\n\nm\u2264n\u21d2n\u2238m\u2264n : m \u2264 n \u2192 n \u2238 m \u2264 n\nm\u2264n\u21d2n\u2238m\u2264n z\u2264n       = \u2264-refl\nm\u2264n\u21d2n\u2238m\u2264n (s\u2264s m\u2264n) = m\u2264n\u21d2m\u22641+n (m\u2264n\u21d2n\u2238m\u2264n m\u2264n)\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_ and _+_\n\n+-\u2238-comm : \u2200 {m} n {o} \u2192 o \u2264 m \u2192 (m + n) \u2238 o \u2261 (m \u2238 o) + n\n+-\u2238-comm {zero}  _ {zero}  _         = refl\n+-\u2238-comm {suc m} _ {zero}  _         = refl\n+-\u2238-comm {suc m} n {suc o} (s\u2264s o\u2264m) = +-\u2238-comm n o\u2264m\n\n\u2238-+-assoc : \u2200 m n o \u2192 (m \u2238 n) \u2238 o \u2261 m \u2238 (n + o)\n\u2238-+-assoc zero zero o = refl\n\u2238-+-assoc zero (suc n) o = 0\u2238n\u22610 o\n\u2238-+-assoc (suc m) zero o = refl\n\u2238-+-assoc (suc m) (suc n) o = \u2238-+-assoc m n o\n\n+-\u2238-assoc : \u2200 m {n o} \u2192 o \u2264 n \u2192 (m + n) \u2238 o \u2261 m + (n \u2238 o)\n+-\u2238-assoc m (z\u2264n {n = n})             = begin-equality m + n \u220e\n+-\u2238-assoc m (s\u2264s {m = o} {n = n} o\u2264n) = begin-equality\n  (m + suc n) \u2238 suc o  \u2261\u27e8 cong (_\u2238 suc o) (+-suc m n) \u27e9\n  suc (m + n) \u2238 suc o  \u2261\u27e8\u27e9\n  (m + n) \u2238 o          \u2261\u27e8 +-\u2238-assoc m o\u2264n \u27e9\n  m + (n \u2238 o)          \u220e\n\nm\u2264n+o\u21d2m\u2238n\u2264o : \u2200 m n {o} \u2192 m \u2264 n + o \u2192 m \u2238 n \u2264 o\nm\u2264n+o\u21d2m\u2238n\u2264o      m  zero    le = le\nm\u2264n+o\u21d2m\u2238n\u2264o zero    (suc n)  _ = z\u2264n\nm\u2264n+o\u21d2m\u2238n\u2264o (suc m) (suc n) le = m\u2264n+o\u21d2m\u2238n\u2264o m n (s\u2264s\u207b\u00b9 le)\n\nm&lt;n+o\u21d2m\u2238n&lt;o : \u2200 m n {o} \u2192 .{{NonZero o}} \u2192 m &lt; n + o \u2192 m \u2238 n &lt; o\nm&lt;n+o\u21d2m\u2238n&lt;o      m  zero                lt = lt\nm&lt;n+o\u21d2m\u2238n&lt;o zero    (suc n) {o@(suc _)} lt = z&lt;s\nm&lt;n+o\u21d2m\u2238n&lt;o (suc m) (suc n)             lt = m&lt;n+o\u21d2m\u2238n&lt;o m n  (s&lt;s\u207b\u00b9 lt)\n\nm+n\u2264o\u21d2m\u2264o\u2238n : \u2200 m {n o} \u2192 m + n \u2264 o \u2192 m \u2264 o \u2238 n\nm+n\u2264o\u21d2m\u2264o\u2238n zero    le       = z\u2264n\nm+n\u2264o\u21d2m\u2264o\u2238n (suc m) (s\u2264s le)\n  rewrite +-\u2238-assoc 1 (m+n\u2264o\u21d2n\u2264o m le) = s\u2264s (m+n\u2264o\u21d2m\u2264o\u2238n m le)\n\nm\u2264o\u2238n\u21d2m+n\u2264o : \u2200 m {n o} (n\u2264o : n \u2264 o) \u2192 m \u2264 o \u2238 n \u2192 m + n \u2264 o\nm\u2264o\u2238n\u21d2m+n\u2264o m         z\u2264n       le rewrite +-identity\u02b3 m = le\nm\u2264o\u2238n\u21d2m+n\u2264o m {suc n} (s\u2264s n\u2264o) le rewrite +-suc m n = s\u2264s (m\u2264o\u2238n\u21d2m+n\u2264o m n\u2264o le)\n\nm\u2264n+m\u2238n : \u2200 m n \u2192 m \u2264 n + (m \u2238 n)\nm\u2264n+m\u2238n zero    n       = z\u2264n\nm\u2264n+m\u2238n (suc m) zero    = \u2264-refl\nm\u2264n+m\u2238n (suc m) (suc n) = s\u2264s (m\u2264n+m\u2238n m n)\n\nm+n\u2238n\u2261m : \u2200 m n \u2192 m + n \u2238 n \u2261 m\nm+n\u2238n\u2261m m n = begin-equality\n  (m + n) \u2238 n  \u2261\u27e8 +-\u2238-assoc m (\u2264-refl {x = n}) \u27e9\n  m + (n \u2238 n)  \u2261\u27e8 cong (m +_) (n\u2238n\u22610 n) \u27e9\n  m + 0        \u2261\u27e8 +-identity\u02b3 m \u27e9\n  m            \u220e\n\nm+n\u2238m\u2261n : \u2200 m n \u2192 m + n \u2238 m \u2261 n\nm+n\u2238m\u2261n m n = trans (cong (_\u2238 m) (+-comm m n)) (m+n\u2238n\u2261m n m)\n\nm+[n\u2238m]\u2261n : m \u2264 n \u2192 m + (n \u2238 m) \u2261 n\nm+[n\u2238m]\u2261n {m} {n} m\u2264n = begin-equality\n  m + (n \u2238 m)  \u2261\u27e8 sym $ +-\u2238-assoc m m\u2264n \u27e9\n  (m + n) \u2238 m  \u2261\u27e8 cong (_\u2238 m) (+-comm m n) \u27e9\n  (n + m) \u2238 m  \u2261\u27e8 m+n\u2238n\u2261m n m \u27e9\n  n            \u220e\n\nm\u2238n+n\u2261m : \u2200 {m n} \u2192 n \u2264 m \u2192 (m \u2238 n) + n \u2261 m\nm\u2238n+n\u2261m {m} {n} n\u2264m = begin-equality\n  (m \u2238 n) + n \u2261\u27e8 sym (+-\u2238-comm n n\u2264m) \u27e9\n  (m + n) \u2238 n \u2261\u27e8 m+n\u2238n\u2261m m n \u27e9\n  m           \u220e\n\nm\u2238[m\u2238n]\u2261n : \u2200 {m n} \u2192 n \u2264 m \u2192 m \u2238 (m \u2238 n) \u2261 n\nm\u2238[m\u2238n]\u2261n {m}     {_}     z\u2264n       = n\u2238n\u22610 m\nm\u2238[m\u2238n]\u2261n {suc m} {suc n} (s\u2264s n\u2264m) = begin-equality\n  suc m \u2238 (m \u2238 n)   \u2261\u27e8 +-\u2238-assoc 1 (m\u2238n\u2264m m n) \u27e9\n  suc (m \u2238 (m \u2238 n)) \u2261\u27e8 cong suc (m\u2238[m\u2238n]\u2261n n\u2264m) \u27e9\n  suc n             \u220e\n\n[m+n]\u2238[m+o]\u2261n\u2238o : \u2200 m n o \u2192 (m + n) \u2238 (m + o) \u2261 n \u2238 o\n[m+n]\u2238[m+o]\u2261n\u2238o zero    n o = refl\n[m+n]\u2238[m+o]\u2261n\u2238o (suc m) n o = [m+n]\u2238[m+o]\u2261n\u2238o m n o\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_ and _*_\n\n*-distrib\u02b3-\u2238 : _*_ DistributesOver\u02b3 _\u2238_\n*-distrib\u02b3-\u2238 m       zero    zero    = refl\n*-distrib\u02b3-\u2238 zero    zero    (suc o) = sym (0\u2238n\u22610 (o * zero))\n*-distrib\u02b3-\u2238 (suc m) zero    (suc o) = refl\n*-distrib\u02b3-\u2238 m       (suc n) zero    = refl\n*-distrib\u02b3-\u2238 m       (suc n) (suc o) = begin-equality\n  (n \u2238 o) * m             \u2261\u27e8 *-distrib\u02b3-\u2238 m n o \u27e9\n  n * m \u2238 o * m           \u2261\u27e8 sym $ [m+n]\u2238[m+o]\u2261n\u2238o m _ _ \u27e9\n  m + n * m \u2238 (m + o * m) \u220e\n\n*-distrib\u02e1-\u2238 : _*_ DistributesOver\u02e1 _\u2238_\n*-distrib\u02e1-\u2238 = comm\u2227distr\u02b3\u21d2distr\u02e1 *-comm *-distrib\u02b3-\u2238\n\n*-distrib-\u2238 : _*_ DistributesOver _\u2238_\n*-distrib-\u2238 = *-distrib\u02e1-\u2238 , *-distrib\u02b3-\u2238\n\neven\u2262odd :  \u2200 m n \u2192 2 * m \u2262 suc (2 * n)\neven\u2262odd (suc m) zero    eq = contradiction (suc-injective eq) (m+1+n\u22620 m)\neven\u2262odd (suc m) (suc n) eq = even\u2262odd m n (suc-injective (begin-equality\n  suc (2 * m)         \u2261\u27e8 sym (+-suc m _) \u27e9\n  m + suc (m + 0)     \u2261\u27e8 suc-injective eq \u27e9\n  suc n + suc (n + 0) \u2261\u27e8 cong suc (+-suc n _) \u27e9\n  suc (suc (2 * n))   \u220e))\n\n------------------------------------------------------------------------\n-- Properties of _\u2238_ and _\u2293_ and _\u2294_\n\nm\u2293n+n\u2238m\u2261n : \u2200 m n \u2192 (m \u2293 n) + (n \u2238 m) \u2261 n\nm\u2293n+n\u2238m\u2261n zero    n       = refl\nm\u2293n+n\u2238m\u2261n (suc m) zero    = refl\nm\u2293n+n\u2238m\u2261n (suc m) (suc n) = cong suc $ m\u2293n+n\u2238m\u2261n m n\n\n[m\u2238n]\u2293[n\u2238m]\u22610 : \u2200 m n \u2192 (m \u2238 n) \u2293 (n \u2238 m) \u2261 0\n[m\u2238n]\u2293[n\u2238m]\u22610 zero zero       = refl\n[m\u2238n]\u2293[n\u2238m]\u22610 zero (suc n)    = refl\n[m\u2238n]\u2293[n\u2238m]\u22610 (suc m) zero    = refl\n[m\u2238n]\u2293[n\u2238m]\u22610 (suc m) (suc n) = [m\u2238n]\u2293[n\u2238m]\u22610 m n\n\n\u2238-distrib\u02e1-\u2293-\u2294 : \u2200 m n o \u2192 m \u2238 (n \u2293 o) \u2261 (m \u2238 n) \u2294 (m \u2238 o)\n\u2238-distrib\u02e1-\u2293-\u2294 m n o = antimono-\u2264-distrib-\u2293 (\u2238-mono\u02b3-\u2264 m) n o\n\n\u2238-distrib\u02b3-\u2293 : _\u2238_ DistributesOver\u02b3 _\u2293_\n\u2238-distrib\u02b3-\u2293 m n o = mono-\u2264-distrib-\u2293 (\u2238-mono\u02e1-\u2264 m) n o\n\n\u2238-distrib\u02e1-\u2294-\u2293 : \u2200 m n o \u2192 m \u2238 (n \u2294 o) \u2261 (m \u2238 n) \u2293 (m \u2238 o)\n\u2238-distrib\u02e1-\u2294-\u2293 m n o = antimono-\u2264-distrib-\u2294 (\u2238-mono\u02b3-\u2264 m) n o\n\n\u2238-distrib\u02b3-\u2294 : _\u2238_ DistributesOver\u02b3 _\u2294_\n\u2238-distrib\u02b3-\u2294 m n o = mono-\u2264-distrib-\u2294 (\u2238-mono\u02e1-\u2264 m) n o\n\n------------------------------------------------------------------------\n-- Properties of pred\n------------------------------------------------------------------------\n\npred[n]\u2264n : pred n \u2264 n\npred[n]\u2264n {zero}  = z\u2264n\npred[n]\u2264n {suc n} = n\u22641+n n\n\n\u2264pred\u21d2\u2264 : m \u2264 pred n \u2192 m \u2264 n\n\u2264pred\u21d2\u2264 {n = zero}  le = le\n\u2264pred\u21d2\u2264 {n = suc n} le = m\u2264n\u21d2m\u22641+n le\n\n\u2264\u21d2pred\u2264 : m \u2264 n \u2192 pred m \u2264 n\n\u2264\u21d2pred\u2264 {zero}  le = le\n\u2264\u21d2pred\u2264 {suc m} le = \u2264-trans (n\u22641+n m) le\n\n&lt;\u21d2\u2264pred : m &lt; n \u2192 m \u2264 pred n\n&lt;\u21d2\u2264pred (s\u2264s le) = le\n\nsuc-pred : \u2200 n .{{_ : NonZero n}} \u2192 suc (pred n) \u2261 n\nsuc-pred (suc n) = refl\n\npred-mono-\u2264 : pred Preserves _\u2264_ \u27f6 _\u2264_\npred-mono-\u2264 {zero}          _   = z\u2264n\npred-mono-\u2264 {suc _} {suc _} m\u2264n = s\u2264s\u207b\u00b9 m\u2264n\n\npred-mono-&lt; : .{{NonZero m}} \u2192 m &lt; n \u2192 pred m &lt; pred n\npred-mono-&lt; {m = suc _} {n = suc _} = s&lt;s\u207b\u00b9\n\npred-cancel-\u2264 : pred m \u2264 pred n \u2192 (m \u2261 1 \u00d7 n \u2261 0) \u228e m \u2264 n\npred-cancel-\u2264 {m = zero}  {n = zero}  _  = inj\u2082 z\u2264n\npred-cancel-\u2264 {m = zero}  {n = suc _} _  = inj\u2082 z\u2264n\npred-cancel-\u2264 {m = suc _} {n = zero} z\u2264n = inj\u2081 (refl , refl)\npred-cancel-\u2264 {m = suc _} {n = suc _} le = inj\u2082 (s\u2264s le)\n\npred-cancel-&lt; : pred m &lt; pred n \u2192 m &lt; n\npred-cancel-&lt; {m = zero}  {n = suc _} _ = z&lt;s\npred-cancel-&lt; {m = suc _} {n = suc _}   = s&lt;s\n\npred-injective : .{{NonZero m}} \u2192 .{{NonZero n}} \u2192 pred m \u2261 pred n \u2192 m \u2261 n\npred-injective {suc m} {suc n} = cong suc\n\npred-cancel-\u2261 : pred m \u2261 pred n \u2192 ((m \u2261 0 \u00d7 n \u2261 1) \u228e (m \u2261 1 \u00d7 n \u2261 0)) \u228e m \u2261 n\npred-cancel-\u2261 {m = zero}  {n = zero}  _    = inj\u2082 refl\npred-cancel-\u2261 {m = zero}  {n = suc _} refl = inj\u2081 (inj\u2081 (refl , refl))\npred-cancel-\u2261 {m = suc _} {n = zero}  refl = inj\u2081 (inj\u2082 (refl , refl))\npred-cancel-\u2261 {m = suc _} {n = suc _}      = inj\u2082 \u2218 pred-injective\n\n------------------------------------------------------------------------\n-- Properties of \u2223_-_\u2223\n------------------------------------------------------------------------\n\n------------------------------------------------------------------------\n-- Basic\n\nm\u2261n\u21d2\u2223m-n\u2223\u22610 : m \u2261 n \u2192 \u2223 m - n \u2223 \u2261 0\nm\u2261n\u21d2\u2223m-n\u2223\u22610 {zero}  refl = refl\nm\u2261n\u21d2\u2223m-n\u2223\u22610 {suc m} refl = m\u2261n\u21d2\u2223m-n\u2223\u22610 {m} refl\n\n\u2223m-n\u2223\u22610\u21d2m\u2261n :  \u2223 m - n \u2223 \u2261 0 \u2192 m \u2261 n\n\u2223m-n\u2223\u22610\u21d2m\u2261n {zero}  {zero}  eq = refl\n\u2223m-n\u2223\u22610\u21d2m\u2261n {suc m} {suc n} eq = cong suc (\u2223m-n\u2223\u22610\u21d2m\u2261n eq)\n\nm\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m : m \u2264 n \u2192 \u2223 n - m \u2223 \u2261 n \u2238 m\nm\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m {n = zero}  z\u2264n       = refl\nm\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m {n = suc n} z\u2264n       = refl\nm\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m {n = _}     (s\u2264s m\u2264n) = m\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m m\u2264n\n\nm\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m : m \u2264 n \u2192 \u2223 m - n \u2223 \u2261 n \u2238 m\nm\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m {n = zero}  z\u2264n       = refl\nm\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m {n = suc n} z\u2264n       = refl\nm\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m {n = _}     (s\u2264s m\u2264n) = m\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m m\u2264n\n\n\u2223m-n\u2223\u2261m\u2238n\u21d2n\u2264m : \u2223 m - n \u2223 \u2261 m \u2238 n \u2192 n \u2264 m\n\u2223m-n\u2223\u2261m\u2238n\u21d2n\u2264m {zero}  {zero}  eq = z\u2264n\n\u2223m-n\u2223\u2261m\u2238n\u21d2n\u2264m {suc m} {zero}  eq = z\u2264n\n\u2223m-n\u2223\u2261m\u2238n\u21d2n\u2264m {suc m} {suc n} eq = s\u2264s (\u2223m-n\u2223\u2261m\u2238n\u21d2n\u2264m eq)\n\n\u2223n-n\u2223\u22610 : \u2200 n \u2192 \u2223 n - n \u2223 \u2261 0\n\u2223n-n\u2223\u22610 n = m\u2261n\u21d2\u2223m-n\u2223\u22610 {n} refl\n\n\u2223m-m+n\u2223\u2261n : \u2200 m n \u2192 \u2223 m - m + n \u2223 \u2261 n\n\u2223m-m+n\u2223\u2261n zero    n = refl\n\u2223m-m+n\u2223\u2261n (suc m) n = \u2223m-m+n\u2223\u2261n m n\n\n\u2223m+n-m+o\u2223\u2261\u2223n-o\u2223 : \u2200 m n o \u2192 \u2223 m + n - m + o \u2223 \u2261 \u2223 n - o \u2223\n\u2223m+n-m+o\u2223\u2261\u2223n-o\u2223 zero    n o = refl\n\u2223m+n-m+o\u2223\u2261\u2223n-o\u2223 (suc m) n o = \u2223m+n-m+o\u2223\u2261\u2223n-o\u2223 m n o\n\nm\u2238n\u2264\u2223m-n\u2223 : \u2200 m n \u2192 m \u2238 n \u2264 \u2223 m - n \u2223\nm\u2238n\u2264\u2223m-n\u2223 m n with \u2264-total m n\n... | inj\u2081 m\u2264n = subst (_\u2264 \u2223 m - n \u2223) (sym (m\u2264n\u21d2m\u2238n\u22610 m\u2264n)) z\u2264n\n... | inj\u2082 n\u2264m = subst (m \u2238 n \u2264_) (sym (m\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m n\u2264m)) \u2264-refl\n\n\u2223m-n\u2223\u2264m\u2294n : \u2200 m n \u2192 \u2223 m - n \u2223 \u2264 m \u2294 n\n\u2223m-n\u2223\u2264m\u2294n zero    m       = \u2264-refl\n\u2223m-n\u2223\u2264m\u2294n (suc m) zero    = \u2264-refl\n\u2223m-n\u2223\u2264m\u2294n (suc m) (suc n) = m\u2264n\u21d2m\u22641+n (\u2223m-n\u2223\u2264m\u2294n m n)\n\n\u2223-\u2223-identity\u02e1 : LeftIdentity 0 \u2223_-_\u2223\n\u2223-\u2223-identity\u02e1 x = refl\n\n\u2223-\u2223-identity\u02b3 : RightIdentity 0 \u2223_-_\u2223\n\u2223-\u2223-identity\u02b3 zero    = refl\n\u2223-\u2223-identity\u02b3 (suc x) = refl\n\n\u2223-\u2223-identity : Identity 0 \u2223_-_\u2223\n\u2223-\u2223-identity = \u2223-\u2223-identity\u02e1 , \u2223-\u2223-identity\u02b3\n\n\u2223-\u2223-comm : Commutative \u2223_-_\u2223\n\u2223-\u2223-comm zero    zero    = refl\n\u2223-\u2223-comm zero    (suc n) = refl\n\u2223-\u2223-comm (suc m) zero    = refl\n\u2223-\u2223-comm (suc m) (suc n) = \u2223-\u2223-comm m n\n\n\u2223m-n\u2223\u2261[m\u2238n]\u2228[n\u2238m] : \u2200 m n \u2192 (\u2223 m - n \u2223 \u2261 m \u2238 n) \u228e (\u2223 m - n \u2223 \u2261 n \u2238 m)\n\u2223m-n\u2223\u2261[m\u2238n]\u2228[n\u2238m] m n with \u2264-total m n\n... | inj\u2082 n\u2264m = inj\u2081 $ m\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m n\u2264m\n... | inj\u2081 m\u2264n = inj\u2082 $ begin-equality\n  \u2223 m - n \u2223 \u2261\u27e8 \u2223-\u2223-comm m n \u27e9\n  \u2223 n - m \u2223 \u2261\u27e8 m\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m m\u2264n \u27e9\n  n \u2238 m     \u220e\n\n*-distrib\u02e1-\u2223-\u2223 : _*_ DistributesOver\u02e1 \u2223_-_\u2223\n*-distrib\u02e1-\u2223-\u2223 a = wlog \u2264-total (comm\u21d2sym[distrib\u02e1] {_\u25e6_ = _*_} \u2223-\u2223-comm a)\n  $\u2032 \u03bb m n m\u2264n \u2192 begin-equality\n    a * \u2223 m - n \u2223     \u2261\u27e8 cong (a *_) (m\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m m\u2264n) \u27e9\n    a * (n \u2238 m)       \u2261\u27e8 *-distrib\u02e1-\u2238 a n m \u27e9\n    a * n \u2238 a * m     \u2261\u27e8 m\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m (*-mono\u02b3-\u2264 a m\u2264n) \u27e8\n    \u2223 a * m - a * n \u2223 \u220e\n\n*-distrib\u02b3-\u2223-\u2223 : _*_ DistributesOver\u02b3 \u2223_-_\u2223\n*-distrib\u02b3-\u2223-\u2223 = comm\u2227distr\u02e1\u21d2distr\u02b3 *-comm *-distrib\u02e1-\u2223-\u2223\n\n*-distrib-\u2223-\u2223 : _*_ DistributesOver \u2223_-_\u2223\n*-distrib-\u2223-\u2223 = *-distrib\u02e1-\u2223-\u2223 , *-distrib\u02b3-\u2223-\u2223\n\nm\u2264n+\u2223n-m\u2223 : \u2200 m n \u2192 m \u2264 n + \u2223 n - m \u2223\nm\u2264n+\u2223n-m\u2223 zero    n       = z\u2264n\nm\u2264n+\u2223n-m\u2223 (suc m) zero    = \u2264-refl\nm\u2264n+\u2223n-m\u2223 (suc m) (suc n) = s\u2264s (m\u2264n+\u2223n-m\u2223 m n)\n\nm\u2264n+\u2223m-n\u2223 : \u2200 m n \u2192 m \u2264 n + \u2223 m - n \u2223\nm\u2264n+\u2223m-n\u2223 m n = subst (m \u2264_) (cong (n +_) (\u2223-\u2223-comm n m)) (m\u2264n+\u2223n-m\u2223 m n)\n\nm\u2264\u2223m-n\u2223+n : \u2200 m n \u2192 m \u2264 \u2223 m - n \u2223 + n\nm\u2264\u2223m-n\u2223+n m n = subst (m \u2264_) (+-comm n _) (m\u2264n+\u2223m-n\u2223 m n)\n\n\u2223-\u2223-triangle : TriangleInequality \u2223_-_\u2223\n\u2223-\u2223-triangle zero    y       z       = m\u2264n+\u2223n-m\u2223 z y\n\u2223-\u2223-triangle x       zero    z       = begin\n  \u2223 x - z \u2223     \u2264\u27e8 \u2223m-n\u2223\u2264m\u2294n x z \u27e9\n  x \u2294 z         \u2264\u27e8 m\u2294n\u2264m+n x z \u27e9\n  x + z         \u2261\u27e8 cong\u2082 _+_ (sym (\u2223-\u2223-identity\u02b3 x)) refl \u27e9\n  \u2223 x - 0 \u2223 + z \u220e\n  where open \u2264-Reasoning\n\u2223-\u2223-triangle x       y       zero    = begin\n  \u2223 x - 0 \u2223             \u2261\u27e8 \u2223-\u2223-identity\u02b3 x \u27e9\n  x                     \u2264\u27e8 m\u2264\u2223m-n\u2223+n x y \u27e9\n  \u2223 x - y \u2223 + y         \u2261\u27e8 cong\u2082 _+_ refl (sym (\u2223-\u2223-identity\u02b3 y)) \u27e9\n  \u2223 x - y \u2223 + \u2223 y - 0 \u2223 \u220e\n  where open \u2264-Reasoning\n\u2223-\u2223-triangle (suc x) (suc y) (suc z) = \u2223-\u2223-triangle x y z\n\n\u2223-\u2223\u2261\u2223-\u2223\u2032 : \u2200 m n \u2192 \u2223 m - n \u2223 \u2261 \u2223 m - n \u2223\u2032\n\u2223-\u2223\u2261\u2223-\u2223\u2032 m n with m &lt;\u1d47 n in eq\n... | false = m\u2264n\u21d2\u2223n-m\u2223\u2261n\u2238m {n} {m} (\u226e\u21d2\u2265 (\u03bb m&lt;n \u2192 subst T eq (&lt;\u21d2&lt;\u1d47 m&lt;n)))\n... | true  = m\u2264n\u21d2\u2223m-n\u2223\u2261n\u2238m {m} {n} (&lt;\u21d2\u2264 (&lt;\u1d47\u21d2&lt; m n (subst T (sym eq) _)))\n\n------------------------------------------------------------------------\n-- Metric structures\n\n\u2223-\u2223-isProtoMetric : IsProtoMetric _\u2261_ \u2223_-_\u2223\n\u2223-\u2223-isProtoMetric = record\n  { isPartialOrder  = \u2264-isPartialOrder\n  ; \u2248-isEquivalence = isEquivalence\n  ; cong            = cong\u2082 \u2223_-_\u2223\n  ; nonNegative     = z\u2264n\n  }\n\n\u2223-\u2223-isPreMetric : IsPreMetric _\u2261_ \u2223_-_\u2223\n\u2223-\u2223-isPreMetric = record\n  { isProtoMetric = \u2223-\u2223-isProtoMetric\n  ; \u2248\u21d20           = m\u2261n\u21d2\u2223m-n\u2223\u22610\n  }\n\n\u2223-\u2223-isQuasiSemiMetric : IsQuasiSemiMetric _\u2261_ \u2223_-_\u2223\n\u2223-\u2223-isQuasiSemiMetric = record\n  { isPreMetric = \u2223-\u2223-isPreMetric\n  ; 0\u21d2\u2248         = \u2223m-n\u2223\u22610\u21d2m\u2261n\n  }\n\n\u2223-\u2223-isSemiMetric : IsSemiMetric _\u2261_ \u2223_-_\u2223\n\u2223-\u2223-isSemiMetric = record\n  { isQuasiSemiMetric = \u2223-\u2223-isQuasiSemiMetric\n  ; sym               = \u2223-\u2223-comm\n  }\n\n\u2223-\u2223-isMetric : IsMetric _\u2261_ \u2223_-_\u2223\n\u2223-\u2223-isMetric = record\n  { isSemiMetric = \u2223-\u2223-isSemiMetric\n  ; triangle     = \u2223-\u2223-triangle\n  }\n\n------------------------------------------------------------------------\n-- Metric bundles\n\n\u2223-\u2223-quasiSemiMetric : QuasiSemiMetric 0\u2113 0\u2113\n\u2223-\u2223-quasiSemiMetric = record\n  { isQuasiSemiMetric = \u2223-\u2223-isQuasiSemiMetric\n  }\n\n\u2223-\u2223-semiMetric : SemiMetric 0\u2113 0\u2113\n\u2223-\u2223-semiMetric = record\n  { isSemiMetric = \u2223-\u2223-isSemiMetric\n  }\n\n\u2223-\u2223-preMetric : PreMetric 0\u2113 0\u2113\n\u2223-\u2223-preMetric = record\n  { isPreMetric = \u2223-\u2223-isPreMetric\n  }\n\n\u2223-\u2223-metric : Metric 0\u2113 0\u2113\n\u2223-\u2223-metric = record\n  { isMetric = \u2223-\u2223-isMetric\n  }\n\n------------------------------------------------------------------------\n-- Properties of \u230a_/2\u230b and \u2308_/2\u2309\n------------------------------------------------------------------------\n\n\u230an/2\u230b-mono : \u230a_/2\u230b Preserves _\u2264_ \u27f6 _\u2264_\n\u230an/2\u230b-mono z\u2264n             = z\u2264n\n\u230an/2\u230b-mono (s\u2264s z\u2264n)       = z\u2264n\n\u230an/2\u230b-mono (s\u2264s (s\u2264s m\u2264n)) = s\u2264s (\u230an/2\u230b-mono m\u2264n)\n\n\u2308n/2\u2309-mono : \u2308_/2\u2309 Preserves _\u2264_ \u27f6 _\u2264_\n\u2308n/2\u2309-mono m\u2264n = \u230an/2\u230b-mono (s\u2264s m\u2264n)\n\n\u230an/2\u230b\u2264\u2308n/2\u2309 : \u2200 n \u2192 \u230a n /2\u230b \u2264 \u2308 n /2\u2309\n\u230an/2\u230b\u2264\u2308n/2\u2309 zero          = z\u2264n\n\u230an/2\u230b\u2264\u2308n/2\u2309 (suc zero)    = z\u2264n\n\u230an/2\u230b\u2264\u2308n/2\u2309 (suc (suc n)) = s\u2264s (\u230an/2\u230b\u2264\u2308n/2\u2309 n)\n\n\u230an/2\u230b+\u2308n/2\u2309\u2261n : \u2200 n \u2192 \u230a n /2\u230b + \u2308 n /2\u2309 \u2261 n\n\u230an/2\u230b+\u2308n/2\u2309\u2261n zero    = refl\n\u230an/2\u230b+\u2308n/2\u2309\u2261n (suc n) = begin-equality\n  \u230a suc n /2\u230b + suc \u230a n /2\u230b   \u2261\u27e8 +-comm \u230a suc n /2\u230b (suc \u230a n /2\u230b) \u27e9\n  suc \u230a n /2\u230b + \u230a suc n /2\u230b   \u2261\u27e8\u27e9\n  suc (\u230a n /2\u230b + \u230a suc n /2\u230b) \u2261\u27e8 cong suc (\u230an/2\u230b+\u2308n/2\u2309\u2261n n) \u27e9\n  suc n                       \u220e\n\n\u230an/2\u230b\u2264n : \u2200 n \u2192 \u230a n /2\u230b \u2264 n\n\u230an/2\u230b\u2264n zero          = z\u2264n\n\u230an/2\u230b\u2264n (suc zero)    = z\u2264n\n\u230an/2\u230b\u2264n (suc (suc n)) = s\u2264s (m\u2264n\u21d2m\u22641+n (\u230an/2\u230b\u2264n n))\n\n\u230an/2\u230b&lt;n : \u2200 n \u2192 \u230a suc n /2\u230b &lt; suc n\n\u230an/2\u230b&lt;n zero    = z&lt;s\n\u230an/2\u230b&lt;n (suc n) = s&lt;s (s\u2264s (\u230an/2\u230b\u2264n n))\n\nn\u2261\u230an+n/2\u230b : \u2200 n \u2192 n \u2261 \u230a n + n /2\u230b\nn\u2261\u230an+n/2\u230b zero          = refl\nn\u2261\u230an+n/2\u230b (suc zero)    = refl\nn\u2261\u230an+n/2\u230b (suc n\u2032@(suc n)) =\n  cong suc (trans (n\u2261\u230an+n/2\u230b _) (cong \u230a_/2\u230b (sym (+-suc n n\u2032))))\n\n\u2308n/2\u2309\u2264n : \u2200 n \u2192 \u2308 n /2\u2309 \u2264 n\n\u2308n/2\u2309\u2264n zero    = z\u2264n\n\u2308n/2\u2309\u2264n (suc n) = s\u2264s (\u230an/2\u230b\u2264n n)\n\n\u2308n/2\u2309&lt;n : \u2200 n \u2192 \u2308 suc (suc n) /2\u2309 &lt; suc (suc n)\n\u2308n/2\u2309&lt;n n = s&lt;s (\u230an/2\u230b&lt;n n)\n\nn\u2261\u2308n+n/2\u2309 : \u2200 n \u2192 n \u2261 \u2308 n + n /2\u2309\nn\u2261\u2308n+n/2\u2309 zero            = refl\nn\u2261\u2308n+n/2\u2309 (suc zero)      = refl\nn\u2261\u2308n+n/2\u2309 (suc n\u2032@(suc n)) =\n  cong suc (trans (n\u2261\u2308n+n/2\u2309 _) (cong \u2308_/2\u2309 (sym (+-suc n n\u2032))))\n\n------------------------------------------------------------------------\n-- Properties of !_\n\n1\u2264n! : \u2200 n \u2192 1 \u2264 n !\n1\u2264n! zero    = \u2264-refl\n1\u2264n! (suc n) = *-mono-\u2264 (m\u2264m+n 1 n) (1\u2264n! n)\n\ninfix 4 _!\u22620 _!*_!\u22620\n\n_!\u22620 : \u2200 n \u2192 NonZero (n !)\nn !\u22620 = &gt;-nonZero (1\u2264n! n)\n\n_!*_!\u22620 : \u2200 m n \u2192 NonZero (m ! * n !)\nm !* n !\u22620 = m*n\u22620 _ _ {{m !\u22620}} {{n !\u22620}}\n\n------------------------------------------------------------------------\n-- Properties of _\u2264\u2032_ and _&lt;\u2032_\n\n\u2264\u2032-trans : Transitive _\u2264\u2032_\n\u2264\u2032-trans m\u2264n \u2264\u2032-refl       = m\u2264n\n\u2264\u2032-trans m\u2264n (\u2264\u2032-step n\u2264o) = \u2264\u2032-step (\u2264\u2032-trans m\u2264n n\u2264o)\n\nz\u2264\u2032n : zero \u2264\u2032 n\nz\u2264\u2032n {zero}  = \u2264\u2032-refl\nz\u2264\u2032n {suc n} = \u2264\u2032-step z\u2264\u2032n\n\ns\u2264\u2032s : m \u2264\u2032 n \u2192 suc m \u2264\u2032 suc n\ns\u2264\u2032s (\u2264\u2032-reflexive m\u2261n) = \u2264\u2032-reflexive (cong suc m\u2261n)\ns\u2264\u2032s (\u2264\u2032-step m\u2264\u2032n) = \u2264\u2032-step (s\u2264\u2032s m\u2264\u2032n)\n\n\u2264\u2032\u21d2\u2264 : _\u2264\u2032_ \u21d2 _\u2264_\n\u2264\u2032\u21d2\u2264 (\u2264\u2032-reflexive m\u2261n) = \u2264-reflexive m\u2261n\n\u2264\u2032\u21d2\u2264 (\u2264\u2032-step m\u2264\u2032n) = m\u2264n\u21d2m\u22641+n (\u2264\u2032\u21d2\u2264 m\u2264\u2032n)\n\n\u2264\u21d2\u2264\u2032 : _\u2264_ \u21d2 _\u2264\u2032_\n\u2264\u21d2\u2264\u2032 z\u2264n       = z\u2264\u2032n\n\u2264\u21d2\u2264\u2032 (s\u2264s m\u2264n) = s\u2264\u2032s (\u2264\u21d2\u2264\u2032 m\u2264n)\n\n\u2264\u2032-step-injective : {p q : m \u2264\u2032 n} \u2192 \u2264\u2032-step p \u2261 \u2264\u2032-step q \u2192 p \u2261 q\n\u2264\u2032-step-injective refl = refl\n\n------------------------------------------------------------------------\n-- Properties of _&lt;\u2032_ and _&lt;_\n------------------------------------------------------------------------\n\nz&lt;\u2032s : zero &lt;\u2032 suc n\nz&lt;\u2032s {zero}  = &lt;\u2032-base\nz&lt;\u2032s {suc n} = &lt;\u2032-step (z&lt;\u2032s {n})\n\ns&lt;\u2032s : m &lt;\u2032 n \u2192 suc m &lt;\u2032 suc n\ns&lt;\u2032s &lt;\u2032-base        = &lt;\u2032-base\ns&lt;\u2032s (&lt;\u2032-step m&lt;\u2032n) = &lt;\u2032-step (s&lt;\u2032s m&lt;\u2032n)\n\n&lt;\u21d2&lt;\u2032 : m &lt; n \u2192 m &lt;\u2032 n\n&lt;\u21d2&lt;\u2032 z&lt;s               = z&lt;\u2032s\n&lt;\u21d2&lt;\u2032 (s&lt;s m&lt;n@(s\u2264s _)) = s&lt;\u2032s (&lt;\u21d2&lt;\u2032 m&lt;n)\n\n&lt;\u2032\u21d2&lt; : m &lt;\u2032 n \u2192 m &lt; n\n&lt;\u2032\u21d2&lt; &lt;\u2032-base        = n&lt;1+n _\n&lt;\u2032\u21d2&lt; (&lt;\u2032-step m&lt;\u2032n) = m&lt;n\u21d2m&lt;1+n (&lt;\u2032\u21d2&lt; m&lt;\u2032n)\n\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n\u2032 : m &lt; suc n \u2192 m &lt; n \u228e m \u2261 n\nm&lt;1+n\u21d2m&lt;n\u2228m\u2261n\u2032 m&lt;n with &lt;\u21d2&lt;\u2032 m&lt;n\n... | &lt;\u2032-base      = inj\u2082 refl\n... | &lt;\u2032-step m&lt;\u2032n = inj\u2081 (&lt;\u2032\u21d2&lt; m&lt;\u2032n)\n\n------------------------------------------------------------------------\n-- Other properties of _\u2264\u2032_ and _&lt;\u2032_\n------------------------------------------------------------------------\n\ninfix 4 _\u2264\u2032?_ _&lt;\u2032?_ _\u2265\u2032?_ _&gt;\u2032?_\n\n_\u2264\u2032?_ : Decidable _\u2264\u2032_\nm \u2264\u2032? n = map\u2032 \u2264\u21d2\u2264\u2032 \u2264\u2032\u21d2\u2264 (m \u2264? n)\n\n_&lt;\u2032?_ : Decidable _&lt;\u2032_\nm &lt;\u2032? n = suc m \u2264\u2032? n\n\n_\u2265\u2032?_ : Decidable _\u2265\u2032_\n_\u2265\u2032?_ = flip _\u2264\u2032?_\n\n_&gt;\u2032?_ : Decidable _&gt;\u2032_\n_&gt;\u2032?_ = flip _&lt;\u2032?_\n\nm\u2264\u2032m+n : \u2200 m n \u2192 m \u2264\u2032 m + n\nm\u2264\u2032m+n m n = \u2264\u21d2\u2264\u2032 (m\u2264m+n m n)\n\nn\u2264\u2032m+n : \u2200 m n \u2192 n \u2264\u2032 m + n\nn\u2264\u2032m+n zero    n = \u2264\u2032-refl\nn\u2264\u2032m+n (suc m) n = \u2264\u2032-step (n\u2264\u2032m+n m n)\n\n\u2308n/2\u2309\u2264\u2032n : \u2200 n \u2192 \u2308 n /2\u2309 \u2264\u2032 n\n\u2308n/2\u2309\u2264\u2032n zero          = \u2264\u2032-refl\n\u2308n/2\u2309\u2264\u2032n (suc zero)    = \u2264\u2032-refl\n\u2308n/2\u2309\u2264\u2032n (suc (suc n)) = s\u2264\u2032s (\u2264\u2032-step (\u2308n/2\u2309\u2264\u2032n n))\n\n\u230an/2\u230b\u2264\u2032n : \u2200 n \u2192 \u230a n /2\u230b \u2264\u2032 n\n\u230an/2\u230b\u2264\u2032n zero    = \u2264\u2032-refl\n\u230an/2\u230b\u2264\u2032n (suc n) = \u2264\u2032-step (\u2308n/2\u2309\u2264\u2032n n)\n\n------------------------------------------------------------------------\n-- Properties of _\u2264\u2033_ and _&lt;\u2033_\n------------------------------------------------------------------------\n\n-- equivalence of  _\u2264\u2033_ to _\u2264_\n\n\u2264\u21d2\u2264\u2033 : _\u2264_ \u21d2 _\u2264\u2033_\n\u2264\u21d2\u2264\u2033 = (_ ,_) \u2218 m+[n\u2238m]\u2261n\n\n&lt;\u21d2&lt;\u2033 : _&lt;_ \u21d2 _&lt;\u2033_\n&lt;\u21d2&lt;\u2033 = \u2264\u21d2\u2264\u2033\n\n\u2264\u2033\u21d2\u2264 : _\u2264\u2033_ \u21d2 _\u2264_\n\u2264\u2033\u21d2\u2264 (k , refl) = m\u2264m+n _ k\n\n-- equivalence to the old definition of _\u2264\u2033_\n\n\u2264\u2033-proof : (le : m \u2264\u2033 n) \u2192 let k , _ = le in m + k \u2261 n\n\u2264\u2033-proof (_ , prf) = prf\n\n-- yielding analogous proof for _\u2264_\n\nm\u2264n\u21d2\u2203[o]m+o\u2261n : .(m \u2264 n) \u2192 \u2203 \u03bb k \u2192 m + k \u2261 n\nm\u2264n\u21d2\u2203[o]m+o\u2261n m\u2264n = _ , m+[n\u2238m]\u2261n (recompute (_ \u2264? _) m\u2264n)\n\n-- whose witness is equal to monus\n\nguarded-\u2238\u2257\u2238 : \u2200 {m n} \u2192 .(m\u2264n : m \u2264 n) \u2192\n              let k , _ = m\u2264n\u21d2\u2203[o]m+o\u2261n m\u2264n in k \u2261 n \u2238 m\nguarded-\u2238\u2257\u2238 m\u2264n = refl\n\n-- equivalence of _&lt;\u2033_ to _&lt;\u1d47_\n\nm&lt;\u1d47n\u21d21+m+[n-1+m]\u2261n : \u2200 m n \u2192 T (m &lt;\u1d47 n) \u2192 suc m + (n \u2238 suc m) \u2261 n\nm&lt;\u1d47n\u21d21+m+[n-1+m]\u2261n m n lt = m+[n\u2238m]\u2261n (&lt;\u1d47\u21d2&lt; m n lt)\n\nm&lt;\u1d471+m+n : \u2200 m {n} \u2192 T (m &lt;\u1d47 suc (m + n))\nm&lt;\u1d471+m+n m = &lt;\u21d2&lt;\u1d47 (m\u2264m+n (suc m) _)\n\n&lt;\u1d47\u21d2&lt;\u2033 : T (m &lt;\u1d47 n) \u2192 m &lt;\u2033 n\n&lt;\u1d47\u21d2&lt;\u2033 {m} {n} = &lt;\u21d2&lt;\u2033 \u2218 (&lt;\u1d47\u21d2&lt; m n)\n\n&lt;\u2033\u21d2&lt;\u1d47 : \u2200 {m n} \u2192 m &lt;\u2033 n \u2192 T (m &lt;\u1d47 n)\n&lt;\u2033\u21d2&lt;\u1d47 {m} (k , refl) = &lt;\u21d2&lt;\u1d47 (m\u2264m+n (suc m) k)\n\n-- NB: we use the builtin function `_&lt;\u1d47_ : (m n : \u2115) \u2192 Bool` here so\n-- that the function quickly decides whether to return `yes` or `no`.\n-- It still takes a linear amount of time to generate the proof if it\n-- is inspected. We expect the main benefit to be visible for compiled\n-- code: the backend erases proofs.\n\ninfix 4 _&lt;\u2033?_ _\u2264\u2033?_ _\u2265\u2033?_ _&gt;\u2033?_\n\n_&lt;\u2033?_ : Decidable _&lt;\u2033_\nm &lt;\u2033? n = map\u2032 &lt;\u1d47\u21d2&lt;\u2033 &lt;\u2033\u21d2&lt;\u1d47 (T? (m &lt;\u1d47 n))\n\n_\u2264\u2033?_ : Decidable _\u2264\u2033_\nzero  \u2264\u2033? n = yes (n , refl)\nsuc m \u2264\u2033? n = m &lt;\u2033? n\n\n_\u2265\u2033?_ : Decidable _\u2265\u2033_\n_\u2265\u2033?_ = flip _\u2264\u2033?_\n\n_&gt;\u2033?_ : Decidable _&gt;\u2033_\n_&gt;\u2033?_ = flip _&lt;\u2033?_\n\n\u2264\u2033-irrelevant : Irrelevant _\u2264\u2033_\n\u2264\u2033-irrelevant {m} (_ , eq\u2081) (_ , eq\u2082)\n  with refl \u2190 +-cancel\u02e1-\u2261 m _ _ (trans eq\u2081 (sym eq\u2082))\n  = cong (_ ,_) (\u2261-irrelevant eq\u2081 eq\u2082)\n\n&lt;\u2033-irrelevant : Irrelevant _&lt;\u2033_\n&lt;\u2033-irrelevant = \u2264\u2033-irrelevant\n\n&gt;\u2033-irrelevant : Irrelevant _&gt;\u2033_\n&gt;\u2033-irrelevant = \u2264\u2033-irrelevant\n\n\u2265\u2033-irrelevant : Irrelevant _\u2265\u2033_\n\u2265\u2033-irrelevant = \u2264\u2033-irrelevant\n\n------------------------------------------------------------------------\n-- Properties of _\u2264\u2034_\n------------------------------------------------------------------------\n\n\u2264\u2034\u21d2\u2264\u2033 : m \u2264\u2034 n \u2192 m \u2264\u2033 n\n\u2264\u2034\u21d2\u2264\u2033 \u2264\u2034-refl       = _ , +-identity\u02b3 _\n\u2264\u2034\u21d2\u2264\u2033 (\u2264\u2034-step m\u2264n) = _ , trans (+-suc _ _) (\u2264\u2033-proof (\u2264\u2034\u21d2\u2264\u2033 m\u2264n))\n\nm\u2264\u2034m+k : m + k \u2261 n \u2192 m \u2264\u2034 n\nm\u2264\u2034m+k {k = zero}  = \u2264\u2034-reflexive \u2218 trans (sym (+-identity\u02b3 _))\nm\u2264\u2034m+k {k = suc _} = \u2264\u2034-step \u2218 m\u2264\u2034m+k \u2218 trans (sym (+-suc _ _))\n\n\u2264\u2033\u21d2\u2264\u2034 : m \u2264\u2033 n \u2192 m \u2264\u2034 n\n\u2264\u2033\u21d2\u2264\u2034 = m\u2264\u2034m+k \u2218 \u2264\u2033-proof\n\n0\u2264\u2034n : 0 \u2264\u2034 n\n0\u2264\u2034n = m\u2264\u2034m+k refl\n\n&lt;\u1d47\u21d2&lt;\u2034 : T (m &lt;\u1d47 n) \u2192 m &lt;\u2034 n\n&lt;\u1d47\u21d2&lt;\u2034 = \u2264\u2033\u21d2\u2264\u2034 \u2218 &lt;\u1d47\u21d2&lt;\u2033\n\n&lt;\u2034\u21d2&lt;\u1d47 : m &lt;\u2034 n \u2192 T (m &lt;\u1d47 n)\n&lt;\u2034\u21d2&lt;\u1d47 = &lt;\u2033\u21d2&lt;\u1d47 \u2218 \u2264\u2034\u21d2\u2264\u2033\n\ninfix 4 _&lt;\u2034?_ _\u2264\u2034?_ _\u2265\u2034?_ _&gt;\u2034?_\n\n_&lt;\u2034?_ : Decidable _&lt;\u2034_\nm &lt;\u2034? n = map\u2032 &lt;\u1d47\u21d2&lt;\u2034 &lt;\u2034\u21d2&lt;\u1d47 (T? (m &lt;\u1d47 n))\n\n_\u2264\u2034?_ : Decidable _\u2264\u2034_\nzero \u2264\u2034? n = yes 0\u2264\u2034n\nsuc m \u2264\u2034? n = m &lt;\u2034? n\n\n_\u2265\u2034?_ : Decidable _\u2265\u2034_\n_\u2265\u2034?_ = flip _\u2264\u2034?_\n\n_&gt;\u2034?_ : Decidable _&gt;\u2034_\n_&gt;\u2034?_ = flip _&lt;\u2034?_\n\n\u2264\u21d2\u2264\u2034 : _\u2264_ \u21d2 _\u2264\u2034_\n\u2264\u21d2\u2264\u2034 = \u2264\u2033\u21d2\u2264\u2034 \u2218 \u2264\u21d2\u2264\u2033\n\n\u2264\u2034\u21d2\u2264 : _\u2264\u2034_ \u21d2 _\u2264_\n\u2264\u2034\u21d2\u2264 = \u2264\u2033\u21d2\u2264 \u2218 \u2264\u2034\u21d2\u2264\u2033\n\n&lt;\u2034-irrefl : Irreflexive _\u2261_ _&lt;\u2034_\n&lt;\u2034-irrefl eq = &lt;-irrefl eq \u2218 \u2264\u2034\u21d2\u2264\n\n\u2264\u2034-irrelevant : Irrelevant _\u2264\u2034_\n\u2264\u2034-irrelevant (\u2264\u2034-reflexive eq\u2081) (\u2264\u2034-reflexive eq\u2082) = cong \u2264\u2034-reflexive (\u2261-irrelevant eq\u2081 eq\u2082)\n\u2264\u2034-irrelevant (\u2264\u2034-reflexive eq\u2081) (\u2264\u2034-step q)        with () \u2190 &lt;\u2034-irrefl eq\u2081 q\n\u2264\u2034-irrelevant (\u2264\u2034-step p)        (\u2264\u2034-reflexive eq\u2082) with () \u2190 &lt;\u2034-irrefl eq\u2082 p\n\u2264\u2034-irrelevant (\u2264\u2034-step p)        (\u2264\u2034-step q)        = cong \u2264\u2034-step (\u2264\u2034-irrelevant p q)\n\n&lt;\u2034-irrelevant : Irrelevant {A = \u2115} _&lt;\u2034_\n&lt;\u2034-irrelevant = \u2264\u2034-irrelevant\n\n&gt;\u2034-irrelevant : Irrelevant {A = \u2115} _&gt;\u2034_\n&gt;\u2034-irrelevant = \u2264\u2034-irrelevant\n\n\u2265\u2034-irrelevant : Irrelevant {A = \u2115} _\u2265\u2034_\n\u2265\u2034-irrelevant = \u2264\u2034-irrelevant\n\n------------------------------------------------------------------------\n-- Other properties\n------------------------------------------------------------------------\n\n-- If there is an injection from a type to \u2115, then the type has\n-- decidable equality.\n\neq? : \u2200 {a} {A : Set a} \u2192 A \u21a3 \u2115 \u2192 DecidableEquality A\neq? inj = via-injection inj _\u225f_\n\n-- It's possible to decide existential and universal predicates up to\n-- a limit.\n\nmodule _ {p} {P : Pred \u2115 p} (P? : U.Decidable P) where\n\n  anyUpTo? : \u2200 v \u2192 Dec (\u2203 \u03bb n \u2192 n &lt; v \u00d7 P n)\n  anyUpTo? zero    = no \u03bb {(_ , () , _)}\n  anyUpTo? (suc v) with P? v | anyUpTo? v\n  ... | yes Pv | _                  = yes (v , \u2264-refl , Pv)\n  ... | _      | yes (n , n&lt;v , Pn) = yes (n , m\u2264n\u21d2m\u22641+n n&lt;v , Pn)\n  ... | no \u00acPv | no \u00acPn&lt;v           = no \u00acPn&lt;1+v\n    where\n    \u00acPn&lt;1+v : \u00ac (\u2203 \u03bb n \u2192 n &lt; suc v \u00d7 P n)\n    \u00acPn&lt;1+v (n , s\u2264s n\u2264v , Pn) with n \u225f v\n    ... | yes refl = \u00acPv Pn\n    ... | no  n\u2262v  = \u00acPn&lt;v (n , \u2264\u2227\u2262\u21d2&lt; n\u2264v n\u2262v , Pn)\n\n  allUpTo? : \u2200 v \u2192 Dec (\u2200 {n} \u2192 n &lt; v \u2192 P n)\n  allUpTo? zero    = yes \u03bb()\n  allUpTo? (suc v) with P? v | allUpTo? v\n  ... | no \u00acPv | _        = no \u03bb prf \u2192 \u00acPv   (prf \u2264-refl)\n  ... | _      | no \u00acPn&lt;v = no \u03bb prf \u2192 \u00acPn&lt;v (prf \u2218 m\u2264n\u21d2m\u22641+n)\n  ... | yes Pn | yes Pn&lt;v = yes Pn&lt;1+v\n    where\n      Pn&lt;1+v : \u2200 {n} \u2192 n &lt; suc v \u2192 P n\n      Pn&lt;1+v {n} (s\u2264s n\u2264v) with n \u225f v\n      ... | yes refl = Pn\n      ... | no  n\u2262v  = Pn&lt;v (\u2264\u2227\u2262\u21d2&lt; n\u2264v n\u2262v)\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.3\n\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2o&lt;n : \u2200 n o \u2192 (\u2200 {m} \u2192 m \u2264 n \u2192 m \u2262 o) \u2192 n &lt; o\n\u2200[m\u2264n\u21d2m\u2262o]\u21d2o&lt;n = \u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o\n{-# WARNING_ON_USAGE \u2200[m\u2264n\u21d2m\u2262o]\u21d2o&lt;n\n\"Warning: \u2200[m\u2264n\u21d2m\u2262o]\u21d2o&lt;n was deprecated in v1.3.\nPlease use \u2200[m\u2264n\u21d2m\u2262o]\u21d2n&lt;o instead.\"\n#-}\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2o\u2264n : \u2200 n o \u2192 (\u2200 {m} \u2192 m &lt; n \u2192 m \u2262 o) \u2192 n \u2264 o\n\u2200[m&lt;n\u21d2m\u2262o]\u21d2o\u2264n = \u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o\n{-# WARNING_ON_USAGE \u2200[m&lt;n\u21d2m\u2262o]\u21d2o\u2264n\n\"Warning: \u2200[m&lt;n\u21d2m\u2262o]\u21d2o\u2264n was deprecated in v1.3.\nPlease use \u2200[m&lt;n\u21d2m\u2262o]\u21d2n\u2264o instead.\"\n#-}\n\n-- Version 1.4\n\n*-+-isSemiring = +-*-isSemiring\n{-# WARNING_ON_USAGE *-+-isSemiring\n\"Warning: *-+-isSemiring was deprecated in v1.4.\nPlease use +-*-isSemiring instead.\"\n#-}\n*-+-isCommutativeSemiring = +-*-isCommutativeSemiring\n{-# WARNING_ON_USAGE *-+-isCommutativeSemiring\n\"Warning: *-+-isCommutativeSemiring was deprecated in v1.4.\nPlease use +-*-isCommutativeSemiring instead.\"\n#-}\n*-+-semiring = +-*-semiring\n{-# WARNING_ON_USAGE *-+-semiring\n\"Warning: *-+-semiring was deprecated in v1.4.\nPlease use +-*-semiring instead.\"\n#-}\n*-+-commutativeSemiring = +-*-commutativeSemiring\n{-# WARNING_ON_USAGE *-+-commutativeSemiring\n\"Warning: *-+-commutativeSemiring was deprecated in v1.4.\nPlease use +-*-commutativeSemiring instead.\"\n#-}\n\n-- Version 1.6\n\n\u2223m+n-m+o\u2223\u2261\u2223n-o| = \u2223m+n-m+o\u2223\u2261\u2223n-o\u2223\n{-# WARNING_ON_USAGE \u2223m+n-m+o\u2223\u2261\u2223n-o|\n\"Warning: \u2223m+n-m+o\u2223\u2261\u2223n-o| was deprecated in v1.6.\nPlease use \u2223m+n-m+o\u2223\u2261\u2223n-o\u2223 instead. Note the final is a \\\\| rather than a |\"\n#-}\nm\u2264n\u21d2n\u2294m\u2261n = m\u2265n\u21d2m\u2294n\u2261m\n{-# WARNING_ON_USAGE m\u2264n\u21d2n\u2294m\u2261n\n\"Warning: m\u2264n\u21d2n\u2294m\u2261n was deprecated in v1.6. Please use m\u2265n\u21d2m\u2294n\u2261m instead.\"\n#-}\nm\u2264n\u21d2n\u2293m\u2261m = m\u2265n\u21d2m\u2293n\u2261n\n{-# WARNING_ON_USAGE m\u2264n\u21d2n\u2293m\u2261m\n\"Warning: m\u2264n\u21d2n\u2293m\u2261m was deprecated in v1.6. Please use m\u2265n\u21d2m\u2293n\u2261n instead.\"\n#-}\nn\u2294m\u2261m\u21d2n\u2264m = m\u2294n\u2261n\u21d2m\u2264n\n{-# WARNING_ON_USAGE n\u2294m\u2261m\u21d2n\u2264m\n\"Warning: n\u2294m\u2261m\u21d2n\u2264m was deprecated in v1.6. Please use m\u2294n\u2261n\u21d2m\u2264n instead.\"\n#-}\nn\u2294m\u2261n\u21d2m\u2264n = m\u2294n\u2261m\u21d2n\u2264m\n{-# WARNING_ON_USAGE n\u2294m\u2261n\u21d2m\u2264n\n\"Warning: n\u2294m\u2261n\u21d2m\u2264n was deprecated in v1.6. Please use m\u2294n\u2261m\u21d2n\u2264m instead.\"\n#-}\nn\u2264m\u2294n = m\u2264n\u2294m\n{-# WARNING_ON_USAGE n\u2264m\u2294n\n\"Warning: n\u2264m\u2294n was deprecated in v1.6. Please use m\u2264n\u2294m instead.\"\n#-}\n\u2294-least = \u2294-lub\n{-# WARNING_ON_USAGE \u2294-least\n\"Warning: \u2294-least was deprecated in v1.6. Please use \u2294-lub instead.\"\n#-}\n\u2293-greatest = \u2293-glb\n{-# WARNING_ON_USAGE \u2293-greatest\n\"Warning: \u2293-greatest was deprecated in v1.6. Please use \u2293-glb instead.\"\n#-}\n\u2294-pres-\u2264m = \u2294-lub\n{-# WARNING_ON_USAGE \u2294-pres-\u2264m\n\"Warning: \u2294-pres-\u2264m was deprecated in v1.6. Please use \u2294-lub instead.\"\n#-}\n\u2293-pres-m\u2264 = \u2293-glb\n{-# WARNING_ON_USAGE \u2293-pres-m\u2264\n\"Warning: \u2293-pres-m\u2264 was deprecated in v1.6. Please use \u2293-glb instead.\"\n#-}\n\u2294-abs-\u2293 = \u2294-absorbs-\u2293\n{-# WARNING_ON_USAGE \u2294-abs-\u2293\n\"Warning: \u2294-abs-\u2293 was deprecated in v1.6. Please use \u2294-absorbs-\u2293 instead.\"\n#-}\n\u2293-abs-\u2294 = \u2293-absorbs-\u2294\n{-# WARNING_ON_USAGE \u2293-abs-\u2294\n\"Warning: \u2293-abs-\u2294 was deprecated in v1.6. Please use \u2293-absorbs-\u2294 instead.\"\n#-}\n\n-- Version 2.0\n\nsuc[pred[n]]\u2261n : n \u2262 0 \u2192 suc (pred n) \u2261 n\nsuc[pred[n]]\u2261n {zero}  0\u22620 = contradiction refl 0\u22620\nsuc[pred[n]]\u2261n {suc n} _   = refl\n{-# WARNING_ON_USAGE suc[pred[n]]\u2261n\n\"Warning: suc[pred[n]]\u2261n was deprecated in v2.0. Please use suc-pred instead. Note that the proof now uses instance arguments\"\n#-}\n\n\u2264-step = m\u2264n\u21d2m\u22641+n\n{-# WARNING_ON_USAGE \u2264-step\n\"Warning: \u2264-step was deprecated in v2.0. Please use m\u2264n\u21d2m\u22641+n instead. \"\n#-}\n\n\u2264-steps\u02e1 = m\u2264n\u21d2m\u2264o+n\n{-# WARNING_ON_USAGE \u2264-steps\u02e1\n\"Warning: \u2264-steps\u02e1 was deprecated in v2.0. Please use m\u2264n\u21d2m\u2264o+n instead. \"\n#-}\n\n\u2264-steps\u02b3 = m\u2264n\u21d2m\u2264n+o\n{-# WARNING_ON_USAGE \u2264-steps\u02b3\n\"Warning: \u2264-steps\u02b3 was deprecated in v2.0. Please use m\u2264n\u21d2m\u2264n+o instead. \"\n#-}\n\n&lt;-step = m&lt;n\u21d2m&lt;1+n\n{-# WARNING_ON_USAGE &lt;-step\n\"Warning: &lt;-step was deprecated in v2.0. Please use m&lt;n\u21d2m&lt;1+n instead. \"\n#-}\n\npred-mono = pred-mono-\u2264\n{-# WARNING_ON_USAGE pred-mono\n\"Warning: pred-mono was deprecated in v2.0. Please use pred-mono-\u2264 instead. \"\n#-}\n\n{- issue1844/issue1755: raw bundles have moved to `Data.X.Base` -}\nopen Data.Nat.Base public\n  using (*-rawMagma; *-1-rawMonoid)\n\n&lt;-trans\u02b3 = \u2264-&lt;-trans\n{-# WARNING_ON_USAGE &lt;-trans\u02b3\n\"Warning: &lt;-trans\u02b3 was deprecated in v2.0. Please use \u2264-&lt;-trans instead. \"\n#-}\n\n&lt;-trans\u02e1 = &lt;-\u2264-trans\n{-# WARNING_ON_USAGE &lt;-trans\u02e1\n\"Warning: &lt;-trans\u02e1 was deprecated in v2.0. Please use &lt;-\u2264-trans instead. \"\n#-}\n</pre>"},{"location":"md/Data/Parity/Base/","title":"Data.Parity.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Parity\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Parity.Base where\n\nopen import Algebra.Bundles.Raw\n  using (RawMagma; RawMonoid; RawGroup; RawNearSemiring; RawSemiring)\nopen import Data.Sign.Base using (Sign; +; -)\nopen import Level using (0\u2113)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\n------------------------------------------------------------------------\n-- Definition\n\ndata Parity : Set where\n  0\u2119 : Parity\n  1\u2119 : Parity\n\n------------------------------------------------------------------------\n-- Operations\n\n-- The opposite parity.\n\ninfix 8 _\u207b\u00b9\n\n_\u207b\u00b9 : Parity \u2192 Parity\n1\u2119 \u207b\u00b9 = 0\u2119\n0\u2119 \u207b\u00b9 = 1\u2119\n\n-- Addition.\n\ninfixl 7 _+_\n\n_+_ : Parity \u2192 Parity \u2192 Parity\n0\u2119 + p = p\n1\u2119 + p = p \u207b\u00b9\n\n-- Multiplication.\n\ninfixl 7 _*_\n\n_*_ : Parity \u2192 Parity \u2192 Parity\n0\u2119 * p = 0\u2119\n1\u2119 * p = p\n\n------------------------------------------------------------------------\n-- Raw Bundles\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; \u03b5 = 0\u2119\n  }\n\n+-0-rawGroup : RawGroup 0\u2113 0\u2113\n+-0-rawGroup = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; _\u207b\u00b9 = _\u207b\u00b9\n  ; \u03b5 = 0\u2119\n  }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = 1\u2119\n  }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2119\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2119\n  ; 1# = 1\u2119\n  }\n\n\n------------------------------------------------------------------------\n-- Homomorphisms between Parity and Sign\n\ntoSign : Parity \u2192 Sign\ntoSign 0\u2119 = +\ntoSign 1\u2119 = -\n\nfromSign : Sign \u2192 Parity\nfromSign + = 0\u2119\nfromSign - = 1\u2119\n</pre>"},{"location":"md/Data/Product/Base/","title":"Data.Product.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Products\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Product.Base where\n\nopen import Function.Base\nopen import Level using (Level; _\u2294_)\n\nprivate\n  variable\n    a b c d e f \u2113 p q r : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n    F : Set f\n\n------------------------------------------------------------------------\n-- Definition of dependent products\n\nopen import Agda.Builtin.Sigma public\n  renaming (fst to proj\u2081; snd to proj\u2082)\n  hiding (module \u03a3)\n\nmodule \u03a3 = Agda.Builtin.Sigma.\u03a3\n  renaming (fst to proj\u2081; snd to proj\u2082)\n\n------------------------------------------------------------------------\n-- Existential quantifiers\n\n\u2203 : \u2200 {A : Set a} \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u2203 = \u03a3 _\n\n\u2203\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b}\n     (C : (x : A) \u2192 B x \u2192 Set c) \u2192 Set (a \u2294 b \u2294 c)\n\u2203\u2082 C = \u2203 \u03bb a \u2192 \u2203 \u03bb b \u2192 C a b\n\n------------------------------------------------------------------------\n-- Syntaxes\n\n-- The syntax declaration below is attached to \u03a3-syntax, to make it\n-- easy to import \u03a3 without the special syntax.\n\ninfix 2 \u03a3-syntax\n\n\u03a3-syntax : (A : Set a) \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u03a3-syntax = \u03a3\n\nsyntax \u03a3-syntax A (\u03bb x \u2192 B) = \u03a3[ x \u2208 A ] B\n\ninfix 2 \u2203-syntax\n\n\u2203-syntax : \u2200 {A : Set a} \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u2203-syntax = \u2203\n\nsyntax \u2203-syntax (\u03bb x \u2192 B) = \u2203[ x ] B\n\n------------------------------------------------------------------------\n-- Definition of non-dependent products\n\ninfixr 4 _,\u2032_\ninfixr 2 _\u00d7_\n\n_\u00d7_ : \u2200 (A : Set a) (B : Set b) \u2192 Set (a \u2294 b)\nA \u00d7 B = \u03a3[ x \u2208 A ] B\n\n_,\u2032_ : A \u2192 B \u2192 A \u00d7 B\n_,\u2032_ = _,_\n\n------------------------------------------------------------------------\n-- Operations over dependent products\n\ninfix  4 -,_\ninfixr 2 _-\u00d7-_ _-,-_\ninfixl 2 _&lt;*&gt;_\n\n-- Sometimes the first component can be inferred.\n\n-,_ : \u2200 {A : Set a} {B : A \u2192 Set b} {x} \u2192 B x \u2192 \u03a3 _ B\n-, y = _ , y\n\n&lt;_,_&gt; : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u2200 {x} \u2192 B x \u2192 Set c}\n        (f : (x : A) \u2192 B x) \u2192 ((x : A) \u2192 C (f x)) \u2192\n        ((x : A) \u2192 \u03a3 (B x) C)\n&lt; f , g &gt; x = (f x , g x)\n\nmap : \u2200 {P : A \u2192 Set p} {Q : B \u2192 Set q} \u2192\n      (f : A \u2192 B) \u2192 (\u2200 {x} \u2192 P x \u2192 Q (f x)) \u2192\n      \u03a3 A P \u2192 \u03a3 B Q\nmap f g (x , y) = (f x , g y)\n\nmap\u2081 : (A \u2192 B) \u2192 A \u00d7 C \u2192 B \u00d7 C\nmap\u2081 f = map f id\n\nmap\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : A \u2192 Set c} \u2192\n       (\u2200 {x} \u2192 B x \u2192 C x) \u2192 \u03a3 A B \u2192 \u03a3 A C\nmap\u2082 f = map id f\n\n-- A version of map where the output can depend on the input\ndmap : \u2200 {B : A \u2192 Set b} {P : A \u2192 Set p} {Q : \u2200 {a} \u2192 P a \u2192 B a \u2192 Set q} \u2192\n       (f : (a : A) \u2192 B a) \u2192 (\u2200 {a} (b : P a) \u2192 Q b (f a)) \u2192\n       ((a , b) : \u03a3 A P) \u2192 \u03a3 (B a) (Q b)\ndmap f g (x , y) = f x , g y\n\nzip : \u2200 {P : A \u2192 Set p} {Q : B \u2192 Set q} {R : C \u2192 Set r} \u2192\n      (_\u2219_ : A \u2192 B \u2192 C) \u2192\n      (\u2200 {x y} \u2192 P x \u2192 Q y \u2192 R (x \u2219 y)) \u2192\n      \u03a3 A P \u2192 \u03a3 B Q \u2192 \u03a3 C R\nzip _\u2219_ _\u2218_ (a , p) (b , q) = ((a \u2219 b) , (p \u2218 q))\n\ncurry : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n        ((p : \u03a3 A B) \u2192 C p) \u2192\n        ((x : A) \u2192 (y : B x) \u2192 C (x , y))\ncurry f x y = f (x , y)\n\nuncurry : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n          ((x : A) \u2192 (y : B x) \u2192 C (x , y)) \u2192\n          ((p : \u03a3 A B) \u2192 C p)\nuncurry f (x , y) = f x y\n\n-- Rewriting dependent products\nassoc\u02b3 : {B : A \u2192 Set b} {C : (a : A) \u2192 B a \u2192 Set c} \u2192\n          \u03a3 (\u03a3 A B) (uncurry C) \u2192 \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (C a))\nassoc\u02b3 ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1 : {B : A \u2192 Set b} {C : (a : A) \u2192 B a \u2192 Set c} \u2192\n          \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (C a)) \u2192 \u03a3 (\u03a3 A B) (uncurry C)\nassoc\u02e1 (a , (b , c)) = ((a , b) , c)\n\n-- Alternate form of associativity for dependent products\n-- where the C parameter is uncurried.\nassoc\u02b3-curried : {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n                 \u03a3 (\u03a3 A B) C \u2192 \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (curry C a))\nassoc\u02b3-curried ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1-curried : {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n          \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (curry C a)) \u2192 \u03a3 (\u03a3 A B) C\nassoc\u02e1-curried (a , (b , c)) = ((a , b) , c)\n\n------------------------------------------------------------------------\n-- Operations for non-dependent products\n\n-- Any of the above operations for dependent products will also work for\n-- non-dependent products but sometimes Agda has difficulty inferring\n-- the non-dependency. Primed (\u2032 = \\prime) versions of the operations\n-- are therefore provided below that sometimes have better inference\n-- properties.\n\nzip\u2032 : (A \u2192 B \u2192 C) \u2192 (D \u2192 E \u2192 F) \u2192 A \u00d7 D \u2192 B \u00d7 E \u2192 C \u00d7 F\nzip\u2032 f g = zip f g\n\ncurry\u2032 : (A \u00d7 B \u2192 C) \u2192 (A \u2192 B \u2192 C)\ncurry\u2032 = curry\n\nuncurry\u2032 : (A \u2192 B \u2192 C) \u2192 (A \u00d7 B \u2192 C)\nuncurry\u2032 = uncurry\n\nmap\u2082\u2032 : (B \u2192 C) \u2192 A \u00d7 B \u2192 A \u00d7 C\nmap\u2082\u2032 f = map\u2082 f\n\ndmap\u2032 : \u2200 {x y} {X : A \u2192 Set x} {Y : B \u2192 Set y} \u2192\n        ((a : A) \u2192 X a) \u2192 ((b : B) \u2192 Y b) \u2192\n        ((a , b) : A \u00d7 B) \u2192 X a \u00d7 Y b\ndmap\u2032 f g = dmap f g\n\n_&lt;*&gt;_ : \u2200 {x y} {X : A \u2192 Set x} {Y : B \u2192 Set y} \u2192\n        ((a : A) \u2192 X a) \u00d7 ((b : B) \u2192 Y b) \u2192\n        ((a , b) : A \u00d7 B) \u2192 X a \u00d7 Y b\n_&lt;*&gt;_ = uncurry dmap\u2032\n\n-- Operations that can only be defined for non-dependent products\n\nswap : A \u00d7 B \u2192 B \u00d7 A\nswap (x , y) = (y , x)\n\n_-\u00d7-_ : (A \u2192 B \u2192 Set p) \u2192 (A \u2192 B \u2192 Set q) \u2192 (A \u2192 B \u2192 Set _)\nf -\u00d7- g = f -\u27ea _\u00d7_ \u27eb- g\n\n_-,-_ : (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 C \u00d7 D)\nf -,- g = f -\u27ea _,_ \u27eb- g\n\n-- Rewriting non-dependent products\nassoc\u02b3\u2032 : (A \u00d7 B) \u00d7 C \u2192 A \u00d7 (B \u00d7 C)\nassoc\u02b3\u2032 ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1\u2032 : A \u00d7 (B \u00d7 C) \u2192 (A \u00d7 B) \u00d7 C\nassoc\u02e1\u2032 (a , (b , c)) = ((a , b) , c)\n</pre>"},{"location":"md/Data/Sign/Base/","title":"Data.Sign.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Signs\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Sign.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid; RawGroup)\nopen import Level using (0\u2113)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\n------------------------------------------------------------------------\n-- Definition\n\ndata Sign : Set where\n  - : Sign\n  + : Sign\n\n------------------------------------------------------------------------\n-- Operations\n\n-- The opposite sign.\n\nopposite : Sign \u2192 Sign\nopposite - = +\nopposite + = -\n\n-- \"Multiplication\".\n\ninfixl 7 _*_\n\n_*_ : Sign \u2192 Sign \u2192 Sign\n+ * s\u2082 = s\u2082\n- * s\u2082 = opposite s\u2082\n\n------------------------------------------------------------------------\n-- Raw Bundles\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = +\n  }\n\n*-1-rawGroup : RawGroup 0\u2113 0\u2113\n*-1-rawGroup = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; _\u207b\u00b9 = opposite\n  ; \u03b5 = +\n  }\n\n</pre>"},{"location":"md/Data/String/Base/","title":"Data.String.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Strings: builtin type and basic operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.String.Base where\n\nopen import Data.Bool.Base using (Bool; true; false; if_then_else_)\nopen import Data.Char.Base as Char using (Char)\nopen import Data.List.Base as List using (List; [_]; _\u2237_; [])\nopen import Data.List.NonEmpty.Base as NE using (List\u207a)\nopen import Data.List.Relation.Binary.Pointwise.Base using (Pointwise)\nopen import Data.List.Relation.Binary.Lex.Core using (Lex-&lt;; Lex-\u2264)\nopen import Data.Maybe.Base as Maybe using (Maybe)\nopen import Data.Nat.Base using (\u2115; _\u2238_; \u230a_/2\u230b; \u2308_/2\u2309; _\u2261\u1d47_)\nopen import Data.Product.Base using (proj\u2081; proj\u2082)\nopen import Function.Base using (_on_; _\u2218\u2032_; _\u2218_)\nopen import Level using (Level; 0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; refl)\nopen import Relation.Unary using (Pred; Decidable)\nopen import Relation.Nullary.Decidable.Core using (does; T?)\n\n------------------------------------------------------------------------\n-- From Agda.Builtin: type and renamed primitives\n\n-- Note that we do not re-export primStringAppend because we want to\n-- give it an infix definition and be able to assign it a level.\n\nimport Agda.Builtin.String as String\n\nopen String public using ( String )\n  renaming\n  ( primStringUncons   to uncons\n  ; primStringToList   to toList\n  ; primStringFromList to fromList\n  ; primShowString     to show\n  )\n\n------------------------------------------------------------------------\n-- Relations\n\n-- Pointwise equality on Strings\n\ninfix 4 _\u2248_\n_\u2248_ : Rel String 0\u2113\n_\u2248_ = Pointwise _\u2261_ on toList\n\n-- Lexicographic ordering on Strings\n\ninfix 4 _&lt;_\n_&lt;_ : Rel String 0\u2113\n_&lt;_ = Lex-&lt; _\u2261_ Char._&lt;_ on toList\n\ninfix 4 _\u2264_\n_\u2264_ : Rel String 0\u2113\n_\u2264_ = Lex-\u2264 _\u2261_ Char._&lt;_ on toList\n\n------------------------------------------------------------------------\n-- Operations\n\n-- List-like operations\n\nhead : String \u2192 Maybe Char\nhead = Maybe.map proj\u2081 \u2218\u2032 uncons\n\ntail : String \u2192 Maybe String\ntail = Maybe.map proj\u2082 \u2218\u2032 uncons\n\n-- Additional conversion functions\n\nfromChar : Char \u2192 String\nfromChar = fromList \u2218\u2032 [_]\n\nfromList\u207a : List\u207a Char \u2192 String\nfromList\u207a = fromList \u2218\u2032 NE.toList\n\n-- List-like functions\n\ninfixr 5 _++_\n_++_ : String \u2192 String \u2192 String\n_++_ = String.primStringAppend\n\nlength : String \u2192 \u2115\nlength = List.length \u2218 toList\n\nreplicate : \u2115 \u2192 Char \u2192 String\nreplicate n = fromList \u2218 List.replicate n\n\nconcat : List String \u2192 String\nconcat = List.foldr _++_ \"\"\n\nintersperse : String \u2192 List String \u2192 String\nintersperse sep = concat \u2218\u2032 (List.intersperse sep)\n\nunwords : List String \u2192 String\nunwords = intersperse \" \"\n\nunlines : List String \u2192 String\nunlines = intersperse \"\\n\"\n\nbetween : String \u2192 String \u2192 String \u2192 String\nbetween left right middle = left ++ middle ++ right\n\nparens : String \u2192 String\nparens = between \"(\" \")\"\n\nbraces : String \u2192 String\nbraces = between \"{\" \"}\"\n\n-- append that also introduces spaces, if necessary\ninfixr 5 _&lt;+&gt;_\n_&lt;+&gt;_ : String \u2192 String \u2192 String\n\"\" &lt;+&gt; b = b\na &lt;+&gt; \"\" = a\na &lt;+&gt; b = a ++ \" \" ++ b\n\n------------------------------------------------------------------------\n-- Padding\n\n-- Each one of the padding functions should verify the following\n-- invariant:\n--   If length str \u2264 n then length (padLeft c n str) \u2261 n\n--   and otherwise padLeft c n str \u2261 str.\n\n-- Appending an empty string is expensive (append for Haskell's\n-- Text creates a fresh Text value in which both contents are\n-- copied) so we precompute `n \u2238 length str` and check whether\n-- it is equal to 0.\n\npadLeft : Char \u2192 \u2115 \u2192 String \u2192 String\npadLeft c n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else replicate l c ++ str\n\npadRight : Char \u2192 \u2115 \u2192 String \u2192 String\npadRight c n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else str ++ replicate l c\n\npadBoth : Char \u2192 Char \u2192 \u2115 \u2192 String \u2192 String\npadBoth c\u2097 c\u1d63 n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else replicate \u230a l /2\u230b c\u2097 ++ str ++ replicate \u2308 l /2\u2309 c\u1d63\n\n------------------------------------------------------------------------\n-- Alignment\n\n-- We can align a String left, center or right in a column of a given\n-- width by padding it with whitespace.\n\ndata Alignment : Set where\n  Left Center Right : Alignment\n\nfromAlignment : Alignment \u2192 \u2115 \u2192 String \u2192 String\nfromAlignment Left   = padRight ' '\nfromAlignment Center = padBoth ' ' ' '\nfromAlignment Right  = padLeft ' '\n\n------------------------------------------------------------------------\n-- Splitting strings\n\nwordsBy : \u2200 {p} {P : Pred Char p} \u2192 Decidable P \u2192 String \u2192 List String\nwordsBy P? = List.map fromList \u2218 List.wordsBy P? \u2218 toList\n\nwordsBy\u1d47 : (Char \u2192 Bool) \u2192 String \u2192 List String\nwordsBy\u1d47 p = wordsBy (T? \u2218 p)\n\nwords : String \u2192 List String\nwords = wordsBy\u1d47 Char.isSpace\n\n-- `words` ignores contiguous whitespace\n_ : words \" abc  b   \" \u2261 \"abc\" \u2237 \"b\" \u2237 []\n_ = refl\n\nlinesBy : \u2200 {p} {P : Pred Char p} \u2192 Decidable P \u2192 String \u2192 List String\nlinesBy P? = List.map fromList \u2218 List.linesBy P? \u2218 toList\n\nlinesBy\u1d47 : (Char \u2192 Bool) \u2192 String \u2192 List String\nlinesBy\u1d47 p = linesBy (T? \u2218 p)\n\nlines : String \u2192 List String\nlines = linesBy\u1d47 ('\\n' Char.\u2248\u1d47_)\n\n-- `lines` preserves empty lines\n_ : lines \"\\nabc\\n\\nb\\n\\n\\n\" \u2261 \"\" \u2237 \"abc\" \u2237 \"\" \u2237 \"b\" \u2237 \"\" \u2237 \"\" \u2237 []\n_ = refl\n\nmap : (Char \u2192 Char) \u2192 String \u2192 String\nmap f = fromList \u2218 List.map f \u2218 toList\n\n_ : map Char.toUpper \"abc\" \u2261 \"ABC\"\n_ = refl\n</pre>"},{"location":"md/Data/Sum/Base/","title":"Data.Sum.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Sums (disjoint unions)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Sum.Base where\n\nopen import Data.Bool.Base using (true; false)\nopen import Function.Base using (_\u2218_; _\u2218\u2032_; _-\u27ea_\u27eb-_ ; id)\nopen import Level using (Level; _\u2294_)\n\nprivate\n  variable\n    a b c d : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 1 _\u228e_\n\ndata _\u228e_ (A : Set a) (B : Set b) : Set (a \u2294 b) where\n  inj\u2081 : (x : A) \u2192 A \u228e B\n  inj\u2082 : (y : B) \u2192 A \u228e B\n\n------------------------------------------------------------------------\n-- Functions\n\n[_,_] : \u2200 {C : A \u228e B \u2192 Set c} \u2192\n        ((x : A) \u2192 C (inj\u2081 x)) \u2192 ((x : B) \u2192 C (inj\u2082 x)) \u2192\n        ((x : A \u228e B) \u2192 C x)\n[ f , g ] (inj\u2081 x) = f x\n[ f , g ] (inj\u2082 y) = g y\n\n[_,_]\u2032 : (A \u2192 C) \u2192 (B \u2192 C) \u2192 (A \u228e B \u2192 C)\n[_,_]\u2032 = [_,_]\n\nfromInj\u2081 : (B \u2192 A) \u2192 A \u228e B \u2192 A\nfromInj\u2081 = [ id ,_]\u2032\n\nfromInj\u2082 : (A \u2192 B) \u2192 A \u228e B \u2192 B\nfromInj\u2082 = [_, id ]\u2032\n\nreduce : A \u228e A \u2192 A\nreduce = [ id , id ]\u2032\n\nswap : A \u228e B \u2192 B \u228e A\nswap (inj\u2081 x) = inj\u2082 x\nswap (inj\u2082 x) = inj\u2081 x\n\nmap : (A \u2192 C) \u2192 (B \u2192 D) \u2192 (A \u228e B \u2192 C \u228e D)\nmap f g = [ inj\u2081 \u2218 f , inj\u2082 \u2218 g ]\u2032\n\nmap\u2081 : (A \u2192 C) \u2192 (A \u228e B \u2192 C \u228e B)\nmap\u2081 f = map f id\n\nmap\u2082 : (B \u2192 D) \u2192 (A \u228e B \u2192 A \u228e D)\nmap\u2082 = map id\n\nassoc\u02b3 : (A \u228e B) \u228e C \u2192 A \u228e B \u228e C\nassoc\u02b3 = [ map\u2082 inj\u2081 , inj\u2082 \u2218\u2032 inj\u2082 ]\u2032\n\nassoc\u02e1 : A \u228e B \u228e C \u2192 (A \u228e B) \u228e C\nassoc\u02e1 = [ inj\u2081 \u2218\u2032 inj\u2081 , map\u2081 inj\u2082 ]\u2032\n\ninfixr 1 _-\u228e-_\n_-\u228e-_ : (A \u2192 B \u2192 Set c) \u2192 (A \u2192 B \u2192 Set d) \u2192 (A \u2192 B \u2192 Set (c \u2294 d))\nf -\u228e- g = f -\u27ea _\u228e_ \u27eb- g\n</pre>"},{"location":"md/Data/These/Base/","title":"Data.These.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- An either-or-both data type, basic type and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.These.Base where\n\nopen import Level using (Level; _\u2294_)\nopen import Data.Sum.Base using (_\u228e_; [_,_]\u2032)\nopen import Function.Base using (id; flip)\n\nprivate\n  variable\n    a b c d e f : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n    F : Set f\n\ndata These {a b} (A : Set a) (B : Set b) : Set (a \u2294 b) where\n  this  : A     \u2192 These A B\n  that  :     B \u2192 These A B\n  these : A \u2192 B \u2192 These A B\n\n------------------------------------------------------------------------\n-- Operations\n\n-- injection\n\nfromSum : A \u228e B \u2192 These A B\nfromSum = [ this , that ]\u2032\n\n-- map\n\nmap : (f : A \u2192 B) (g : C \u2192 D) \u2192 These A C \u2192 These B D\nmap f g (this a)    = this (f a)\nmap f g (that b)    = that (g b)\nmap f g (these a b) = these (f a) (g b)\n\nmap\u2081 : (f : A \u2192 B) \u2192 These A C \u2192 These B C\nmap\u2081 f = map f id\n\nmap\u2082 : (g : B \u2192 C) \u2192 These A B \u2192 These A C\nmap\u2082 = map id\n\n-- fold\n\nfold : (A \u2192 C) \u2192 (B \u2192 C) \u2192 (A \u2192 B \u2192 C) \u2192 These A B \u2192 C\nfold l r lr (this a)    = l a\nfold l r lr (that b)    = r b\nfold l r lr (these a b) = lr a b\n\nfoldWithDefaults : A \u2192 B \u2192 (A \u2192 B \u2192 C) \u2192 These A B \u2192 C\nfoldWithDefaults a b lr = fold (flip lr b) (lr a) lr\n\n-- swap\n\nswap : These A B \u2192 These B A\nswap = fold that this (flip these)\n\n-- align\n\nalignWith : (These A C \u2192 E) \u2192 (These B D \u2192 F) \u2192 These A B \u2192 These C D \u2192 These E F\nalignWith f g (this a)    (this c)    = this (f (these a c))\nalignWith f g (this a)    (that d)    = these (f (this a)) (g (that d))\nalignWith f g (this a)    (these c d) = these (f (these a c)) (g (that d))\nalignWith f g (that b)    (this c)    = these (f (that c)) (g (this b))\nalignWith f g (that b)    (that d)    = that (g (these b d))\nalignWith f g (that b)    (these c d) = these (f (that c)) (g (these b d))\nalignWith f g (these a b) (this c)    = these (f (these a c)) (g (this b))\nalignWith f g (these a b) (that d)    = these (f (this a)) (g (these b d))\nalignWith f g (these a b) (these c d) = these (f (these a c)) (g (these b d))\n\nalign : These A B \u2192 These C D \u2192 These (These A C) (These B D)\nalign = alignWith id id\n</pre>"},{"location":"md/Data/Unit/Base/","title":"Data.Unit.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The unit type and the total relation on unit\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Unit.Base where\n\n------------------------------------------------------------------------\n-- A unit type defined as a record type\n\n-- Note that by default the unit type is not universe polymorphic as it\n-- often results in unsolved metas. See `Data.Unit.Polymorphic` for a\n-- universe polymorphic variant.\n\n-- Note also that the name of this type is \"\\top\", not T.\n\nopen import Agda.Builtin.Unit public\n  using (\u22a4; tt)\n</pre>"},{"location":"md/Data/Unit/Polymorphic/Base/","title":"Data.Unit.Polymorphic.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- A universe polymorphic unit type, as a Lift of the Level 0 one.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Unit.Polymorphic.Base where\n\nopen import Level using (Level; Lift; lift)\nimport Data.Unit.Base as \u22a4\n\n------------------------------------------------------------------------\n-- A unit type defined as a synonym\n\n\u22a4 : {\u2113 : Level} \u2192 Set \u2113\n\u22a4 {\u2113} = Lift \u2113 \u22a4.\u22a4\n\ntt : {\u2113 : Level} \u2192 \u22a4 {\u2113}\ntt = lift \u22a4.tt\n</pre>"},{"location":"md/Data/Vec/Base/","title":"Data.Vec.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Vectors, basic types and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Vec.Base where\n\nopen import Data.Bool.Base using (Bool; true; false; if_then_else_)\nopen import Data.Nat.Base\nopen import Data.Fin.Base using (Fin; zero; suc)\nopen import Data.List.Base as List using (List)\nopen import Data.Product.Base as Product using (\u2203; \u2203\u2082; _\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Function.Base using (const; _\u2218\u2032_; id; _\u2218_; _$_)\nopen import Level using (Level)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; refl; trans; cong)\nopen import Relation.Nullary.Decidable.Core using (does; T?)\nopen import Relation.Unary using (Pred; Decidable)\n\nprivate\n  variable\n    a b c p : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    m n : \u2115\n\n------------------------------------------------------------------------\n-- Types\n\ninfixr 5 _\u2237_\n\ndata Vec (A : Set a) : \u2115 \u2192 Set a where\n  []  : Vec A zero\n  _\u2237_ : \u2200 (x : A) (xs : Vec A n) \u2192 Vec A (suc n)\n\ninfix 4 _[_]=_\n\ndata _[_]=_ {A : Set a} : Vec A n \u2192 Fin n \u2192 A \u2192 Set a where\n  here  : \u2200     {x}   {xs : Vec A n} \u2192 x \u2237 xs [ zero ]= x\n  there : \u2200 {i} {x y} {xs : Vec A n}\n    (xs[i]=x : xs [ i ]= x) \u2192 y \u2237 xs [ suc i ]= x\n\n------------------------------------------------------------------------\n-- Basic operations\n\nlength : Vec A n \u2192 \u2115\nlength {n = n} _ = n\n\nhead : Vec A (1 + n) \u2192 A\nhead (x \u2237 xs) = x\n\ntail : Vec A (1 + n) \u2192 Vec A n\ntail (x \u2237 xs) = xs\n\nlookup : Vec A n \u2192 Fin n \u2192 A\nlookup (x \u2237 xs) zero    = x\nlookup (x \u2237 xs) (suc i) = lookup xs i\n\niterate : (A \u2192 A) \u2192 A \u2192 \u2200 n \u2192 Vec A n\niterate s z zero    = []\niterate s z (suc n) = z \u2237 iterate s (s z) n\n\ninsertAt : Vec A n \u2192 Fin (suc n) \u2192 A \u2192 Vec A (suc n)\ninsertAt xs       zero     v = v \u2237 xs\ninsertAt (x \u2237 xs) (suc i)  v = x \u2237 insertAt xs i v\n\nremoveAt : Vec A (suc n) \u2192 Fin (suc n) \u2192 Vec A n\nremoveAt (x \u2237 xs)         zero    = xs\nremoveAt (x \u2237 xs@(_ \u2237 _)) (suc i) = x \u2237 removeAt xs i\n\nupdateAt : Vec A n \u2192 Fin n \u2192 (A \u2192 A) \u2192 Vec A n\nupdateAt (x \u2237 xs) zero    f = f x \u2237 xs\nupdateAt (x \u2237 xs) (suc i) f = x   \u2237 updateAt xs i f\n\n-- xs [ i ]%= f  modifies the i-th element of xs according to f\n\ninfixl 6 _[_]%=_ _[_]\u2254_\n\n_[_]%=_ : Vec A n \u2192 Fin n \u2192 (A \u2192 A) \u2192 Vec A n\nxs [ i ]%= f = updateAt xs i f\n\n-- xs [ i ]\u2254 y  overwrites the i-th element of xs with y\n\n_[_]\u2254_ : Vec A n \u2192 Fin n \u2192 A \u2192 Vec A n\nxs [ i ]\u2254 y = xs [ i ]%= const y\n\n------------------------------------------------------------------------\n-- Operations for transforming vectors\n\n-- See README.Data.Vec.Relation.Binary.Equality.Cast for the reasoning\n-- system of `cast`-ed equality.\ncast : .(eq : m \u2261 n) \u2192 Vec A m \u2192 Vec A n\ncast {n = zero}  eq []       = []\ncast {n = suc _} eq (x \u2237 xs) = x \u2237 cast (cong pred eq) xs\n\nmap : (A \u2192 B) \u2192 Vec A n \u2192 Vec B n\nmap f []       = []\nmap f (x \u2237 xs) = f x \u2237 map f xs\n\n-- Concatenation.\n\ninfixr 5 _++_\n\n_++_ : Vec A m \u2192 Vec A n \u2192 Vec A (m + n)\n[]       ++ ys = ys\n(x \u2237 xs) ++ ys = x \u2237 (xs ++ ys)\n\nconcat : Vec (Vec A m) n \u2192 Vec A (n * m)\nconcat []         = []\nconcat (xs \u2237 xss) = xs ++ concat xss\n\n-- Align, Restrict, and Zip.\n\nalignWith : (These A B \u2192 C) \u2192 Vec A m \u2192 Vec B n \u2192 Vec C (m \u2294 n)\nalignWith f []         bs       = map (f \u2218\u2032 that) bs\nalignWith f as@(_ \u2237 _) []       = map (f \u2218\u2032 this) as\nalignWith f (a \u2237 as)   (b \u2237 bs) = f (these a b) \u2237 alignWith f as bs\n\nrestrictWith : (A \u2192 B \u2192 C) \u2192 Vec A m \u2192 Vec B n \u2192 Vec C (m \u2293 n)\nrestrictWith f []       bs       = []\nrestrictWith f (_ \u2237 _)  []       = []\nrestrictWith f (a \u2237 as) (b \u2237 bs) = f a b \u2237 restrictWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Vec A n \u2192 Vec B n \u2192 Vec C n\nzipWith f []       []       = []\nzipWith f (x \u2237 xs) (y \u2237 ys) = f x y \u2237 zipWith f xs ys\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 Vec A n \u2192 Vec B n \u00d7 Vec C n\nunzipWith f []       = [] , []\nunzipWith f (a \u2237 as) = Product.zip _\u2237_ _\u2237_ (f a) (unzipWith f as)\n\nalign : Vec A m \u2192 Vec B n \u2192 Vec (These A B) (m \u2294 n)\nalign = alignWith id\n\nrestrict : Vec A m \u2192 Vec B n \u2192 Vec (A \u00d7 B) (m \u2293 n)\nrestrict = restrictWith _,_\n\nzip : Vec A n \u2192 Vec B n \u2192 Vec (A \u00d7 B) n\nzip = zipWith _,_\n\nunzip : Vec (A \u00d7 B) n \u2192 Vec A n \u00d7 Vec B n\nunzip = unzipWith id\n\n-- Interleaving.\n\ninfixr 5 _\u22ce_\n\n_\u22ce_ : Vec A m \u2192 Vec A n \u2192 Vec A (m +\u22ce n)\n[]       \u22ce ys = ys\n(x \u2237 xs) \u22ce ys = x \u2237 (ys \u22ce xs)\n\n-- Pointwise application\n\ninfixl 4 _\u229b_\n\n_\u229b_ : Vec (A \u2192 B) n \u2192 Vec A n \u2192 Vec B n\n[]       \u229b []       = []\n(f \u2237 fs) \u229b (x \u2237 xs) = f x \u2237 (fs \u229b xs)\n\n-- Multiplication\n\nmodule CartesianBind where\n  infixl 1 _&gt;&gt;=_\n\n  _&gt;&gt;=_ : Vec A m \u2192 (A \u2192 Vec B n) \u2192 Vec B (m * n)\n  xs &gt;&gt;= f = concat (map f xs)\n\ninfixl 4 _\u229b*_\n\n_\u229b*_ : Vec (A \u2192 B) m \u2192 Vec A n \u2192 Vec B (m * n)\nfs \u229b* xs = fs CartesianBind.&gt;&gt;= \u03bb f \u2192 map f xs\n\nallPairs : Vec A m \u2192 Vec B n \u2192 Vec (A \u00d7 B) (m * n)\nallPairs xs ys = map _,_ xs \u229b* ys\n\n-- Diagonal\n\ndiagonal : Vec (Vec A n) n \u2192 Vec A n\ndiagonal [] = []\ndiagonal (xs \u2237 xss) = head xs \u2237 diagonal (map tail xss)\n\nmodule DiagonalBind where\n  infixl 1 _&gt;&gt;=_\n\n  _&gt;&gt;=_ : Vec A n \u2192 (A \u2192 Vec B n) \u2192 Vec B n\n  xs &gt;&gt;= f = diagonal (map f xs)\n\n\n------------------------------------------------------------------------\n-- Operations for reducing vectors\n\n-- Dependent folds\n\nmodule _ (A : Set a) (B : \u2115 \u2192 Set b) where\n\n  FoldrOp = \u2200 {n} \u2192 A \u2192 B n \u2192 B (suc n)\n  FoldlOp = \u2200 {n} \u2192 B n \u2192 A \u2192 B (suc n)\n\nfoldr : \u2200 (B : \u2115 \u2192 Set b) \u2192 FoldrOp A B \u2192 B zero \u2192 Vec A n \u2192 B n\nfoldr B _\u2295_ e []       = e\nfoldr B _\u2295_ e (x \u2237 xs) = x \u2295 foldr B _\u2295_ e xs\n\nfoldl : \u2200 (B : \u2115 \u2192 Set b) \u2192 FoldlOp A B \u2192 B zero \u2192 Vec A n \u2192 B n\nfoldl B _\u2295_ e []       = e\nfoldl B _\u2295_ e (x \u2237 xs) = foldl (B \u2218 suc) _\u2295_ (e \u2295 x) xs\n\n-- Non-dependent folds\n\nfoldr\u2032 : (A \u2192 B \u2192 B) \u2192 B \u2192 Vec A n \u2192 B\nfoldr\u2032 _\u2295_ = foldr _ _\u2295_\n\nfoldl\u2032 : (B \u2192 A \u2192 B) \u2192 B \u2192 Vec A n \u2192 B\nfoldl\u2032 _\u2295_ = foldl _ _\u2295_\n\n-- Non-empty folds\n\nfoldr\u2081 : (A \u2192 A \u2192 A) \u2192 Vec A (suc n) \u2192 A\nfoldr\u2081 _\u2295_ (x \u2237 [])     = x\nfoldr\u2081 _\u2295_ (x \u2237 y \u2237 ys) = x \u2295 foldr\u2081 _\u2295_ (y \u2237 ys)\n\nfoldl\u2081 : (A \u2192 A \u2192 A) \u2192 Vec A (suc n) \u2192 A\nfoldl\u2081 _\u2295_ (x \u2237 xs) = foldl _ _\u2295_ x xs\n\n-- Special folds\n\nsum : Vec \u2115 n \u2192 \u2115\nsum = foldr _ _+_ 0\n\ncount : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 Vec A n \u2192 \u2115\ncount P? []       = zero\ncount P? (x \u2237 xs) = if does (P? x) then suc else id $ count P? xs\n\ncount\u1d47 : (A \u2192 Bool) \u2192 Vec A n \u2192 \u2115\ncount\u1d47 p = count (T? \u2218 p)\n\n------------------------------------------------------------------------\n-- Operations for building vectors\n\n[_] : A \u2192 Vec A 1\n[ x ] = x \u2237 []\n\nreplicate : (n : \u2115) \u2192 A \u2192 Vec A n\nreplicate zero    x = []\nreplicate (suc n) x = x \u2237 replicate n x\n\ntabulate : (Fin n \u2192 A) \u2192 Vec A n\ntabulate {n = zero}  f = []\ntabulate {n = suc n} f = f zero \u2237 tabulate (f \u2218 suc)\n\nallFin : \u2200 n \u2192 Vec (Fin n) n\nallFin _ = tabulate id\n\n------------------------------------------------------------------------\n-- Operations for dividing vectors\n\nsplitAt : \u2200 m {n} (xs : Vec A (m + n)) \u2192\n          \u2203\u2082 \u03bb (ys : Vec A m) (zs : Vec A n) \u2192 xs \u2261 ys ++ zs\nsplitAt zero    xs                = [] , xs , refl\nsplitAt (suc m) (x \u2237 xs) =\n  let ys , zs , eq = splitAt m xs in x \u2237 ys , zs , cong (x \u2237_) eq\n\ntake : \u2200 m {n} \u2192 Vec A (m + n) \u2192 Vec A m\ntake m xs = proj\u2081 (splitAt m xs)\n\ndrop : \u2200 m {n} \u2192 Vec A (m + n) \u2192 Vec A n\ndrop m xs = proj\u2081 (proj\u2082 (splitAt m xs))\n\ngroup : \u2200 n k (xs : Vec A (n * k)) \u2192\n        \u2203 \u03bb (xss : Vec (Vec A k) n) \u2192 xs \u2261 concat xss\ngroup zero    k []                  = ([] , refl)\ngroup (suc n) k xs  =\n  let ys , zs , eq-split = splitAt k xs in\n  let zss , eq-group     = group n k zs in\n   (ys \u2237 zss) , trans eq-split (cong (ys ++_) eq-group)\n\nsplit : Vec A n \u2192 Vec A \u2308 n /2\u2309 \u00d7 Vec A \u230a n /2\u230b\nsplit []           = ([]     , [])\nsplit (x \u2237 [])     = (x \u2237 [] , [])\nsplit (x \u2237 y \u2237 xs) = Product.map (x \u2237_) (y \u2237_) (split xs)\n\nuncons : Vec A (suc n) \u2192 A \u00d7 Vec A n\nuncons (x \u2237 xs) = x , xs\n\n------------------------------------------------------------------------\n-- Operations involving \u2264\n\n-- Take the first 'm' elements of a vector.\ntruncate : \u2200 {m n} \u2192 m \u2264 n \u2192 Vec A n \u2192 Vec A m\ntruncate {m = zero} _ _    = []\ntruncate (s\u2264s le) (x \u2237 xs) = x \u2237 (truncate le xs)\n\n-- Pad out a vector with extra elements.\npadRight : \u2200 {m n} \u2192 m \u2264 n \u2192 A \u2192 Vec A m \u2192 Vec A n\npadRight z\u2264n      a xs       = replicate _ a\npadRight (s\u2264s le) a (x \u2237 xs) = x \u2237 padRight le a xs\n\n------------------------------------------------------------------------\n-- Operations for converting between lists\n\ntoList : Vec A n \u2192 List A\ntoList []       = List.[]\ntoList (x \u2237 xs) = List._\u2237_ x (toList xs)\n\nfromList : (xs : List A) \u2192 Vec A (List.length xs)\nfromList List.[]         = []\nfromList (List._\u2237_ x xs) = x \u2237 fromList xs\n\n------------------------------------------------------------------------\n-- Operations for reversing vectors\n\n-- snoc\n\ninfixl 5 _\u2237\u02b3_\n\n_\u2237\u02b3_ : Vec A n \u2192 A \u2192 Vec A (suc n)\n[]       \u2237\u02b3 y = [ y ]\n(x \u2237 xs) \u2237\u02b3 y = x \u2237 (xs \u2237\u02b3 y)\n\n-- vanilla reverse\n\nreverse : Vec A n \u2192 Vec A n\nreverse = foldl (Vec _) (\u03bb rev x \u2192 x \u2237 rev) []\n\n-- reverse-append\n\ninfix 5 _\u02b3++_\n\n_\u02b3++_ : Vec A m \u2192 Vec A n \u2192 Vec A (m + n)\nxs \u02b3++ ys = foldl (Vec _ \u2218 (_+ _)) (\u03bb rev x \u2192 x \u2237 rev) ys xs\n\n-- init and last\n\ninitLast : \u2200 (xs : Vec A (1 + n)) \u2192 \u2203\u2082 \u03bb ys y \u2192 xs \u2261 ys \u2237\u02b3 y\ninitLast {n = zero}  (x \u2237 []) = [] , x , refl\ninitLast {n = suc n} (x \u2237 xs) =\n  let ys , y , eq = initLast xs in\n  x \u2237 ys , y , cong (x \u2237_) eq\n\ninit : Vec A (1 + n) \u2192 Vec A n\ninit xs = proj\u2081 (initLast xs)\n\nlast : Vec A (1 + n) \u2192 A\nlast xs = proj\u2081 (proj\u2082 (initLast xs))\n\n------------------------------------------------------------------------\n-- Other operations\n\ntranspose : Vec (Vec A n) m \u2192 Vec (Vec A m) n\ntranspose {n = n} []          = replicate n []\ntranspose {n = n} (as \u2237 ass) = ((replicate n _\u2237_) \u229b as) \u229b transpose ass\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nremove = removeAt\n{-# WARNING_ON_USAGE remove\n\"Warning: remove was deprecated in v2.0.\nPlease use removeAt instead.\"\n#-}\ninsert = insertAt\n{-# WARNING_ON_USAGE insert\n\"Warning: insert was deprecated in v2.0.\nPlease use insertAt instead.\"\n#-}\n</pre>"},{"location":"md/Effect/Applicative/","title":"Effect.Applicative","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Applicative functors\n------------------------------------------------------------------------\n\n-- Note that currently the applicative functor laws are not included\n-- here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Applicative where\n\nopen import Data.Bool.Base using (Bool; true; false)\nopen import Data.Product.Base using (_\u00d7_; _,_)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Effect.Choice using (RawChoice)\nopen import Effect.Empty using (RawEmpty)\nopen import Effect.Functor as Fun using (RawFunctor)\nopen import Function.Base using (const; flip; _\u2218\u2032_)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\nprivate\n  variable\n    f g : Level\n    A B C : Set f\n------------------------------------------------------------------------\n-- The type of raw applicatives\n\nrecord RawApplicative (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  infixl 4 _&lt;*&gt;_ _&lt;*_ _*&gt;_\n  infixl 4 _\u229b_ _&lt;\u229b_ _\u229b&gt;_\n  infix  4 _\u2297_\n  field\n    rawFunctor : RawFunctor F\n    pure : A \u2192 F A\n    _&lt;*&gt;_ : F (A \u2192 B) \u2192 F A \u2192 F B\n\n  open RawFunctor rawFunctor public\n\n  _&lt;*_ : F A \u2192 F B \u2192 F A\n  a &lt;* b = const &lt;$&gt; a &lt;*&gt; b\n\n  _*&gt;_ : F A \u2192 F B \u2192 F B\n  a *&gt; b = flip const &lt;$&gt; a &lt;*&gt; b\n\n  zipWith : (A \u2192 B \u2192 C) \u2192 F A \u2192 F B \u2192 F C\n  zipWith f x y = f &lt;$&gt; x &lt;*&gt; y\n\n  zip : F A \u2192 F B \u2192 F (A \u00d7 B)\n  zip = zipWith _,_\n\n  -- Haskell-style alternative name for pure\n  return : A \u2192 F A\n  return = pure\n\n  -- backwards compatibility: unicode variants\n  _\u229b_ : F (A \u2192 B) \u2192 F A \u2192 F B\n  _\u229b_ = _&lt;*&gt;_\n\n  _&lt;\u229b_ : F A \u2192 F B \u2192 F A\n  _&lt;\u229b_ = _&lt;*_\n\n  _\u229b&gt;_ : F A \u2192 F B \u2192 F B\n  _\u229b&gt;_ = _*&gt;_\n\n  _\u2297_ : F A \u2192 F B \u2192 F (A \u00d7 B)\n  _\u2297_ = zip\n\nmodule _ where\n\n  open RawApplicative\n  open RawFunctor\n\n  -- Smart constructor\n  mkRawApplicative :\n    (F : Set f \u2192 Set g) \u2192\n    (pure : \u2200 {A} \u2192 A \u2192 F A) \u2192\n    (app : \u2200 {A B} \u2192 F (A \u2192 B) \u2192 F A \u2192 F B) \u2192\n    RawApplicative F\n  mkRawApplicative F pure app .rawFunctor ._&lt;$&gt;_ = app \u2218\u2032 pure\n  mkRawApplicative F pure app .pure = pure\n  mkRawApplicative F pure app ._&lt;*&gt;_ = app\n\n------------------------------------------------------------------------\n-- The type of raw applicatives with a zero\n\nrecord RawApplicativeZero (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawApplicative : RawApplicative F\n    rawEmpty : RawEmpty F\n\n  open RawApplicative rawApplicative public\n  open RawEmpty rawEmpty public\n\n  guard : Bool \u2192 F \u22a4\n  guard true = pure _\n  guard false = empty\n\n------------------------------------------------------------------------\n-- The type of raw alternative applicatives\n\nrecord RawAlternative (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawApplicativeZero : RawApplicativeZero F\n    rawChoice : RawChoice F\n\n  open RawApplicativeZero rawApplicativeZero public\n  open RawChoice rawChoice public\n\n------------------------------------------------------------------------\n-- The type of applicative morphisms\n\nrecord Morphism {F\u2081 F\u2082 : Set f \u2192 Set g}\n                (A\u2081 : RawApplicative F\u2081)\n                (A\u2082 : RawApplicative F\u2082) : Set (suc f \u2294 g) where\n  module A\u2081 = RawApplicative A\u2081\n  module A\u2082 = RawApplicative A\u2082\n  field\n    functorMorphism : Fun.Morphism A\u2081.rawFunctor A\u2082.rawFunctor\n\n  open Fun.Morphism functorMorphism public\n\n  field\n    op-pure : (x : A) \u2192 op (A\u2081.pure x) \u2261 A\u2082.pure x\n    op-&lt;*&gt;  : (f : F\u2081 (A \u2192 B)) (x : F\u2081 A) \u2192\n              op (f A\u2081.\u229b x) \u2261 (op f A\u2082.\u229b op x)\n\n  -- backwards compatibility: unicode variants\n  op-\u229b = op-&lt;*&gt;\n</pre>"},{"location":"md/Effect/Choice/","title":"Effect.Choice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Type constructors giving rise to a semigroup at every type\n-- e.g. (List, _++_)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Choice where\n\nopen import Level\n\nprivate\n  variable\n    \u2113 \u2113\u2032 : Level\n    A  : Set \u2113\n\nrecord RawChoice (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  infixr 3 _&lt;|&gt;_ _\u2223_\n  field\n    _&lt;|&gt;_ : F A \u2192 F A \u2192 F A\n\n  -- backwards compatibility: unicode variants\n  _\u2223_ : F A \u2192 F A \u2192 F A\n  _\u2223_ = _&lt;|&gt;_\n</pre>"},{"location":"md/Effect/Empty/","title":"Effect.Empty","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Empty values (e.g. [] for List, nothing for Maybe)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Empty where\n\nopen import Level using (Level; suc; _\u2294_)\n\nprivate\n  variable\n    \u2113 \u2113\u2032 : Level\n    A  : Set \u2113\n\nrecord RawEmpty (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  field\n    empty : F A\n\n  -- backwards compatibility: unicode variants\n  \u2205 : F A\n  \u2205 = empty\n</pre>"},{"location":"md/Effect/Functor/","title":"Effect.Functor","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Functors\n------------------------------------------------------------------------\n\n-- Note that currently the functor laws are not included here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Functor where\n\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Function.Base using (const; flip)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\nprivate\n  variable\n    \u2113 \u2113\u2032 \u2113\u2033 : Level\n    A B X Y : Set \u2113\n\nrecord RawFunctor (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  infixl 4 _&lt;$&gt;_ _&lt;$_\n  infixl 1 _&lt;&amp;&gt;_\n  field\n    _&lt;$&gt;_ : (A \u2192 B) \u2192 F A \u2192 F B\n\n  _&lt;$_ : A \u2192 F B \u2192 F A\n  x &lt;$ y = const x &lt;$&gt; y\n\n  _&lt;&amp;&gt;_ : F A \u2192 (A \u2192 B) \u2192 F B\n  _&lt;&amp;&gt;_ = flip _&lt;$&gt;_\n\n  ignore : F A \u2192 F \u22a4\n  ignore = _ &lt;$_\n\n-- A functor morphism from F\u2081 to F\u2082 is an operation op such that\n-- op (F\u2081 f x) \u2261 F\u2082 f (op x)\n\nrecord Morphism {F\u2081 : Set \u2113 \u2192 Set \u2113\u2032} {F\u2082 : Set \u2113 \u2192 Set \u2113\u2033}\n                (fun\u2081 : RawFunctor F\u2081)\n                (fun\u2082 : RawFunctor F\u2082) : Set (suc \u2113 \u2294 \u2113\u2032 \u2294 \u2113\u2033) where\n  open RawFunctor\n  field\n    op     : F\u2081 X \u2192 F\u2082 X\n    op-&lt;$&gt; : (f : X \u2192 Y) (x : F\u2081 X) \u2192\n             op (fun\u2081 ._&lt;$&gt;_ f x) \u2261 fun\u2082 ._&lt;$&gt;_ f (op x)\n</pre>"},{"location":"md/Effect/Monad/","title":"Effect.Monad","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Monads\n------------------------------------------------------------------------\n\n-- Note that currently the monad laws are not included here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Monad where\n\nopen import Data.Bool.Base using (Bool; true; false; not)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Effect.Choice using (RawChoice)\nopen import Effect.Empty using (RawEmpty)\nopen import Effect.Applicative as App\n  using (RawApplicative; RawApplicativeZero; mkRawApplicative; RawAlternative)\nopen import Function.Base using (id; flip; _$\u2032_; _\u2218\u2032_)\nopen import Level using (Level; suc; _\u2294_)\n\nprivate\n  variable\n    f g g\u2081 g\u2082 : Level\n    A B C : Set f\n\n------------------------------------------------------------------------\n-- The type of raw monads\n\nrecord RawMonad (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  infixl 1 _&gt;&gt;=_ _&gt;&gt;_ _&gt;=&gt;_\n  infixr 1 _=&lt;&lt;_ _&lt;=&lt;_\n  field\n    rawApplicative : RawApplicative F\n    _&gt;&gt;=_ : F A \u2192 (A \u2192 F B) \u2192 F B\n\n  open RawApplicative rawApplicative public\n\n  _&gt;&gt;_ : F A \u2192 F B \u2192 F B\n  _&gt;&gt;_ = _*&gt;_\n\n  _=&lt;&lt;_ : (A \u2192 F B) \u2192 F A \u2192 F B\n  _=&lt;&lt;_ = flip _&gt;&gt;=_\n\n  Kleisli : Set f \u2192 Set f \u2192 Set (f \u2294 g)\n  Kleisli A B = A \u2192 F B\n\n  _&gt;=&gt;_ : Kleisli A B \u2192 Kleisli B C \u2192 Kleisli A C\n  (f &gt;=&gt; g) a = f a &gt;&gt;= g\n\n  _&lt;=&lt;_ : Kleisli B C \u2192 Kleisli A B \u2192 Kleisli A C\n  _&lt;=&lt;_ = flip _&gt;=&gt;_\n\n  when : Bool \u2192 F \u22a4 \u2192 F \u22a4\n  when true m = m\n  when false m = pure _\n\n  unless : Bool \u2192 F \u22a4 \u2192 F \u22a4\n  unless = when \u2218\u2032 not\n\n-- When level g=f, a join/\u03bc operator is definable\n\nmodule Join {F : Set f \u2192 Set f} (M : RawMonad F) where\n  open RawMonad M\n\n  join : F (F A) \u2192 F A\n  join = _&gt;&gt;= id\n\n-- Smart constructor\n\nmodule _ where\n\n  open RawMonad\n  open RawApplicative\n\n  mkRawMonad :\n    (F : Set f \u2192 Set g) \u2192\n    (pure : \u2200 {A} \u2192 A \u2192 F A) \u2192\n    (bind : \u2200 {A B} \u2192 F A \u2192 (A \u2192 F B) \u2192 F B) \u2192\n    RawMonad F\n  mkRawMonad F pure _&gt;&gt;=_ .rawApplicative =\n    mkRawApplicative _ pure $\u2032 \u03bb mf mx \u2192 do\n      f \u2190 mf\n      x \u2190 mx\n      pure (f x)\n  mkRawMonad F pure _&gt;&gt;=_ ._&gt;&gt;=_ = _&gt;&gt;=_\n\n------------------------------------------------------------------------\n-- The type of raw monads with a zero\n\nrecord RawMonadZero (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawMonad : RawMonad F\n    rawEmpty : RawEmpty F\n\n  open RawMonad rawMonad public\n  open RawEmpty rawEmpty public\n\n  rawApplicativeZero : RawApplicativeZero F\n  rawApplicativeZero = record\n    { rawApplicative = rawApplicative\n    ; rawEmpty = rawEmpty\n    }\n\n------------------------------------------------------------------------\n-- The type of raw monadplus\n\nrecord RawMonadPlus (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawMonadZero : RawMonadZero F\n    rawChoice    : RawChoice F\n\n  open RawMonadZero rawMonadZero public\n  open RawChoice rawChoice public\n\n  rawAlternative : RawAlternative F\n  rawAlternative = record\n    { rawApplicativeZero = rawApplicativeZero\n    ; rawChoice = rawChoice\n    }\n\n------------------------------------------------------------------------\n-- The type of raw monad transformer\n\n-- F has been RawMonadT'd as TF\nrecord RawMonadTd (F : Set f \u2192 Set g\u2081) (TF : Set f \u2192 Set g\u2082) : Set (suc f \u2294 g\u2081 \u2294 g\u2082) where\n  field\n    lift : F A \u2192 TF A\n    rawMonad : RawMonad TF\n\n  open RawMonad rawMonad public\n\nRawMonadT : (T : (Set f \u2192 Set g\u2081) \u2192 (Set f \u2192 Set g\u2082)) \u2192 Set (suc f \u2294 suc g\u2081 \u2294 g\u2082)\nRawMonadT T = \u2200 {M} \u2192 RawMonad M \u2192 RawMonadTd M (T M)\n</pre>"},{"location":"md/Function/","title":"Function","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Functions\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function where\n\nopen import Function.Core public\nopen import Function.Base public\nopen import Function.Strict public\nopen import Function.Definitions public\nopen import Function.Structures public\nopen import Function.Structures.Biased public\nopen import Function.Bundles public\n</pre>"},{"location":"md/Function/Base/","title":"Function.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Simple combinators working solely on and with functions\n------------------------------------------------------------------------\n\n-- The contents of this module is also accessible via the `Function`\n-- module. See `Function.Strict` for strict versions of these\n-- combinators.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Base where\n\nopen import Level using (Level)\n\nprivate\n  variable\n    a b c d e : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n\n------------------------------------------------------------------------\n-- Some simple functions\n\nid : A \u2192 A\nid x = x\n\nconst : A \u2192 B \u2192 A\nconst x = \u03bb _ \u2192 x\n\nconst\u1d63 : A \u2192 B \u2192 B\nconst\u1d63 _ = id\n\n------------------------------------------------------------------------\n-- Operations on dependent functions\n\n-- These are functions whose output has a type that depends on the\n-- value of the input to the function.\n\ninfixr 9 _\u2218_ _\u2218\u2082_\ninfixl 8 _\u02e2_\ninfixl 0 _|&gt;_\ninfix  0 case_returning_of_ case_return_of_\ninfixr -1 _$_\n\n-- Composition\n\n_\u2218_ : \u2200 {A : Set a} {B : A \u2192 Set b} {C : {x : A} \u2192 B x \u2192 Set c} \u2192\n      (\u2200 {x} (y : B x) \u2192 C y) \u2192 (g : (x : A) \u2192 B x) \u2192\n      ((x : A) \u2192 C (g x))\nf \u2218 g = \u03bb x \u2192 f (g x)\n{-# INLINE _\u2218_ #-}\n\n_\u2218\u2082_ : \u2200 {A\u2081 : Set a} {A\u2082 : A\u2081 \u2192 Set d}\n         {B : (x : A\u2081) \u2192 A\u2082 x \u2192 Set b}\n         {C : {x : A\u2081} \u2192 {y : A\u2082 x} \u2192 B x y \u2192 Set c} \u2192\n       ({x : A\u2081} \u2192 {y : A\u2082 x} \u2192 (z : B x y) \u2192 C z) \u2192\n       (g : (x : A\u2081) \u2192 (y : A\u2082 x) \u2192 B x y) \u2192\n       ((x : A\u2081) \u2192 (y : A\u2082 x) \u2192 C (g x y))\nf \u2218\u2082 g = \u03bb x y \u2192 f (g x y)\n\n-- Flipping order of arguments\n\nflip : \u2200 {A : Set a} {B : Set b} {C : A \u2192 B \u2192 Set c} \u2192\n       ((x : A) (y : B) \u2192 C x y) \u2192 ((y : B) (x : A) \u2192 C x y)\nflip f = \u03bb y x \u2192 f x y\n{-# INLINE flip #-}\n\n-- Application - note that _$_ is right associative, as in Haskell.\n-- If you want a left associative infix application operator, use\n-- RawFunctor._&lt;$&gt;_ from Effect.Functor.\n\n_$_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n      ((x : A) \u2192 B x) \u2192 ((x : A) \u2192 B x)\nf $ x = f x\n{-# INLINE _$_ #-}\n\n-- Flipped application (aka pipe-forward)\n\n_|&gt;_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       (a : A) \u2192 (\u2200 a \u2192 B a) \u2192 B a\n_|&gt;_ = flip _$_\n{-# INLINE _|&gt;_ #-}\n\n-- The S combinator - written infix as in Conor McBride's paper\n-- \"Outrageous but Meaningful Coincidences: Dependent type-safe syntax\n-- and evaluation\".\n\n_\u02e2_ : \u2200 {A : Set a} {B : A \u2192 Set b} {C : (x : A) \u2192 B x \u2192 Set c} \u2192\n      ((x : A) (y : B x) \u2192 C x y) \u2192\n      (g : (x : A) \u2192 B x) \u2192\n      ((x : A) \u2192 C x (g x))\nf \u02e2 g = \u03bb x \u2192 f x (g x)\n{-# INLINE _\u02e2_ #-}\n\n-- Converting between implicit and explicit function spaces.\n\n_$- : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192 ((x : A) \u2192 B x) \u2192 ({x : A} \u2192 B x)\nf $- = f _\n{-# INLINE _$- #-}\n\n\u03bb- : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192 ({x : A} \u2192 B x) \u2192 ((x : A) \u2192 B x)\n\u03bb- f = \u03bb x \u2192 f\n{-# INLINE \u03bb- #-}\n\n-- Case expressions (to be used with pattern-matching lambdas, see\n-- README.Case).\n\ncase_returning_of_ : \u2200 {A : Set a} (x : A) (B : A \u2192 Set b) \u2192\n                  ((x : A) \u2192 B x) \u2192 B x\ncase x returning B of f = f x\n{-# INLINE case_returning_of_ #-}\n\n------------------------------------------------------------------------\n-- Non-dependent versions of dependent operations\n\n-- Any of the above operations for dependent functions will also work\n-- for non-dependent functions but sometimes Agda has difficulty\n-- inferring the non-dependency. Primed (\u2032 = \\prime) versions of the\n-- operations are therefore provided below that sometimes have better\n-- inference properties.\n\ninfixr 9 _\u2218\u2032_ _\u2218\u2082\u2032_\ninfixl 0 _|&gt;\u2032_\ninfix  0 case_of_\ninfixr -1 _$\u2032_\n\n-- Composition\n\n_\u2218\u2032_ : (B \u2192 C) \u2192 (A \u2192 B) \u2192 (A \u2192 C)\nf \u2218\u2032 g = _\u2218_ f g\n\n_\u2218\u2082\u2032_ : (C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\nf \u2218\u2082\u2032 g = _\u2218\u2082_ f g\n\n-- Flipping order of arguments\n\nflip\u2032 : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\nflip\u2032 = flip\n\n-- Application\n\n_$\u2032_ : (A \u2192 B) \u2192 (A \u2192 B)\n_$\u2032_ = _$_\n\n-- Flipped application (aka pipe-forward)\n\n_|&gt;\u2032_ : A \u2192 (A \u2192 B) \u2192 B\n_|&gt;\u2032_ = _|&gt;_\n\n-- Case expressions (to be used with pattern-matching lambdas, see\n-- README.Case).\n\ncase_of_ : A \u2192 (A \u2192 B) \u2192 B\ncase x of f = case x returning _ of f\n{-# INLINE case_of_ #-}\n\n------------------------------------------------------------------------\n-- Operations that are only defined for non-dependent functions\n\ninfixl 1 _\u27e8_\u27e9_\ninfixl 0 _\u220b_\n\n-- Binary application\n\n_\u27e8_\u27e9_ : A \u2192 (A \u2192 B \u2192 C) \u2192 B \u2192 C\nx \u27e8 f \u27e9 y = f x y\n\n-- In Agda you cannot annotate every subexpression with a type\n-- signature. This function can be used instead.\n\n_\u220b_ : (A : Set a) \u2192 A \u2192 A\nA \u220b x = x\n\n-- Conversely it is sometimes useful to be able to extract the\n-- type of a given expression.\n\ntypeOf : {A : Set a} \u2192 A \u2192 Set a\ntypeOf {A = A} _ = A\n\n-- Construct an element of the given type by instance search.\n\nit : {A : Set a} \u2192 {{A}} \u2192 A\nit {{x}} = x\n\n------------------------------------------------------------------------\n-- Composition of a binary function with other functions\n\ninfixr 0 _-\u27ea_\u27eb-_ _-\u27e8_\u27eb-_\ninfixl 0 _-\u27ea_\u27e9-_\ninfixr 1 _-\u27e8_\u27e9-_ \u2223_\u27eb-_ \u2223_\u27e9-_\ninfixl 1 _on_ _on\u2082_ _-\u27ea_\u2223 _-\u27e8_\u2223\n\n-- Two binary functions\n\n_-\u27ea_\u27eb-_ : (A \u2192 B \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27ea _*_ \u27eb- g = \u03bb x y \u2192 f x y * g x y\n\n-- A single binary function on the left\n\n_-\u27ea_\u2223 : (A \u2192 B \u2192 C) \u2192 (C \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 D)\nf -\u27ea _*_ \u2223 = f -\u27ea _*_ \u27eb- const\u1d63\n\n-- A single binary function on the right\n\n\u2223_\u27eb-_ : (A \u2192 C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n\u2223 _*_ \u27eb- g = const -\u27ea _*_ \u27eb- g\n\n-- A single unary function on the left\n\n_-\u27e8_\u2223 : (A \u2192 C) \u2192 (C \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 D)\nf -\u27e8 _*_ \u2223 = f \u2218\u2082 const -\u27ea _*_ \u2223\n\n-- A single unary function on the right\n\n\u2223_\u27e9-_ : (A \u2192 C \u2192 D) \u2192 (B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n\u2223 _*_ \u27e9- g = \u2223 _*_ \u27eb- g \u2218\u2082 const\u1d63\n\n-- A binary function and a unary function\n\n_-\u27ea_\u27e9-_ : (A \u2192 B \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27ea _*_ \u27e9- g = f -\u27ea _*_ \u27eb- \u2223 const\u1d63 \u27e9- g\n\n-- A unary function and a binary function\n\n_-\u27e8_\u27eb-_ : (A \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27e8 _*_ \u27eb- g = f -\u27e8 const \u2223 -\u27ea _*_ \u27eb- g\n\n-- Two unary functions\n\n_-\u27e8_\u27e9-_ : (A \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27e8 _*_ \u27e9- g = f -\u27e8 const \u2223 -\u27ea _*_ \u27eb- \u2223 const\u1d63 \u27e9- g\n\n-- A single binary function on both sides\n\n_on\u2082_ : (C \u2192 C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n_*_ on\u2082 f = f -\u27ea _*_ \u27eb- f\n\n-- A single unary function on both sides\n\n_on_ : (B \u2192 B \u2192 C) \u2192 (A \u2192 B) \u2192 (A \u2192 A \u2192 C)\n_*_ on f = f -\u27e8 _*_ \u27e9- f\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.4\n\n_-[_]-_ = _-\u27ea_\u27eb-_\n{-# WARNING_ON_USAGE _-[_]-_\n\"Warning: Function._-[_]-_ was deprecated in v1.4.\nPlease use _-\u27ea_\u27eb-_ instead.\"\n#-}\n\n-- Version 2.0\n\ncase_return_of_ = case_returning_of_\n{-# WARNING_ON_USAGE case_return_of_\n\"case_return_of_ was deprecated in v2.0.\nPlease use case_returning_of_ instead.\"\n#-}\n\n</pre>"},{"location":"md/Function/Bundles/","title":"Function.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for types of functions\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n-- Note that these bundles differ from those found elsewhere in other\n-- library hierarchies as they take Setoids as parameters. This is\n-- because a function is of no use without knowing what its domain and\n-- codomain is, as well which equalities are being considered over them.\n-- One consequence of this is that they are not built from the\n-- definitions found in `Function.Structures` as is usually the case in\n-- other library hierarchies, as this would duplicate the equality\n-- axioms.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Bundles where\n\nopen import Function.Base using (_\u2218_)\nopen import Function.Definitions\nimport Function.Structures as FunctionStructures\nopen import Level using (Level; _\u2294_; suc)\nopen import Data.Product.Base using (_,_; proj\u2081; proj\u2082)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Core using (_Preserves_\u27f6_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nimport Relation.Binary.PropositionalEquality.Properties as \u2261\nopen import Function.Consequences.Propositional\nopen Setoid using (isEquivalence)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Setoid bundles\n------------------------------------------------------------------------\n\nmodule _ (From : Setoid a \u2113\u2081) (To : Setoid b \u2113\u2082) where\n\n  open Setoid From using () renaming (Carrier to A; _\u2248_ to _\u2248\u2081_)\n  open Setoid To   using () renaming (Carrier to B; _\u2248_ to _\u2248\u2082_)\n  open FunctionStructures _\u2248\u2081_ _\u2248\u2082_\n\n------------------------------------------------------------------------\n-- Bundles with one element\n\n  -- Called `Func` rather than `Function` in order to avoid clashing\n  -- with the top-level module.\n  record Func : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to   : A \u2192 B\n      cong : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    open IsCongruent isCongruent public\n      using (module Eq\u2081; module Eq\u2082)\n\n\n  record Injection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to          : A \u2192 B\n      cong        : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      injective   : Injective _\u2248\u2081_ _\u2248\u2082_ to\n\n    function : Func\n    function = record\n      { to   = to\n      ; cong = cong\n      }\n\n    open Func function public\n      hiding (to; cong)\n\n    isInjection : IsInjection to\n    isInjection = record\n      { isCongruent = isCongruent\n      ; injective   = injective\n      }\n\n\n  record Surjection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to         : A \u2192 B\n      cong       : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      surjective : Surjective _\u2248\u2081_ _\u2248\u2082_ to\n\n    function : Func\n    function = record\n      { to   = to\n      ; cong = cong\n      }\n\n    open Func function public\n      hiding (to; cong)\n\n    isSurjection : IsSurjection to\n    isSurjection = record\n      { isCongruent = isCongruent\n      ; surjective  = surjective\n      }\n\n    open IsSurjection isSurjection public\n      using\n      ( strictlySurjective\n      )\n\n    to\u207b : B \u2192 A\n    to\u207b = proj\u2081 \u2218 surjective\n\n    to\u2218to\u207b : \u2200 x \u2192 to (to\u207b x) \u2248\u2082 x\n    to\u2218to\u207b = proj\u2082 \u2218 strictlySurjective\n\n\n  record Bijection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      cong      : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      bijective : Bijective _\u2248\u2081_ _\u2248\u2082_ to\n\n    injective : Injective _\u2248\u2081_ _\u2248\u2082_ to\n    injective = proj\u2081 bijective\n\n    surjective : Surjective _\u2248\u2081_ _\u2248\u2082_ to\n    surjective = proj\u2082 bijective\n\n    injection : Injection\n    injection = record\n      { cong      = cong\n      ; injective = injective\n      }\n\n    surjection : Surjection\n    surjection = record\n      { cong       = cong\n      ; surjective = surjective\n      }\n\n    open Injection  injection  public using (isInjection)\n    open Surjection surjection public using (isSurjection; to\u207b;  strictlySurjective)\n\n    isBijection : IsBijection to\n    isBijection = record\n      { isInjection = isInjection\n      ; surjective  = surjective\n      }\n\n    open IsBijection isBijection public using (module Eq\u2081; module Eq\u2082)\n\n\n------------------------------------------------------------------------\n-- Bundles with two elements\n\nmodule _ (From : Setoid a \u2113\u2081) (To : Setoid b \u2113\u2082) where\n\n  open Setoid From using () renaming (Carrier to A; _\u2248_ to _\u2248\u2081_)\n  open Setoid To   using () renaming (Carrier to B; _\u2248_ to _\u2248\u2082_)\n  open FunctionStructures _\u2248\u2081_ _\u2248\u2082_\n\n  record Equivalence : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n\n    toFunction : Func From To\n    toFunction = record\n      { to = to\n      ; cong = to-cong\n      }\n\n    open Func toFunction public\n      using (module Eq\u2081; module Eq\u2082)\n      renaming (isCongruent to to-isCongruent)\n\n    fromFunction : Func To From\n    fromFunction = record\n      { to = from\n      ; cong = from-cong\n      }\n\n    open Func fromFunction public\n      using ()\n      renaming (isCongruent to from-isCongruent)\n\n\n  record LeftInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n      inverse\u02e1  : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isLeftInverse : IsLeftInverse to from\n    isLeftInverse = record\n      { isCongruent = isCongruent\n      ; from-cong   = from-cong\n      ; inverse\u02e1    = inverse\u02e1\n      }\n\n    open IsLeftInverse isLeftInverse public\n      using (module Eq\u2081; module Eq\u2082; strictlyInverse\u02e1; isSurjection)\n\n    equivalence : Equivalence\n    equivalence = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      }\n\n    isSplitSurjection : IsSplitSurjection to\n    isSplitSurjection = record\n      { from = from\n      ; isLeftInverse = isLeftInverse\n      }\n\n    surjection : Surjection From To\n    surjection = record\n      { to = to\n      ; cong = to-cong\n      ; surjective = \u03bb y \u2192 from y , inverse\u02e1\n      }\n\n\n\n  record RightInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : from Preserves _\u2248\u2082_ \u27f6 _\u2248\u2081_\n      inverse\u02b3  : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isRightInverse : IsRightInverse to from\n    isRightInverse = record\n      { isCongruent = isCongruent\n      ; from-cong   = from-cong\n      ; inverse\u02b3    = inverse\u02b3\n      }\n\n    open IsRightInverse isRightInverse public\n      using (module Eq\u2081; module Eq\u2082; strictlyInverse\u02b3)\n\n    equivalence : Equivalence\n    equivalence = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      }\n\n\n  record Inverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n      inverse   : Inverse\u1d47 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    inverse\u02e1 : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n    inverse\u02e1 = proj\u2081 inverse\n\n    inverse\u02b3 : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n    inverse\u02b3 = proj\u2082 inverse\n\n    leftInverse : LeftInverse\n    leftInverse = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      ; inverse\u02e1  = inverse\u02e1\n      }\n\n    rightInverse : RightInverse\n    rightInverse = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      ; inverse\u02b3  = inverse\u02b3\n      }\n\n    open LeftInverse leftInverse   public using (isLeftInverse; strictlyInverse\u02e1)\n    open RightInverse rightInverse public using (isRightInverse; strictlyInverse\u02b3)\n\n    isInverse : IsInverse to from\n    isInverse = record\n      { isLeftInverse = isLeftInverse\n      ; inverse\u02b3      = inverse\u02b3\n      }\n\n    open IsInverse isInverse public using (module Eq\u2081; module Eq\u2082)\n\n\n------------------------------------------------------------------------\n-- Bundles with three elements\n\n  record BiEquivalence : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to         : A \u2192 B\n      from\u2081      : B \u2192 A\n      from\u2082      : B \u2192 A\n      to-cong    : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from\u2081-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n      from\u2082-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n\n\n  record BiInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to          : A \u2192 B\n      from\u2081       : B \u2192 A\n      from\u2082       : B \u2192 A\n      to-cong     : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from\u2081-cong  : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n      from\u2082-cong  : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n      inverse\u02e1  : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\u2081\n      inverse\u02b3  : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\u2082\n\n    to-isCongruent : IsCongruent to\n    to-isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isBiInverse : IsBiInverse to from\u2081 from\u2082\n    isBiInverse = record\n      { to-isCongruent = to-isCongruent\n      ; from\u2081-cong     = from\u2081-cong\n      ; from\u2082-cong     = from\u2082-cong\n      ; inverse\u02e1       = inverse\u02e1\n      ; inverse\u02b3       = inverse\u02b3\n      }\n\n    biEquivalence : BiEquivalence\n    biEquivalence = record\n      { to-cong    = to-cong\n      ; from\u2081-cong = from\u2081-cong\n      ; from\u2082-cong = from\u2082-cong\n      }\n\n------------------------------------------------------------------------\n-- Other\n\n  -- A left inverse is also known as a \u201csplit surjection\u201d.\n  --\n  -- As the name implies, a split surjection is a special kind of\n  -- surjection where the witness generated in the domain in the\n  -- function for elements `x\u2081` and `x\u2082` are equal if `x\u2081 \u2248 x\u2082` .\n  --\n  -- The difference is the `from-cong` law --- generally, the section\n  -- (called `Surjection.to\u207b` or `SplitSurjection.from`) of a surjection\n  -- need not respect equality, whereas it must in a split surjection.\n  --\n  -- The two notions coincide when the equivalence relation on `B` is\n  -- propositional equality (because all functions respect propositional\n  -- equality).\n  --\n  -- For further background on (split) surjections, one may consult any\n  -- general mathematical references which work without the principle\n  -- of choice. For example:\n  --\n  --   https://ncatlab.org/nlab/show/split+epimorphism.\n  --\n  -- The connection to set-theoretic notions with the same names is\n  -- justified by the setoid type theory/homotopy type theory\n  -- observation/definition that (\u2203x : A. P) = \u2225 \u03a3x : A. P \u2225 --- i.e.,\n  -- we can read set-theoretic \u2203 as squashed/propositionally truncated \u03a3.\n  --\n  -- We see working with setoids as working in the MLTT model of a setoid\n  -- type theory, in which \u2225 X \u2225 is interpreted as the setoid with carrier\n  -- set X and the equivalence relation that relates all elements.\n  -- All maps into \u2225 X \u2225 respect equality, so in the idiomatic definitions\n  -- here, we drop the corresponding trivial `cong` field completely.\n\n  SplitSurjection : Set _\n  SplitSurjection = LeftInverse\n\n  module SplitSurjection (splitSurjection : SplitSurjection) =\n    LeftInverse splitSurjection\n\n------------------------------------------------------------------------\n-- Infix abbreviations for oft-used items\n------------------------------------------------------------------------\n\n-- Same naming convention as used for propositional equality below, with\n-- appended \u209b (for 'S'etoid).\n\ninfixr 0 _\u27f6\u209b_\n_\u27f6\u209b_ : Setoid a \u2113\u2081 \u2192 Setoid b \u2113\u2082 \u2192 Set _\n_\u27f6\u209b_ = Func\n\n------------------------------------------------------------------------\n-- Bundles specialised for propositional equality\n------------------------------------------------------------------------\n\ninfix 3 _\u27f6_ _\u21a3_ _\u21a0_ _\u2916_ _\u21d4_ _\u21a9_ _\u21aa_ _\u21a9\u21aa_ _\u2194_\n_\u27f6_ : Set a \u2192 Set b \u2192 Set _\nA \u27f6 B = Func (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a3_ : Set a \u2192 Set b \u2192 Set _\nA \u21a3 B = Injection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a0_ : Set a \u2192 Set b \u2192 Set _\nA \u21a0 B = Surjection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u2916_ : Set a \u2192 Set b \u2192 Set _\nA \u2916 B = Bijection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21d4_ : Set a \u2192 Set b \u2192 Set _\nA \u21d4 B = Equivalence (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a9_ : Set a \u2192 Set b \u2192 Set _\nA \u21a9 B = LeftInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21aa_ : Set a \u2192 Set b \u2192 Set _\nA \u21aa B = RightInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a9\u21aa_ : Set a \u2192 Set b \u2192 Set _\nA \u21a9\u21aa B = BiInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u2194_ : Set a \u2192 Set b \u2192 Set _\nA \u2194 B = Inverse (\u2261.setoid A) (\u2261.setoid B)\n\n-- We now define some constructors for the above that\n-- automatically provide the required congruency proofs.\n\nmodule _ {A : Set a} {B : Set b} where\n\n  mk\u27f6 : (A \u2192 B) \u2192 A \u27f6 B\n  mk\u27f6 to = record\n    { to        = to\n    ; cong      = \u2261.cong to\n    }\n\n  mk\u21a3 : \u2200 {to : A \u2192 B} \u2192 Injective _\u2261_ _\u2261_ to \u2192 A \u21a3 B\n  mk\u21a3 {to} inj = record\n    { to         = to\n    ; cong      = \u2261.cong to\n    ; injective = inj\n    }\n\n  mk\u21a0 : \u2200 {to : A \u2192 B} \u2192 Surjective _\u2261_ _\u2261_ to \u2192 A \u21a0 B\n  mk\u21a0 {to} surj = record\n    { to         = to\n    ; cong       = \u2261.cong to\n    ; surjective = surj\n    }\n\n  mk\u2916 : \u2200 {to : A \u2192 B} \u2192 Bijective _\u2261_ _\u2261_ to \u2192 A \u2916 B\n  mk\u2916 {to} bij = record\n    { to        = to\n    ; cong      = \u2261.cong to\n    ; bijective = bij\n    }\n\n  mk\u21d4 : \u2200 (to : A \u2192 B) (from : B \u2192 A) \u2192 A \u21d4 B\n  mk\u21d4 to from = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    }\n\n  mk\u21a9 : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u02e1 _\u2261_ _\u2261_ to from \u2192 A \u21a9 B\n  mk\u21a9 {to} {from} inv\u02e1 = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse\u02e1  = inv\u02e1\n    }\n\n  mk\u21aa : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u02b3 _\u2261_ _\u2261_ to from \u2192 A \u21aa B\n  mk\u21aa {to} {from} inv\u02b3 = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse\u02b3  = inv\u02b3\n    }\n\n  mk\u21a9\u21aa : \u2200 {to : A \u2192 B} {from\u2081 : B \u2192 A} {from\u2082 : B \u2192 A} \u2192\n         Inverse\u02e1 _\u2261_ _\u2261_ to from\u2081 \u2192 Inverse\u02b3 _\u2261_ _\u2261_ to from\u2082 \u2192 A \u21a9\u21aa B\n  mk\u21a9\u21aa {to} {from\u2081} {from\u2082} inv\u02e1 inv\u02b3 = record\n    { to         = to\n    ; from\u2081      = from\u2081\n    ; from\u2082      = from\u2082\n    ; to-cong    = \u2261.cong to\n    ; from\u2081-cong = \u2261.cong from\u2081\n    ; from\u2082-cong = \u2261.cong from\u2082\n    ; inverse\u02e1   = inv\u02e1\n    ; inverse\u02b3   = inv\u02b3\n    }\n\n  mk\u2194 : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u1d47 _\u2261_ _\u2261_ to from \u2192 A \u2194 B\n  mk\u2194 {to} {from} inv = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse   = inv\n    }\n\n\n  -- Strict variant of the above.\n  mk\u21a0\u209b : \u2200 {to : A \u2192 B} \u2192 StrictlySurjective _\u2261_ to \u2192 A \u21a0 B\n  mk\u21a0\u209b = mk\u21a0 \u2218 strictlySurjective\u21d2surjective\n\n  mk\u2194\u209b\u2032 : \u2200 (to : A \u2192 B) (from : B \u2192 A) \u2192\n          StrictlyInverse\u02e1 _\u2261_ to from \u2192\n          StrictlyInverse\u02b3 _\u2261_ to from \u2192\n          A \u2194 B\n  mk\u2194\u209b\u2032 to from inv\u02e1 inv\u02b3 = mk\u2194 {to} {from}\n    ( strictlyInverse\u02e1\u21d2inverse\u02e1 to inv\u02e1\n    , strictlyInverse\u02b3\u21d2inverse\u02b3 to inv\u02b3\n    )\n\n------------------------------------------------------------------------\n-- Other\n------------------------------------------------------------------------\n\n-- Alternative syntax for the application of functions\n\nmodule _ {From : Setoid a \u2113\u2081} {To : Setoid b \u2113\u2082} where\n  open Setoid\n\n  infixl 5 _\u27e8$\u27e9_\n  _\u27e8$\u27e9_ : Func From To \u2192 Carrier From \u2192 Carrier To\n  _\u27e8$\u27e9_ = Func.to\n</pre>"},{"location":"md/Function/Consequences/","title":"Function.Consequences","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions. See\n-- `Function.Consequences.Propositional` for specialisations to\n-- propositional equality.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Consequences where\n\nopen import Data.Product.Base as Product\nopen import Function.Definitions\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Definitions using (Reflexive; Symmetric; Transitive)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contraposition)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n    \u2248\u2081 \u2248\u2082 : Rel A \u2113\u2081\n    f f\u207b\u00b9 : A \u2192 B\n\n------------------------------------------------------------------------\n-- Injective\n\ncontraInjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192 Injective \u2248\u2081 \u2248\u2082 f \u2192\n                  \u2200 {x y} \u2192 \u00ac (\u2248\u2081 x y) \u2192 \u00ac (\u2248\u2082 (f x) (f y))\ncontraInjective _ inj p = contraposition inj p\n\n------------------------------------------------------------------------\n-- Inverse\u02e1\n\ninverse\u02e1\u21d2surjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                      Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                      Surjective \u2248\u2081 \u2248\u2082 f\ninverse\u02e1\u21d2surjective \u2248\u2082 inv\u02e1 y = (_ , inv\u02e1)\n\n------------------------------------------------------------------------\n-- Inverse\u02b3\n\ninverse\u02b3\u21d2injective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) f \u2192\n                     Reflexive \u2248\u2082 \u2192\n                     Symmetric \u2248\u2081 \u2192\n                     Transitive \u2248\u2081 \u2192\n                     Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                     Injective \u2248\u2081 \u2248\u2082 f\ninverse\u02b3\u21d2injective \u2248\u2082 f refl sym trans inv\u02b3 {x} {y} fx\u2248fy =\n  trans (sym (inv\u02b3 refl)) (inv\u02b3 fx\u2248fy)\n\n------------------------------------------------------------------------\n-- Inverse\u1d47\n\ninverse\u1d47\u21d2bijective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                     Reflexive \u2248\u2082 \u2192\n                     Symmetric \u2248\u2081 \u2192\n                     Transitive \u2248\u2081 \u2192\n                     Inverse\u1d47 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                     Bijective \u2248\u2081 \u2248\u2082 f\ninverse\u1d47\u21d2bijective {f = f} \u2248\u2082 refl sym trans (inv\u02e1 , inv\u02b3) =\n  (inverse\u02b3\u21d2injective \u2248\u2082 f refl sym trans inv\u02b3 , inverse\u02e1\u21d2surjective \u2248\u2082 inv\u02e1)\n\n------------------------------------------------------------------------\n-- StrictlySurjective\n\nsurjective\u21d2strictlySurjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                                 Reflexive \u2248\u2081 \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f\nsurjective\u21d2strictlySurjective _ refl surj x =\n  Product.map\u2082 (\u03bb v \u2192 v refl) (surj x)\n\nstrictlySurjective\u21d2surjective : Transitive \u2248\u2082 \u2192\n                                 Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f\nstrictlySurjective\u21d2surjective trans cong surj x =\n  Product.map\u2082 (\u03bb fy\u2248x z\u2248y \u2192 trans (cong z\u2248y) fy\u2248x) (surj x)\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02e1\n\ninverse\u02e1\u21d2strictlyInverse\u02e1 : \u2200 (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                            Reflexive \u2248\u2081 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9\ninverse\u02e1\u21d2strictlyInverse\u02e1 _ _ refl sinv x = sinv refl\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : Transitive \u2248\u2082 \u2192\n                            Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 trans cong sinv {x} y\u2248f\u207b\u00b9x =\n  trans (cong y\u2248f\u207b\u00b9x) (sinv x)\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02b3\n\ninverse\u02b3\u21d2strictlyInverse\u02b3 : \u2200 (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                            Reflexive \u2248\u2082 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9\ninverse\u02b3\u21d2strictlyInverse\u02b3 _ _ refl sinv x = sinv refl\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : Transitive \u2248\u2081 \u2192\n                            Congruent \u2248\u2082 \u2248\u2081 f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 trans cong sinv {x} y\u2248f\u207b\u00b9x =\n  trans (cong y\u2248f\u207b\u00b9x) (sinv x)\n</pre>"},{"location":"md/Function/Consequences/Propositional/","title":"Function.Consequences.Propositional","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions where the equality\n-- over both the domain and codomain is assumed to be _\u2261_\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Consequences.Propositional\n  {a b} {A : Set a} {B : Set b}\n  where\n\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; _\u2262_; cong)\nopen import Relation.Binary.PropositionalEquality.Properties\n  using (setoid)\nopen import Function.Definitions\n  using (StrictlySurjective; StrictlyInverse\u02e1; StrictlyInverse\u02b3; Inverse\u02e1\n        ; Inverse\u02b3; Surjective)\nopen import Relation.Nullary.Negation.Core using (contraposition)\n\nimport Function.Consequences.Setoid (setoid A) (setoid B) as Setoid\n\n------------------------------------------------------------------------\n-- Re-export setoid properties\n\nopen Setoid public\n  hiding\n  ( strictlySurjective\u21d2surjective\n  ; strictlyInverse\u02e1\u21d2inverse\u02e1\n  ; strictlyInverse\u02b3\u21d2inverse\u02b3\n  )\n\n------------------------------------------------------------------------\n-- Properties that rely on congruence\n\nprivate\n  variable\n    f : A \u2192 B\n    f\u207b\u00b9 : B \u2192 A\n\nstrictlySurjective\u21d2surjective : StrictlySurjective _\u2261_ f \u2192\n                                 Surjective _\u2261_ _\u2261_ f\nstrictlySurjective\u21d2surjective =\n Setoid.strictlySurjective\u21d2surjective (cong _)\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : \u2200 f \u2192 StrictlyInverse\u02e1 _\u2261_ f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 _\u2261_ _\u2261_ f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 f =\n  Setoid.strictlyInverse\u02e1\u21d2inverse\u02e1 (cong _)\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : \u2200 f \u2192 StrictlyInverse\u02b3 _\u2261_ f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 _\u2261_ _\u2261_ f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 f =\n  Setoid.strictlyInverse\u02b3\u21d2inverse\u02b3 (cong _)\n</pre>"},{"location":"md/Function/Consequences/Setoid/","title":"Function.Consequences.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions where the equality\n-- over both the domain and codomain are assumed to be setoids.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Setoid)\n\nmodule Function.Consequences.Setoid\n  {a b \u2113\u2081 \u2113\u2082}\n  (S : Setoid a \u2113\u2081)\n  (T : Setoid b \u2113\u2082)\n  where\n\nopen import Function.Definitions\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nimport Function.Consequences as C\n\nprivate\n  open module S = Setoid S using () renaming (Carrier to A; _\u2248_ to \u2248\u2081)\n  open module T = Setoid T using () renaming (Carrier to B; _\u2248_ to \u2248\u2082)\n\n  variable\n    f : A \u2192 B\n    f\u207b\u00b9 : B \u2192 A\n\n------------------------------------------------------------------------\n-- Injective\n\ncontraInjective : Injective \u2248\u2081 \u2248\u2082 f \u2192\n                  \u2200 {x y} \u2192 \u00ac (\u2248\u2081 x y) \u2192 \u00ac (\u2248\u2082 (f x) (f y))\ncontraInjective = C.contraInjective \u2248\u2082\n\n------------------------------------------------------------------------\n-- Inverse\u02e1\n\ninverse\u02e1\u21d2surjective : Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Surjective \u2248\u2081 \u2248\u2082 f\ninverse\u02e1\u21d2surjective = C.inverse\u02e1\u21d2surjective \u2248\u2082\n\n------------------------------------------------------------------------\n-- Inverse\u02b3\n\ninverse\u02b3\u21d2injective : \u2200 f \u2192 Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Injective \u2248\u2081 \u2248\u2082 f\ninverse\u02b3\u21d2injective f = C.inverse\u02b3\u21d2injective \u2248\u2082 f T.refl S.sym S.trans\n\n------------------------------------------------------------------------\n-- Inverse\u1d47\n\ninverse\u1d47\u21d2bijective : Inverse\u1d47 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Bijective \u2248\u2081 \u2248\u2082 f\ninverse\u1d47\u21d2bijective = C.inverse\u1d47\u21d2bijective \u2248\u2082 T.refl S.sym S.trans\n\n------------------------------------------------------------------------\n-- StrictlySurjective\n\nsurjective\u21d2strictlySurjective : Surjective \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f\nsurjective\u21d2strictlySurjective =\n  C.surjective\u21d2strictlySurjective \u2248\u2082 S.refl\n\nstrictlySurjective\u21d2surjective : Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f\nstrictlySurjective\u21d2surjective =\n  C.strictlySurjective\u21d2surjective T.trans\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02e1\n\ninverse\u02e1\u21d2strictlyInverse\u02e1 : Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9\ninverse\u02e1\u21d2strictlyInverse\u02e1 = C.inverse\u02e1\u21d2strictlyInverse\u02e1 \u2248\u2081 \u2248\u2082 S.refl\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 = C.strictlyInverse\u02e1\u21d2inverse\u02e1 T.trans\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02b3\n\ninverse\u02b3\u21d2strictlyInverse\u02b3 : Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9\ninverse\u02b3\u21d2strictlyInverse\u02b3 = C.inverse\u02b3\u21d2strictlyInverse\u02b3 \u2248\u2081 \u2248\u2082 T.refl\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : Congruent \u2248\u2082 \u2248\u2081 f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 = C.strictlyInverse\u02b3\u21d2inverse\u02b3 S.trans\n</pre>"},{"location":"md/Function/Core/","title":"Function.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core definitions for Functions\n------------------------------------------------------------------------\n\n-- The contents of this file should always be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Core where\n\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Types\n\nFun\u2081 : \u2200 {a} \u2192 Set a \u2192 Set a\nFun\u2081 A = A \u2192 A\n\nFun\u2082 : \u2200 {a} \u2192 Set a \u2192 Set a\nFun\u2082 A = A \u2192 A \u2192 A\n\n------------------------------------------------------------------------\n-- Morphism\n\nMorphism : \u2200 {a} \u2192 \u2200 {b} \u2192 Set a \u2192 Set b \u2192 Set (a \u2294 b)\nMorphism A B = A \u2192 B\n</pre>"},{"location":"md/Function/Definitions/","title":"Function.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions for types of functions.\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Definitions where\n\nopen import Data.Product.Base using (\u2203; _\u00d7_)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Basic definitions\n\nmodule _\n  (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\n  Congruent : (A \u2192 B) \u2192 Set _\n  Congruent f = \u2200 {x y} \u2192 x \u2248\u2081 y \u2192 f x \u2248\u2082 f y\n\n  Injective : (A \u2192 B) \u2192 Set _\n  Injective f = \u2200 {x y} \u2192 f x \u2248\u2082 f y \u2192 x \u2248\u2081 y\n\n  Surjective : (A \u2192 B) \u2192 Set _\n  Surjective f = \u2200 y \u2192 \u2203 \u03bb x \u2192 \u2200 {z} \u2192 z \u2248\u2081 x \u2192 f z \u2248\u2082 y\n\n  Bijective : (A \u2192 B) \u2192 Set _\n  Bijective f = Injective f \u00d7 Surjective f\n\n  Inverse\u02e1 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u02e1 f g = \u2200 {x y} \u2192 y \u2248\u2081 g x \u2192 f y \u2248\u2082 x\n\n  Inverse\u02b3 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u02b3 f g = \u2200 {x y} \u2192 y \u2248\u2082 f x \u2192 g y \u2248\u2081 x\n\n  Inverse\u1d47 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u1d47 f g = Inverse\u02e1 f g \u00d7 Inverse\u02b3 f g\n\n------------------------------------------------------------------------\n-- Strict definitions\n\n-- These are often easier to use once but much harder to compose and\n-- reason about.\n\nStrictlySurjective : Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nStrictlySurjective _\u2248\u2082_ f = \u2200 y \u2192 \u2203 \u03bb x \u2192 f x \u2248\u2082 y\n\nStrictlyInverse\u02e1 : Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nStrictlyInverse\u02e1 _\u2248\u2082_ f g = \u2200 y \u2192 f (g y) \u2248\u2082 y\n\nStrictlyInverse\u02b3 : Rel A \u2113\u2081 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nStrictlyInverse\u02b3 _\u2248\u2081_ f g = \u2200 x \u2192 g (f x) \u2248\u2081 x\n</pre>"},{"location":"md/Function/Dependent/Bundles/","title":"Function.Dependent.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for types of functions\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n-- Note that these bundles differ from those found elsewhere in other\n-- library hierarchies as they take Setoids as parameters. This is\n-- because a function is of no use without knowing what its domain and\n-- codomain is, as well which equalities are being considered over them.\n-- One consequence of this is that they are not built from the\n-- definitions found in `Function.Structures` as is usually the case in\n-- other library hierarchies, as this would duplicate the equality\n-- axioms.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Dependent.Bundles where\n\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Indexed.Heterogeneous using (IndexedSetoid)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Setoid bundles\n------------------------------------------------------------------------\n\nmodule _\n  (From : Setoid a \u2113\u2081)\n  (To : IndexedSetoid (Setoid.Carrier From) b \u2113\u2082)\n  where\n\n  open Setoid From using () renaming (Carrier to A; _\u2248_ to _\u2248\u2081_)\n  open IndexedSetoid To using () renaming (Carrier to B; _\u2248_ to _\u2248\u2082_)\n\n------------------------------------------------------------------------\n-- Bundles with one element\n\n  -- Called `Func` rather than `Function` in order to avoid clashing\n  -- with the top-level module.\n  record Func : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to   : (x : A) \u2192 B x\n      cong : \u2200 {x y} \u2192 x \u2248\u2081 y \u2192 to x \u2248\u2082 to y\n</pre>"},{"location":"md/Function/Indexed/Relation/Binary/Equality/","title":"Function.Indexed.Relation.Binary.Equality","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Function setoids and related constructions\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Indexed.Relation.Binary.Equality where\n\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Indexed.Heterogeneous using (IndexedSetoid)\n\n-- A variant of setoid which uses the propositional equality setoid\n-- for the domain, and a more convenient definition of _\u2248_.\n\n\u2261-setoid : \u2200 {f t\u2081 t\u2082} (From : Set f) \u2192 IndexedSetoid From t\u2081 t\u2082 \u2192 Setoid _ _\n\u2261-setoid From To = record\n  { Carrier       = (x : From) \u2192 Carrier x\n  ; _\u2248_           = \u03bb f g \u2192 \u2200 x \u2192 f x \u2248 g x\n  ; isEquivalence = record\n    { refl  = \u03bb {f} x \u2192 refl\n    ; sym   = \u03bb f\u223cg x \u2192 sym (f\u223cg x)\n    ; trans = \u03bb f\u223cg g\u223ch x \u2192 trans (f\u223cg x) (g\u223ch x)\n    }\n  } where open IndexedSetoid To\n\n</pre>"},{"location":"md/Function/Metric/Bundles/","title":"Function.Metric.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for metrics\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Function.Metric`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Bundles  where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\n\nopen import Function.Metric.Structures\nopen import Function.Metric.Core\n\n------------------------------------------------------------------------\n-- ProtoMetric\n\nrecord ProtoMetric (a i \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level)\n                 : Set (suc (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083)) where\n  infix 4 _\u2248_ _\u2248\u1d62_ _\u2264_\n  field\n    Carrier       : Set a\n    Image         : Set i\n    _\u2248_           : Rel Carrier \u2113\u2081\n    _\u2248\u1d62_          : Rel Image \u2113\u2082\n    _\u2264_           : Rel Image \u2113\u2083\n    0#            : Image\n    d             : DistanceFunction Carrier Image\n    isProtoMetric : IsProtoMetric _\u2248_ _\u2248\u1d62_ _\u2264_ 0# d\n\n  open IsProtoMetric isProtoMetric public\n\n------------------------------------------------------------------------\n-- PreMetric\n\nrecord PreMetric (a i \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level)\n               : Set (suc (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083)) where\n  infix 4 _\u2248_ _\u2248\u1d62_ _\u2264_\n  field\n    Carrier     : Set a\n    Image       : Set i\n    _\u2248_         : Rel Carrier \u2113\u2081\n    _\u2248\u1d62_        : Rel Image \u2113\u2082\n    _\u2264_         : Rel Image \u2113\u2083\n    0#          : Image\n    d           : DistanceFunction Carrier Image\n    isPreMetric : IsPreMetric _\u2248_ _\u2248\u1d62_ _\u2264_ 0# d\n\n  open IsPreMetric isPreMetric public\n\n  protoMetric : ProtoMetric a i \u2113\u2081 \u2113\u2082 \u2113\u2083\n  protoMetric = record\n    { isProtoMetric = isProtoMetric\n    }\n\n------------------------------------------------------------------------\n-- QuasiSemiMetric\n\nrecord QuasiSemiMetric (a i \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level)\n                     : Set (suc (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083)) where\n\n  infix 4 _\u2248_ _\u2248\u1d62_ _\u2264_\n  field\n    Carrier           : Set a\n    Image             : Set i\n    _\u2248_               : Rel Carrier \u2113\u2081\n    _\u2248\u1d62_              : Rel Image \u2113\u2082\n    _\u2264_               : Rel Image \u2113\u2083\n    0#                : Image\n    d                 : DistanceFunction Carrier Image\n    isQuasiSemiMetric : IsQuasiSemiMetric _\u2248_ _\u2248\u1d62_ _\u2264_ 0# d\n\n  open IsQuasiSemiMetric isQuasiSemiMetric public\n\n  preMetric : PreMetric a i \u2113\u2081 \u2113\u2082 \u2113\u2083\n  preMetric = record\n    { isPreMetric = isPreMetric\n    }\n\n  open PreMetric preMetric public\n    using (protoMetric)\n\n------------------------------------------------------------------------\n-- SemiMetric\n\nrecord SemiMetric (a i \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level)\n                : Set (suc (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083)) where\n  infix 4 _\u2248_ _\u2248\u1d62_ _\u2264_\n  field\n    Carrier      : Set a\n    Image        : Set i\n    _\u2248_          : Rel Carrier \u2113\u2081\n    _\u2248\u1d62_         : Rel Image \u2113\u2082\n    _\u2264_          : Rel Image \u2113\u2083\n    0#           : Image\n    d            : DistanceFunction Carrier Image\n    isSemiMetric : IsSemiMetric _\u2248_ _\u2248\u1d62_ _\u2264_ 0# d\n\n  open IsSemiMetric isSemiMetric public\n\n  quasiSemiMetric : QuasiSemiMetric a i \u2113\u2081 \u2113\u2082 \u2113\u2083\n  quasiSemiMetric = record\n    { isQuasiSemiMetric = isQuasiSemiMetric\n    }\n\n  open QuasiSemiMetric quasiSemiMetric public\n    using (protoMetric; preMetric)\n\n------------------------------------------------------------------------\n-- GeneralMetric\n\n-- Note that this package is not necessarily a metric in the classical\n-- sense as there is no way to ensure that the _\u2219_ operator really\n-- represents addition. See `Function.Metric.Nat` and\n-- `Function.Metric.Rational` for more specialised `Metric` and\n-- `UltraMetric` packages.\n\n-- See the discussion accompanying the `IsGeneralMetric` structure for\n-- more details.\n\nrecord GeneralMetric (a i \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level)\n                   : Set (suc (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083)) where\n  infix 4 _\u2248_ _\u2248\u1d62_ _\u2264_\n  infixl 6 _\u2219_\n  field\n    Carrier         : Set a\n    Image           : Set i\n    _\u2248_             : Rel Carrier \u2113\u2081\n    _\u2248\u1d62_            : Rel Image \u2113\u2082\n    _\u2264_             : Rel Image \u2113\u2083\n    0#              : Image\n    _\u2219_             : Op\u2082 Image\n    d               : DistanceFunction Carrier Image\n    isGeneralMetric : IsGeneralMetric _\u2248_ _\u2248\u1d62_ _\u2264_ 0# _\u2219_ d\n\n  open IsGeneralMetric isGeneralMetric public\n\n  semiMetric : SemiMetric a i \u2113\u2081 \u2113\u2082 \u2113\u2083\n  semiMetric = record\n    { isSemiMetric = isSemiMetric\n    }\n\n  open SemiMetric semiMetric public\n    using (protoMetric; preMetric; quasiSemiMetric)\n</pre>"},{"location":"md/Function/Metric/Core/","title":"Function.Metric.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core metric definitions\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Core where\n\nopen import Level using (Level)\nprivate\n  variable\n    a i : Level\n\n------------------------------------------------------------------------\n-- Distance functions\n\nDistanceFunction : Set a \u2192 Set i \u2192 Set _\nDistanceFunction A I = A \u2192 A \u2192 I\n</pre>"},{"location":"md/Function/Metric/Definitions/","title":"Function.Metric.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of properties over distance functions\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Function.Metric`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Definitions where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Data.Product.Base using (\u2203)\nopen import Function.Metric.Core using (DistanceFunction)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel; _Preserves\u2082_\u27f6_\u27f6_)\nopen import Relation.Nullary.Negation using (\u00ac_)\n\nprivate\n  variable\n    a i \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    I : Set i\n\n------------------------------------------------------------------------\n-- Properties\n\nCongruent : Rel A \u2113\u2081 \u2192 Rel I \u2113\u2082 \u2192 DistanceFunction A I \u2192 Set _\nCongruent _\u2248\u2090_ _\u2248\u1d62_ d = d Preserves\u2082 _\u2248\u2090_ \u27f6 _\u2248\u2090_ \u27f6 _\u2248\u1d62_\n\nIndiscernable : Rel A \u2113\u2081 \u2192 Rel I \u2113\u2082 \u2192 DistanceFunction A I \u2192 I \u2192 Set _\nIndiscernable _\u2248\u2090_ _\u2248\u1d62_ d 0# = \u2200 {x y} \u2192 d x y \u2248\u1d62 0# \u2192 x \u2248\u2090 y\n\nDefinite : Rel A \u2113\u2081 \u2192 Rel I \u2113\u2082 \u2192 DistanceFunction A I \u2192 I \u2192 Set _\nDefinite _\u2248\u2090_ _\u2248\u1d62_ d 0# = \u2200 {x y} \u2192 x \u2248\u2090 y \u2192 d x y \u2248\u1d62 0#\n\nNonNegative : Rel I \u2113\u2082 \u2192 DistanceFunction A I \u2192 I \u2192 Set _\nNonNegative _\u2264_ d 0# = \u2200 {x y} \u2192 0# \u2264 d x y\n\nSymmetric : Rel I \u2113 \u2192 DistanceFunction A I \u2192 Set _\nSymmetric _\u2248_ d = \u2200 x y \u2192 d x y \u2248 d y x\n\nTriangleInequality : Rel I \u2113 \u2192 Op\u2082 I \u2192 DistanceFunction A I \u2192 _\nTriangleInequality _\u2264_ _\u2219_ d = \u2200 x y z \u2192 d x z \u2264 (d x y \u2219 d y z)\n\nBounded : Rel I \u2113 \u2192 DistanceFunction A I \u2192 Set _\nBounded _\u2264_ d = \u2203 \u03bb n \u2192 \u2200 x y \u2192 d x y \u2264 n\n\nTranslationInvariant : Rel I \u2113\u2082 \u2192 Op\u2082 A \u2192 DistanceFunction A I \u2192 Set _\nTranslationInvariant _\u2248_ _\u2219_ d = \u2200 {x y a} \u2192 d (x \u2219 a) (y \u2219 a) \u2248 d x y\n\nContracting : Rel I \u2113 \u2192 (A \u2192 A) \u2192 DistanceFunction A I \u2192 Set _\nContracting _\u2264_ f d = \u2200 x y \u2192 d (f x) (f y) \u2264 d x y\n\nContractingOnOrbits : Rel I \u2113 \u2192 (A \u2192 A) \u2192 DistanceFunction A I \u2192 Set _\nContractingOnOrbits _\u2264_ f d = \u2200 x \u2192 d (f x) (f (f x)) \u2264 d x (f x)\n\nStrictlyContracting : Rel A \u2113\u2081 \u2192 Rel I \u2113\u2082 \u2192 (A \u2192 A) \u2192 DistanceFunction A I \u2192 Set _\nStrictlyContracting _\u2248_ _&lt;_ f d = \u2200 {x y} \u2192 \u00ac (y \u2248 x) \u2192 d (f x) (f y) &lt; d x y\n\nStrictlyContractingOnOrbits : Rel A \u2113\u2081 \u2192 Rel I \u2113\u2082 \u2192 (A \u2192 A) \u2192 DistanceFunction A I \u2192 Set _\nStrictlyContractingOnOrbits _\u2248_ _&lt;_ f d = \u2200 {x} \u2192 \u00ac (f x \u2248 x) \u2192 d (f x) (f (f x)) &lt; d x (f x)\n</pre>"},{"location":"md/Function/Metric/Nat/","title":"Function.Metric.Nat","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Metrics with \u2115 as the codomain of the metric function\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Nat where\n\nopen import Function.Metric.Nat.Core public\nopen import Function.Metric.Nat.Definitions public\nopen import Function.Metric.Nat.Structures public\nopen import Function.Metric.Nat.Bundles public\n</pre>"},{"location":"md/Function/Metric/Nat/Bundles/","title":"Function.Metric.Nat.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for metrics over \u2115\n------------------------------------------------------------------------\n\n-- Unfortunately, unlike definitions and structures, the bundles over\n-- general metric spaces cannot be reused as it is impossible to\n-- constrain the image set to \u2115.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Nat.Bundles where\n\nopen import Data.Nat.Base hiding (suc; _\u2294_)\nopen import Function.Base using (const)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Relation.Binary.PropositionalEquality.Properties\n  using (isEquivalence)\nopen import Function.Metric.Nat.Core using (DistanceFunction)\nopen import Function.Metric.Nat.Structures\n  using (IsProtoMetric; IsPreMetric; IsQuasiSemiMetric; IsSemiMetric\n        ; IsMetric; IsUltraMetric)\nopen import Function.Metric.Bundles as Base using (GeneralMetric)\n\n------------------------------------------------------------------------\n-- Proto-metric\n\nrecord ProtoMetric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier       : Set a\n    _\u2248_           : Rel Carrier \u2113\n    d             : DistanceFunction Carrier\n    isProtoMetric : IsProtoMetric _\u2248_ d\n\n  open IsProtoMetric isProtoMetric public\n\n------------------------------------------------------------------------\n-- PreMetric\n\nrecord PreMetric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier     : Set a\n    _\u2248_         : Rel Carrier \u2113\n    d           : DistanceFunction Carrier\n    isPreMetric : IsPreMetric _\u2248_ d\n\n  open IsPreMetric isPreMetric public\n\n  protoMetric : ProtoMetric a \u2113\n  protoMetric = record\n    { isProtoMetric = isProtoMetric\n    }\n\n------------------------------------------------------------------------\n-- QuasiSemiMetric\n\nrecord QuasiSemiMetric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier           : Set a\n    _\u2248_               : Rel Carrier \u2113\n    d                 : DistanceFunction Carrier\n    isQuasiSemiMetric : IsQuasiSemiMetric _\u2248_ d\n\n  open IsQuasiSemiMetric isQuasiSemiMetric public\n\n  preMetric : PreMetric a \u2113\n  preMetric = record\n    { isPreMetric = isPreMetric\n    }\n\n  open PreMetric preMetric public\n    using (protoMetric)\n\n------------------------------------------------------------------------\n-- SemiMetric\n\nrecord SemiMetric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier      : Set a\n    _\u2248_          : Rel Carrier \u2113\n    d            : DistanceFunction Carrier\n    isSemiMetric : IsSemiMetric _\u2248_ d\n\n  open IsSemiMetric isSemiMetric public\n\n  quasiSemiMetric : QuasiSemiMetric a \u2113\n  quasiSemiMetric = record\n    { isQuasiSemiMetric = isQuasiSemiMetric\n    }\n\n  open QuasiSemiMetric quasiSemiMetric public\n    using (protoMetric; preMetric)\n\n------------------------------------------------------------------------\n-- Metrics\n\nrecord Metric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier  : Set a\n    _\u2248_      : Rel Carrier \u2113\n    d        : DistanceFunction Carrier\n    isMetric : IsMetric _\u2248_ d\n\n  open IsMetric isMetric public\n\n  semiMetric : SemiMetric a \u2113\n  semiMetric = record\n    { isSemiMetric = isSemiMetric\n    }\n\n  open SemiMetric semiMetric public\n    using (protoMetric; preMetric; quasiSemiMetric)\n\n------------------------------------------------------------------------\n-- UltraMetrics\n\nrecord UltraMetric a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier       : Set a\n    _\u2248_           : Rel Carrier \u2113\n    d             : DistanceFunction Carrier\n    isUltraMetric : IsUltraMetric _\u2248_ d\n\n  open IsUltraMetric isUltraMetric public\n\n  semiMetric : SemiMetric a \u2113\n  semiMetric = record\n    { isSemiMetric = isSemiMetric\n    }\n\n  open SemiMetric semiMetric public\n    using (protoMetric; preMetric; quasiSemiMetric)\n</pre>"},{"location":"md/Function/Metric/Nat/Core/","title":"Function.Metric.Nat.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core definitions for metrics over \u2115\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Nat.Core where\n\nopen import Data.Nat.Base using (\u2115)\nimport Function.Metric.Core as Base using (DistanceFunction)\n\n------------------------------------------------------------------------\n-- Definition\n\nDistanceFunction : \u2200 {a} \u2192 Set a \u2192 Set a\nDistanceFunction A = Base.DistanceFunction A \u2115\n</pre>"},{"location":"md/Function/Metric/Nat/Definitions/","title":"Function.Metric.Nat.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core definitions for metrics over \u2115\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Nat.Definitions where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Data.Nat.Base using (\u2115; _\u2264_; _+_; _\u2294_ ; _&lt;_)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\nopen import Function.Metric.Nat.Core\nimport Function.Metric.Definitions as Base\n\nprivate\n  variable\n    a \u2113 : Level\n    A   : Set a\n\n------------------------------------------------------------------------\n-- Properties\n\n-- Basic\n\nCongruent : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nCongruent _\u2248\u2090_ d = Base.Congruent _\u2248\u2090_ _\u2261_ d\n\nIndiscernable : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIndiscernable _\u2248\u2090_ d = Base.Indiscernable _\u2248\u2090_ _\u2261_ d 0\n\nDefinite : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nDefinite _\u2248\u2090_ d = Base.Definite _\u2248\u2090_ _\u2261_ d 0\n\nSymmetric : DistanceFunction A \u2192 Set _\nSymmetric = Base.Symmetric _\u2261_\n\nBounded : DistanceFunction A \u2192 Set _\nBounded = Base.Bounded _\u2264_\n\nTranslationInvariant : Op\u2082 A \u2192 DistanceFunction A \u2192 Set _\nTranslationInvariant = Base.TranslationInvariant _\u2261_\n\n-- Inequalities\n\nTriangleInequality : DistanceFunction A \u2192 Set _\nTriangleInequality = Base.TriangleInequality _\u2264_ _+_\n\nMaxTriangleInequality : DistanceFunction A \u2192 Set _\nMaxTriangleInequality = Base.TriangleInequality _\u2264_ _\u2294_\n\n-- Contractions\n\nContracting : (A \u2192 A) \u2192 DistanceFunction A \u2192 Set _\nContracting = Base.Contracting _\u2264_\n\nContractingOnOrbits : (A \u2192 A) \u2192 DistanceFunction A \u2192 Set _\nContractingOnOrbits = Base.ContractingOnOrbits _\u2264_\n\nStrictlyContracting : Rel A \u2113 \u2192 (A \u2192 A) \u2192 DistanceFunction A \u2192 Set _\nStrictlyContracting _\u2248_ = Base.StrictlyContracting _\u2248_ _&lt;_\n\nStrictlyContractingOnOrbits : Rel A \u2113 \u2192 (A \u2192 A) \u2192 DistanceFunction A \u2192 Set _\nStrictlyContractingOnOrbits _\u2248_ = Base.StrictlyContractingOnOrbits _\u2248_ _&lt;_\n</pre>"},{"location":"md/Function/Metric/Nat/Structures/","title":"Function.Metric.Nat.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core definitions for metrics over \u2115\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Metric.Nat.Structures where\n\nopen import Data.Nat.Base hiding (suc)\nopen import Function.Base using (const)\nopen import Level using (Level; suc)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Function.Metric.Nat.Core using (DistanceFunction)\nimport Function.Metric.Structures as Base\n  using (IsGeneralMetric; IsProtoMetric; IsPreMetric; IsQuasiSemiMetric\n        ; IsSemiMetric)\n\nprivate\n  variable\n    a \u2113 : Level\n    A   : Set a\n\n------------------------------------------------------------------------\n-- Proto-metrics\n\nIsProtoMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsProtoMetric _\u2248_ = Base.IsProtoMetric _\u2248_ _\u2261_ _\u2264_ 0\n\nopen Base using (module IsProtoMetric) public\n\n------------------------------------------------------------------------\n-- Pre-metrics\n\nIsPreMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsPreMetric _\u2248_ = Base.IsPreMetric _\u2248_ _\u2261_ _\u2264_ 0\n\nopen Base using (module IsPreMetric) public\n\n------------------------------------------------------------------------\n-- Quasi-semi-metrics\n\nIsQuasiSemiMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsQuasiSemiMetric _\u2248_ = Base.IsQuasiSemiMetric _\u2248_ _\u2261_ _\u2264_ 0\n\nopen Base using (module IsQuasiSemiMetric) public\n\n------------------------------------------------------------------------\n-- Semi-metrics\n\nIsSemiMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsSemiMetric _\u2248_ = Base.IsSemiMetric _\u2248_ _\u2261_ _\u2264_ 0\n\nopen Base using (module IsSemiMetric) public\n\n------------------------------------------------------------------------\n-- Metrics\n\nIsMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsMetric _\u2248_ = Base.IsGeneralMetric _\u2248_ _\u2261_ _\u2264_ 0 _+_\n\nmodule IsMetric {_\u2248_ : Rel A \u2113} {d : DistanceFunction A}\n                (M : IsMetric _\u2248_ d) where\n  open Base.IsGeneralMetric M public\n\n------------------------------------------------------------------------\n-- Ultra-metrics\n\nIsUltraMetric : Rel A \u2113 \u2192 DistanceFunction A \u2192 Set _\nIsUltraMetric _\u2248_ = Base.IsGeneralMetric _\u2248_ _\u2261_ _\u2264_ 0 _\u2294_\n\nmodule IsUltraMetric {_\u2248_ : Rel A \u2113} {d : DistanceFunction A}\n                     (UM : IsUltraMetric _\u2248_ d) where\n  open Base.IsGeneralMetric UM public\n</pre>"},{"location":"md/Function/Metric/Structures/","title":"Function.Metric.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some metric structures (not packed up with sets, operations, etc.)\n------------------------------------------------------------------------\n\n-- The contents of this module should usually be accessed via\n-- `Function.Metric`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Structures using (IsPartialOrder; IsEquivalence)\n\nmodule Function.Metric.Structures\n  {a i \u2113\u2081 \u2113\u2082 \u2113\u2083} {A : Set a} {I : Set i}\n  (_\u2248\u2090_ : Rel A \u2113\u2081) (_\u2248\u1d62_ : Rel I \u2113\u2082) (_\u2264_ : Rel I \u2113\u2083) (0# : I) where\n\nopen import Algebra.Core using (Op\u2082)\nopen import Function.Metric.Core\nopen import Function.Metric.Definitions\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Proto-metrics\n\n-- We do not insist that the ordering relation is total as otherwise\n-- we would exclude the real numbers.\n\nrecord IsProtoMetric (d : DistanceFunction A I)\n                   : Set (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  field\n    isPartialOrder   : IsPartialOrder _\u2248\u1d62_ _\u2264_\n    \u2248-isEquivalence  : IsEquivalence _\u2248\u2090_\n    cong             : Congruent _\u2248\u2090_ _\u2248\u1d62_ d\n    nonNegative      : NonNegative _\u2264_ d 0#\n\n  open IsPartialOrder isPartialOrder public\n    renaming (module Eq to EqI)\n\n  module EqC = IsEquivalence \u2248-isEquivalence\n\n------------------------------------------------------------------------\n-- Pre-metrics\n\nrecord IsPreMetric (d : DistanceFunction A I)\n                 : Set (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  field\n    isProtoMetric : IsProtoMetric d\n    \u2248\u21d20           : Definite _\u2248\u2090_ _\u2248\u1d62_ d 0#\n\n  open IsProtoMetric isProtoMetric public\n\n------------------------------------------------------------------------\n-- Quasi-semi-metrics\n\nrecord IsQuasiSemiMetric (d : DistanceFunction A I)\n                       : Set (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  field\n    isPreMetric : IsPreMetric d\n    0\u21d2\u2248         : Indiscernable _\u2248\u2090_ _\u2248\u1d62_ d 0#\n\n  open IsPreMetric isPreMetric public\n\n------------------------------------------------------------------------\n-- Semi-metrics\n\nrecord IsSemiMetric (d : DistanceFunction A I)\n                  : Set (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  field\n    isQuasiSemiMetric : IsQuasiSemiMetric d\n    sym               : Symmetric _\u2248\u1d62_ d\n\n  open IsQuasiSemiMetric isQuasiSemiMetric public\n\n------------------------------------------------------------------------\n-- General metrics\n\n-- A general metric obeys a generalised form of the triangle inequality.\n-- It can be specialised to a standard metric/ultrametric/inframetric\n-- etc. by providing the correct operator.\n--\n-- Furthermore we do not assume that _\u2219_ &amp; 0# form a monoid as\n-- associativity does not hold for p-relaxed metrics/p-inframetrics and\n-- the identity laws do not hold for ultrametrics over negative\n-- codomains.\n--\n-- See \"Properties of distance spaces with power triangle inequalities\"\n-- by Daniel J. Greenhoe, 2016 (arXiv)\n\nrecord IsGeneralMetric (_\u2219_ : Op\u2082 I) (d : DistanceFunction A I)\n                     : Set (a \u2294 i \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  field\n    isSemiMetric : IsSemiMetric d\n    triangle     : TriangleInequality _\u2264_ _\u2219_ d\n\n  open IsSemiMetric isSemiMetric public\n</pre>"},{"location":"md/Function/Strict/","title":"Function.Strict","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Strict combinators (i.e. that use call-by-value)\n------------------------------------------------------------------------\n\n-- The contents of this module is also accessible via the `Function`\n-- module.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Strict where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Function.Base using (flip)\nopen import Level using (Level)\n\nprivate\n  variable\n    a b : Level\n    A B : Set a\n\ninfixl 0 _!|&gt;_ _!|&gt;\u2032_\ninfixr -1 _$!_ _$!\u2032_\n\n------------------------------------------------------------------------\n-- Dependent combinators\n\n-- These are functions whose output has a type that depends on the\n-- value of the input to the function.\n\nopen import Agda.Builtin.Strict public\n  renaming\n  ( primForce      to force\n  ; primForceLemma to force-\u2261\n  )\n\n-- Application\n_$!_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       ((x : A) \u2192 B x) \u2192 ((x : A) \u2192 B x)\nf $! x = force x f\n\n-- Flipped application\n_!|&gt;_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       (a : A) \u2192 (\u2200 a \u2192 B a) \u2192 B a\n_!|&gt;_ = flip _$!_\n\n------------------------------------------------------------------------\n-- Non-dependent combinators\n\n-- Any of the above operations for dependent functions will also work\n-- for non-dependent functions but sometimes Agda has difficulty\n-- inferring the non-dependency. Primed (\u2032 = \\prime) versions of the\n-- operations are therefore provided below that sometimes have better\n-- inference properties.\n\nseq : A \u2192 B \u2192 B\nseq a b = force a (\u03bb _ \u2192 b)\n\nseq-\u2261 : (a : A) (b : B) \u2192 seq a b \u2261 b\nseq-\u2261 a b = force-\u2261 a (\u03bb _ \u2192 b)\n\nforce\u2032 : A \u2192 (A \u2192 B) \u2192 B\nforce\u2032 = force\n\nforce\u2032-\u2261 : (a : A) (f : A \u2192 B) \u2192 force\u2032 a f \u2261 f a\nforce\u2032-\u2261 = force-\u2261\n\n-- Application\n_$!\u2032_ : (A \u2192 B) \u2192 (A \u2192 B)\n_$!\u2032_ = _$!_\n\n-- Flipped application\n_!|&gt;\u2032_ : A \u2192 (A \u2192 B) \u2192 B\n_!|&gt;\u2032_ = _!|&gt;_\n</pre>"},{"location":"md/Function/Structures/","title":"Function.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Structures for types of functions\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Function.Structures {a b \u2113\u2081 \u2113\u2082}\n  {A : Set a} (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  {B : Set b} (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\nopen import Data.Product.Base as Product using (\u2203; _\u00d7_; _,_)\nopen import Function.Base\nopen import Function.Definitions\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- One element structures\n------------------------------------------------------------------------\n\nrecord IsCongruent (to : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    cong           : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n    isEquivalence\u2081 : IsEquivalence _\u2248\u2081_\n    isEquivalence\u2082 : IsEquivalence _\u2248\u2082_\n\n  module Eq\u2081 where\n\n    setoid : Setoid a \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\u2081\n      }\n\n    open Setoid setoid public\n\n  module Eq\u2082 where\n\n    setoid : Setoid b \u2113\u2082\n    setoid = record\n      { isEquivalence = isEquivalence\u2082\n      }\n\n    open Setoid setoid public\n\n\nrecord IsInjection (to : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    injective   : Injective _\u2248\u2081_ _\u2248\u2082_ to\n\n  open IsCongruent isCongruent public\n\n\nrecord IsSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent f\n    surjective  : Surjective _\u2248\u2081_ _\u2248\u2082_ f\n\n  open IsCongruent isCongruent public\n\n  strictlySurjective : StrictlySurjective _\u2248\u2082_ f\n  strictlySurjective x = Product.map\u2082 (\u03bb v \u2192 v Eq\u2081.refl) (surjective x)\n\n\nrecord IsBijection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isInjection : IsInjection f\n    surjective  : Surjective _\u2248\u2081_ _\u2248\u2082_ f\n\n  open IsInjection isInjection public\n\n  bijective : Bijective _\u2248\u2081_ _\u2248\u2082_ f\n  bijective = injective , surjective\n\n  isSurjection : IsSurjection f\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective  = surjective\n    }\n\n  open IsSurjection isSurjection public\n    using (strictlySurjective)\n\n\n------------------------------------------------------------------------\n-- Two element structures\n------------------------------------------------------------------------\n\nrecord IsLeftInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent  : IsCongruent to\n    from-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    inverse\u02e1     : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsCongruent isCongruent public\n    renaming (cong to to-cong)\n\n  strictlyInverse\u02e1 : StrictlyInverse\u02e1 _\u2248\u2082_ to from\n  strictlyInverse\u02e1 x = inverse\u02e1 Eq\u2081.refl\n\n  isSurjection : IsSurjection to\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective = \u03bb y \u2192 from y , inverse\u02e1\n    }\n\n\nrecord IsRightInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    from-cong   : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    inverse\u02b3    : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsCongruent isCongruent public\n    renaming (cong to to-cong)\n\n  strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n  strictlyInverse\u02b3 x = inverse\u02b3 Eq\u2082.refl\n\n\nrecord IsInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLeftInverse : IsLeftInverse to from\n    inverse\u02b3      : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsLeftInverse isLeftInverse public\n\n  isRightInverse : IsRightInverse to from\n  isRightInverse = record\n    { isCongruent = isCongruent\n    ; from-cong   = from-cong\n    ; inverse\u02b3    = inverse\u02b3\n    }\n\n  open IsRightInverse isRightInverse public\n    using (strictlyInverse\u02b3)\n\n  inverse : Inverse\u1d47 _\u2248\u2081_ _\u2248\u2082_ to from\n  inverse = inverse\u02e1 , inverse\u02b3\n\n\n------------------------------------------------------------------------\n-- Three element structures\n------------------------------------------------------------------------\n\nrecord IsBiEquivalence\n  (to : A \u2192 B) (from\u2081 : B \u2192 A) (from\u2082 : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    to-isCongruent : IsCongruent to\n    from\u2081-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n    from\u2082-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n\n  open IsCongruent to-isCongruent public\n    renaming (cong to to-cong\u2081)\n\n\nrecord IsBiInverse\n  (to : A \u2192 B) (from\u2081 : B \u2192 A) (from\u2082 : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    to-isCongruent : IsCongruent to\n    from\u2081-cong     : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n    from\u2082-cong     : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n    inverse\u02e1       : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\u2081\n    inverse\u02b3       : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\u2082\n\n  open IsCongruent to-isCongruent public\n    renaming (cong to to-cong)\n\n\n------------------------------------------------------------------------\n-- Other\n------------------------------------------------------------------------\n\n-- See the comment on `SplitSurjection` in `Function.Bundles` for an\n-- explanation of (split) surjections.\nrecord IsSplitSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    from : B \u2192 A\n    isLeftInverse : IsLeftInverse f from\n\n  open IsLeftInverse isLeftInverse public\n</pre>"},{"location":"md/Function/Structures/Biased/","title":"Function.Structures.Biased","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Ways to give instances of certain structures where some fields can\n-- be given in terms of others.\n-- The contents of this file should usually be accessed from `Function`.\n------------------------------------------------------------------------\n\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\n\n\nmodule Function.Structures.Biased {a b \u2113\u2081 \u2113\u2082}\n  {A : Set a} (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  {B : Set b} (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\nopen import Data.Product.Base as Product using (\u2203; _\u00d7_; _,_)\nopen import Function.Base using (_\u2218_; id)\nopen import Function.Definitions using(StrictlySurjective; StrictlyInverse\u02e1; StrictlyInverse\u02b3; Congruent)\nopen import Function.Consequences.Setoid\n  using (strictlySurjective\u21d2surjective; strictlyInverse\u02e1\u21d2inverse\u02e1\n        ; strictlyInverse\u02b3\u21d2inverse\u02b3)\nopen import Level using (_\u2294_)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nopen import Function.Structures _\u2248\u2081_ _\u2248\u2082_\n\n------------------------------------------------------------------------\n-- Surjection\n------------------------------------------------------------------------\n\nrecord IsStrictSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent f\n    strictlySurjective : StrictlySurjective _\u2248\u2082_ f\n\n  open IsCongruent isCongruent public\n\n  isSurjection : IsSurjection f\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective = strictlySurjective\u21d2surjective\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlySurjective\n    }\n\nopen IsStrictSurjection public\n  using () renaming (isSurjection to isStrictSurjection)\n\n------------------------------------------------------------------------\n-- Bijection\n------------------------------------------------------------------------\n\nrecord IsStrictBijection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isInjection : IsInjection f\n    strictlySurjective  : StrictlySurjective _\u2248\u2082_ f\n\n  isBijection : IsBijection f\n  isBijection = record\n    { isInjection = isInjection\n    ; surjective = strictlySurjective\u21d2surjective\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlySurjective\n    } where open IsInjection isInjection\n\nopen IsStrictBijection public\n  using () renaming (isBijection to isStrictBijection)\n\n------------------------------------------------------------------------\n-- Left inverse\n------------------------------------------------------------------------\n\nrecord IsStrictLeftInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent  : IsCongruent to\n    from-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    strictlyInverse\u02e1 : StrictlyInverse\u02e1 _\u2248\u2082_ to from\n\n  isLeftInverse : IsLeftInverse to from\n  isLeftInverse = record\n    { isCongruent = isCongruent\n    ; from-cong = from-cong\n    ; inverse\u02e1 = strictlyInverse\u02e1\u21d2inverse\u02e1\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlyInverse\u02e1\n    } where open IsCongruent isCongruent\n\nopen IsStrictLeftInverse public\n  using () renaming (isLeftInverse to isStrictLeftInverse)\n\n------------------------------------------------------------------------\n-- Right inverse\n------------------------------------------------------------------------\n\nrecord IsStrictRightInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    from-cong   : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n\n  isRightInverse : IsRightInverse to from\n  isRightInverse = record\n    { isCongruent = isCongruent\n    ; from-cong = from-cong\n    ; inverse\u02b3 = strictlyInverse\u02b3\u21d2inverse\u02b3\n        Eq\u2081.setoid Eq\u2082.setoid from-cong strictlyInverse\u02b3\n    } where open IsCongruent isCongruent\n\nopen IsStrictRightInverse public\n  using () renaming (isRightInverse to isStrictRightInverse)\n\n------------------------------------------------------------------------\n-- Inverse\n------------------------------------------------------------------------\n\nrecord IsStrictInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLeftInverse : IsLeftInverse to from\n    strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n\n  isInverse : IsInverse to from\n  isInverse = record\n    { isLeftInverse = isLeftInverse\n    ; inverse\u02b3      = strictlyInverse\u02b3\u21d2inverse\u02b3\n        Eq\u2081.setoid Eq\u2082.setoid from-cong strictlyInverse\u02b3\n    } where open IsLeftInverse isLeftInverse\n\nopen IsStrictInverse public\n  using () renaming (isInverse to isStrictInverse)\n</pre>"},{"location":"md/Induction/","title":"Induction","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- An abstraction of various forms of recursion/induction\n------------------------------------------------------------------------\n\n-- The idea underlying Induction.* comes from Epigram\u00a01, see Section\u00a04\n-- of \"The view from the left\" by McBride and McKinna.\n\n-- Note: The types in this module can perhaps be easier to understand\n-- if they are normalised. Note also that Agda can do the\n-- normalisation for you.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Induction where\n\nopen import Level\nopen import Relation.Unary\nopen import Relation.Unary.PredicateTransformer using (PT)\n\nprivate\n  variable\n    a \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    Q : Pred A \u2113\n    Rec : PT A A \u2113\u2081 \u2113\u2082\n\n\n------------------------------------------------------------------------\n-- A RecStruct describes the allowed structure of recursion. The\n-- examples in Data.Nat.Induction should explain what this is all\n-- about.\n\nRecStruct : Set a \u2192 (\u2113\u2081 \u2113\u2082 : Level) \u2192 Set _\nRecStruct A = PT A A\n\n-- A recursor builder constructs an instance of a recursion structure\n-- for a given input.\n\nRecursorBuilder : RecStruct A \u2113\u2081 \u2113\u2082 \u2192 Set _\nRecursorBuilder Rec = \u2200 P \u2192 Rec P \u2286\u2032 P \u2192 Universal (Rec P)\n\n-- A recursor can be used to actually compute/prove something useful.\n\nRecursor : RecStruct A \u2113\u2081 \u2113\u2082 \u2192 Set _\nRecursor Rec = \u2200 P \u2192 Rec P \u2286\u2032 P \u2192 Universal P\n\n-- And recursors can be constructed from recursor builders.\n\nbuild : RecursorBuilder Rec \u2192 Recursor Rec\nbuild builder P f x = f x (builder P f x)\n\n-- We can repeat the exercise above for subsets of the type we are\n-- recursing over.\n\nSubsetRecursorBuilder : Pred A \u2113 \u2192 RecStruct A \u2113\u2081 \u2113\u2082 \u2192 Set _\nSubsetRecursorBuilder Q Rec = \u2200 P \u2192 Rec P \u2286\u2032 P \u2192 Q \u2286\u2032 Rec P\n\nSubsetRecursor : Pred A \u2113 \u2192 RecStruct A \u2113\u2081 \u2113\u2082 \u2192 Set _\nSubsetRecursor Q Rec = \u2200 P \u2192 Rec P \u2286\u2032 P \u2192 Q \u2286\u2032 P\n\nsubsetBuild : SubsetRecursorBuilder Q Rec \u2192 SubsetRecursor Q Rec\nsubsetBuild builder P f x q = f x (builder P f x q)\n</pre>"},{"location":"md/Induction/WellFounded/","title":"Induction.WellFounded","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Well-founded induction\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Induction.WellFounded where\n\nopen import Data.Product.Base using (\u03a3; _,_; proj\u2081; proj\u2082)\nopen import Function.Base using (_\u2218_; flip; _on_)\nopen import Induction\n  using (RecStruct; RecursorBuilder; Recursor; build\n        ; SubsetRecursorBuilder; SubsetRecursor; subsetBuild)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Definitions\n  using (Symmetric; Asymmetric; Irreflexive\n        ; _Respects\u2082_; _Respects\u02b3_; _Respects_)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; refl)\nopen import Relation.Binary.Consequences using (asym\u21d2irr)\nopen import Relation.Unary\n  using (Pred; _\u2286\u2032_; _\u2286_; _\u21d2_; Universal; IUniversal; Stable; Empty)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nprivate\n  variable\n    a b \u2113 \u2113\u2081 \u2113\u2082 r : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Definitions\n\n-- When using well-founded recursion you can recurse arbitrarily, as\n-- long as the arguments become smaller, and \"smaller\" is\n-- well-founded.\n\nWfRec : Rel A r \u2192 \u2200 {\u2113} \u2192 RecStruct A \u2113 _\nWfRec _&lt;_ P x = \u2200 {y} \u2192 y &lt; x \u2192 P y\n\n-- The accessibility predicate: x is accessible if everything which is\n-- smaller than x is also accessible (inductively).\n\ndata Acc {A : Set a} (_&lt;_ : Rel A \u2113) (x : A) : Set (a \u2294 \u2113) where\n  acc : (rs : WfRec _&lt;_ (Acc _&lt;_) x) \u2192 Acc _&lt;_ x\n\n-- The accessibility predicate encodes what it means to be\n-- well-founded; if all elements are accessible, then _&lt;_ is\n-- well-founded.\n\nWellFounded : Rel A \u2113 \u2192 Set _\nWellFounded _&lt;_ = \u2200 x \u2192 Acc _&lt;_ x\n\n------------------------------------------------------------------------\n-- Basic properties\n\nacc-inverse : \u2200 {_&lt;_ : Rel A \u2113} {x : A} (q : Acc _&lt;_ x) \u2192\n              WfRec _&lt;_ (Acc _&lt;_) x\nacc-inverse (acc rs) y&lt;x = rs y&lt;x\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_&lt;_ : Rel A \u2113\u2082} where\n\n  Acc-resp-flip-\u2248 : _&lt;_ Respects\u02b3 (flip _\u2248_) \u2192 (Acc _&lt;_) Respects _\u2248_\n  Acc-resp-flip-\u2248 resp\u02b3 x\u2248y (acc rec) = acc \u03bb z&lt;y \u2192 rec (resp\u02b3 x\u2248y z&lt;y)\n\n  Acc-resp-\u2248 : Symmetric _\u2248_ \u2192 _&lt;_ Respects\u02b3 _\u2248_ \u2192 (Acc _&lt;_) Respects _\u2248_\n  Acc-resp-\u2248 sym resp\u02b3 x\u2248y wf = Acc-resp-flip-\u2248 (resp\u02b3 \u2218 sym) x\u2248y wf\n\n------------------------------------------------------------------------\n-- Well-founded induction for the subset of accessible elements:\n\nmodule Some {_&lt;_ : Rel A r} {\u2113} where\n\n  wfRecBuilder : SubsetRecursorBuilder (Acc _&lt;_) (WfRec _&lt;_ {\u2113 = \u2113})\n  wfRecBuilder P f x (acc rs) = \u03bb y&lt;x \u2192 f _ (wfRecBuilder P f _ (rs y&lt;x))\n\n  wfRec : SubsetRecursor (Acc _&lt;_) (WfRec _&lt;_)\n  wfRec = subsetBuild wfRecBuilder\n\n  unfold-wfRec : (P : Pred A \u2113) (f : WfRec _&lt;_ P \u2286\u2032 P) {x : A} (q : Acc _&lt;_ x) \u2192\n                 wfRec P f x q \u2261 f x \u03bb y&lt;x \u2192 wfRec P f _ (acc-inverse q y&lt;x)\n  unfold-wfRec P f (acc rs) = refl\n\n\n------------------------------------------------------------------------\n-- Well-founded induction for all elements, assuming they are all\n-- accessible:\n\nmodule All {_&lt;_ : Rel A r} (wf : WellFounded _&lt;_) \u2113 where\n\n  wfRecBuilder : RecursorBuilder (WfRec _&lt;_ {\u2113 = \u2113})\n  wfRecBuilder P f x = Some.wfRecBuilder P f x (wf x)\n\n  wfRec : Recursor (WfRec _&lt;_)\n  wfRec = build wfRecBuilder\n\n  wfRec-builder = wfRecBuilder\n\nmodule FixPoint\n  {_&lt;_ : Rel A r} (wf : WellFounded _&lt;_)\n  (P : Pred A \u2113) (f : WfRec _&lt;_ P \u2286\u2032 P)\n  (f-ext : (x : A) {IH IH\u2032 : WfRec _&lt;_ P x} \u2192\n           (\u2200 {y} y&lt;x \u2192 IH {y} y&lt;x \u2261 IH\u2032 y&lt;x) \u2192\n           f x IH \u2261 f x IH\u2032)\n  where\n\n  some-wfrec-Irrelevant : Pred A _\n  some-wfrec-Irrelevant x = \u2200 q q\u2032 \u2192 Some.wfRec P f x q \u2261 Some.wfRec P f x q\u2032\n\n  some-wfRec-irrelevant : \u2200 x \u2192 some-wfrec-Irrelevant x\n  some-wfRec-irrelevant = All.wfRec wf _ some-wfrec-Irrelevant\n    \u03bb { x IH (acc rs) (acc rs\u2032) \u2192 f-ext x \u03bb y&lt;x \u2192 IH y&lt;x (rs y&lt;x) (rs\u2032 y&lt;x) }\n\n  open All wf \u2113\n\n  wfRecBuilder-wfRec : \u2200 {x y} y&lt;x \u2192 wfRecBuilder P f x y&lt;x \u2261 wfRec P f y\n  wfRecBuilder-wfRec {x} {y} y&lt;x with acc rs \u2190 wf x\n   = some-wfRec-irrelevant y (rs y&lt;x) (wf y)\n\n  unfold-wfRec : \u2200 {x} \u2192 wfRec P f x \u2261 f x \u03bb _ \u2192 wfRec P f _\n  unfold-wfRec {x} = f-ext x wfRecBuilder-wfRec\n\n------------------------------------------------------------------------\n-- Well-founded relations are asymmetric and irreflexive.\n\nmodule _ {_&lt;_ : Rel A r} where\n  acc\u21d2asym : \u2200 {x y} \u2192 Acc _&lt;_ x \u2192 x &lt; y \u2192 \u00ac (y &lt; x)\n  acc\u21d2asym {x} hx =\n    Some.wfRec (\u03bb x \u2192 \u2200 {y} \u2192 x &lt; y \u2192 \u00ac (y &lt; x)) (\u03bb _ hx x&lt;y y&lt;x \u2192 hx y&lt;x y&lt;x x&lt;y) _ hx\n\n  wf\u21d2asym : WellFounded _&lt;_ \u2192 Asymmetric _&lt;_\n  wf\u21d2asym wf = acc\u21d2asym (wf _)\n\n  wf\u21d2irrefl : {_\u2248_ : Rel A \u2113} \u2192 _&lt;_ Respects\u2082 _\u2248_ \u2192\n              Symmetric _\u2248_ \u2192 WellFounded _&lt;_ \u2192 Irreflexive _\u2248_ _&lt;_\n  wf\u21d2irrefl r s wf = asym\u21d2irr r s (wf\u21d2asym wf)\n\n------------------------------------------------------------------------\n-- It might be useful to establish proofs of Acc or Well-founded using\n-- combinators such as the ones below (see, for instance,\n-- \"Constructing Recursion Operators in Intuitionistic Type Theory\" by\n-- Lawrence C Paulson).\n\nmodule Subrelation {_&lt;\u2081_ : Rel A \u2113\u2081} {_&lt;\u2082_ : Rel A \u2113\u2082}\n                   (&lt;\u2081\u21d2&lt;\u2082 : \u2200 {x y} \u2192 x &lt;\u2081 y \u2192 x &lt;\u2082 y) where\n\n  accessible : Acc _&lt;\u2082_ \u2286 Acc _&lt;\u2081_\n  accessible (acc rs) = acc \u03bb y&lt;x \u2192 accessible (rs (&lt;\u2081\u21d2&lt;\u2082 y&lt;x))\n\n  wellFounded : WellFounded _&lt;\u2082_ \u2192 WellFounded _&lt;\u2081_\n  wellFounded wf = \u03bb x \u2192 accessible (wf x)\n\n\n-- DEPRECATED in v1.4.\n-- Please use proofs in `Relation.Binary.Construct.On` instead.\nmodule InverseImage {_&lt;_ : Rel B \u2113} (f : A \u2192 B) where\n\n  accessible : \u2200 {x} \u2192 Acc _&lt;_ (f x) \u2192 Acc (_&lt;_ on f) x\n  accessible (acc rs) = acc \u03bb fy&lt;fx \u2192 accessible (rs fy&lt;fx)\n\n  wellFounded : WellFounded _&lt;_ \u2192 WellFounded (_&lt;_ on f)\n  wellFounded wf = \u03bb x \u2192 accessible (wf (f x))\n\n  well-founded = wellFounded\n  {-# WARNING_ON_USAGE accessible\n  \"Warning: accessible was deprecated in v1.4.\n\\ \\Please use accessible from `Relation.Binary.Construct.On` instead.\"\n  #-}\n  {-# WARNING_ON_USAGE wellFounded\n  \"Warning: wellFounded was deprecated in v1.4.\n\\ \\Please use wellFounded from `Relation.Binary.Construct.On` instead.\"\n  #-}\n\n\n-- DEPRECATED in v1.5.\n-- Please use `TransClosure` from `Relation.Binary.Construct.Closure.Transitive` instead.\nmodule TransitiveClosure {A : Set a} (_&lt;_ : Rel A \u2113) where\n\n  infix 4 _&lt;\u207a_\n\n  data _&lt;\u207a_ : Rel A (a \u2294 \u2113) where\n    [_]   : \u2200 {x y} (x&lt;y : x &lt; y) \u2192 x &lt;\u207a y\n    trans : \u2200 {x y z} (x&lt;y : x &lt;\u207a y) (y&lt;z : y &lt;\u207a z) \u2192 x &lt;\u207a z\n\n  downwardsClosed : \u2200 {x y} \u2192 Acc _&lt;\u207a_ y \u2192 x &lt;\u207a y \u2192 Acc _&lt;\u207a_ x\n  downwardsClosed (acc rs) x&lt;y = acc \u03bb z&lt;x \u2192 rs (trans z&lt;x x&lt;y)\n\n  mutual\n\n    accessible : \u2200 {x} \u2192 Acc _&lt;_ x \u2192 Acc _&lt;\u207a_ x\n    accessible acc-x = acc (accessible\u2032 acc-x)\n\n    accessible\u2032 : \u2200 {x} \u2192 Acc _&lt;_ x \u2192 WfRec _&lt;\u207a_ (Acc _&lt;\u207a_) x\n    accessible\u2032 (acc rs) [ y&lt;x ]         = accessible (rs y&lt;x)\n    accessible\u2032 acc-x    (trans y&lt;z z&lt;x) =\n      downwardsClosed (accessible\u2032 acc-x z&lt;x) y&lt;z\n\n  wellFounded : WellFounded _&lt;_ \u2192 WellFounded _&lt;\u207a_\n  wellFounded wf = \u03bb x \u2192 accessible (wf x)\n\n  {-# WARNING_ON_USAGE _&lt;\u207a_\n  \"Warning: _&lt;\u207a_ was deprecated in v1.5.\n\\ \\Please use TransClosure from Relation.Binary.Construct.Closure.Transitive instead.\"\n  #-}\n\n\n-- DEPRECATED in v1.3.\n-- Please use `\u00d7-Lex` from `Data.Product.Relation.Binary.Lex.Strict` instead.\nmodule Lexicographic {A : Set a} {B : A \u2192 Set b}\n                     (RelA : Rel A \u2113\u2081)\n                     (RelB : \u2200 x \u2192 Rel (B x) \u2113\u2082) where\n\n  infix 4 _&lt;_\n  data _&lt;_ : Rel (\u03a3 A B) (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    left  : \u2200 {x\u2081 y\u2081 x\u2082 y\u2082} (x\u2081&lt;x\u2082 : RelA   x\u2081 x\u2082) \u2192 (x\u2081 , y\u2081) &lt; (x\u2082 , y\u2082)\n    right : \u2200 {x y\u2081 y\u2082}     (y\u2081&lt;y\u2082 : RelB x y\u2081 y\u2082) \u2192 (x  , y\u2081) &lt; (x  , y\u2082)\n\n  mutual\n\n    accessible : \u2200 {x y} \u2192\n                 Acc RelA x \u2192 (\u2200 {x} \u2192 WellFounded (RelB x)) \u2192\n                 Acc _&lt;_ (x , y)\n    accessible accA wfB = acc (accessible\u2032 accA (wfB _) wfB)\n\n\n    accessible\u2032 :\n      \u2200 {x y} \u2192\n      Acc RelA x \u2192 Acc (RelB x) y \u2192 (\u2200 {x} \u2192 WellFounded (RelB x)) \u2192\n      WfRec _&lt;_ (Acc _&lt;_) (x , y)\n    accessible\u2032 (acc rsA) _    wfB (left  x\u2032&lt;x) = accessible (rsA x\u2032&lt;x) wfB\n    accessible\u2032 accA (acc rsB) wfB (right y\u2032&lt;y) =\n      acc (accessible\u2032 accA (rsB y\u2032&lt;y) wfB)\n\n  wellFounded : WellFounded RelA \u2192 (\u2200 {x} \u2192 WellFounded (RelB x)) \u2192\n                WellFounded _&lt;_\n  wellFounded wfA wfB p = accessible (wfA (proj\u2081 p)) wfB\n\n  well-founded = wellFounded\n\n  {-# WARNING_ON_USAGE _&lt;_\n  \"Warning: _&lt;_ was deprecated in v1.3.\n\\ \\Please use `\u00d7-Lex` from `Data.Product.Relation.Binary.Lex.Strict` instead.\"\n  #-}\n  {-# WARNING_ON_USAGE accessible\n  \"Warning: accessible was deprecated in v1.3.\"\n  #-}\n  {-# WARNING_ON_USAGE accessible\u2032\n  \"Warning: accessible\u2032 was deprecated in v1.3.\"\n  #-}\n  {-# WARNING_ON_USAGE wellFounded\n  \"Warning: wellFounded was deprecated in v1.3.\n\\ \\Please use `\u00d7-wellFounded` from `Data.Product.Relation.Binary.Lex.Strict` instead.\"\n  #-}\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.0\n\nmodule Inverse-image = InverseImage\nmodule Transitive-closure = TransitiveClosure\n</pre>"},{"location":"md/LC/Definitions/","title":"LC.Definitions","text":"<pre>\nmodule LC.Definitions where\n\nimport LC.Variables\nimport LC.Terms\nimport LC.Domains\nimport LC.Environments\nimport LC.Semantics\n</pre>"},{"location":"md/LC/Domains/","title":"LC.Domains","text":"<pre>\nmodule LC.Domains where\n\nopen import Function\n  using (Inverse; _\u2194_) public\nopen Inverse {{ ... }}\n  using (to; from) public\n\npostulate\n  D\u221e : Set\npostulate\n  instance iso : D\u221e \u2194 (D\u221e \u2192 D\u221e)\n\nvariable d : D\u221e\n</pre>"},{"location":"md/LC/Environments/","title":"LC.Environments","text":"<pre>\nmodule LC.Environments where\n\nopen import LC.Variables\nopen import LC.Domains\nopen import Data.Bool using (if_then_else_)\n\nEnv = Var \u2192 D\u221e\n\nvariable \u03c1 : Env\n\n_[_/_] : Env \u2192 D\u221e \u2192 Var \u2192 Env\n\u03c1 [ d / v ] = \u03bb v\u2032 \u2192 if v == v\u2032 then d else \u03c1 v\u2032\n</pre>"},{"location":"md/LC/Semantics/","title":"LC.Semantics","text":"<pre>\nmodule LC.Semantics where\n\nopen import LC.Variables\nopen import LC.Terms\nopen import LC.Domains\nopen import LC.Environments\n\n\u27e6_\u27e7 : Exp \u2192 Env \u2192 D\u221e\n-- \u27e6 e \u27e7 \u03c1 is the value of e with \u03c1 giving the values of free variables \n\n\u27e6 var  v      \u27e7 \u03c1  = \u03c1 v\n\u27e6 lam  v e    \u27e7 \u03c1  = from ( \u03bb d \u2192 \u27e6 e \u27e7 (\u03c1 [ d / v ]) )\n\u27e6 app  e\u2081 e\u2082  \u27e7 \u03c1  = to ( \u27e6 e\u2081 \u27e7 \u03c1 ) ( \u27e6 e\u2082 \u27e7 \u03c1 )\n</pre>"},{"location":"md/LC/Terms/","title":"LC.Terms","text":"<pre>\nmodule LC.Terms where\n\nopen import LC.Variables\n\ndata Exp : Set where\n  var_  : Var \u2192 Exp         -- variable value\n  lam   : Var \u2192 Exp \u2192 Exp   -- lambda abstraction\n  app   : Exp \u2192 Exp \u2192 Exp   -- application\n\nvariable e : Exp\n</pre>"},{"location":"md/LC/Tests/","title":"LC.Tests","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\n\nopen import Agda.Builtin.Equality\nopen import Agda.Builtin.Equality.Rewrite\n\nmodule LC.Tests where\n\nopen import LC.Domains\nopen import LC.Variables\nopen import LC.Terms\nopen import LC.Semantics\n\nopen import Relation.Binary.PropositionalEquality using (refl)\nopen Inverse using (inverse\u02e1; inverse\u02b3)\n\nto-from-elim : \u2200 {f}  \u2192  to (from f)  \u2261 f\nto-from-elim  = inverse\u02e1 iso refl\n\nfrom-to-elim : \u2200 {d}  \u2192  from (to d)  \u2261 d\nfrom-to-elim  = inverse\u02b3 iso refl\n\n{-# REWRITE to-from-elim #-}\n\n-- The following proofs are potentially unsound,\n-- due to rewriting using the postulated iso\n\n-- (\u03bbx1.x1)x42 = x42\ncheck-id :\n  \u27e6 app (lam (x 1) (var x 1))\n        (var x 42) \u27e7 \u2261 \u27e6 var x 42 \u27e7\ncheck-id = refl\n\n-- (\u03bbx1.x42)x0 = x42\ncheck-const :\n  \u27e6 app (lam (x 1) (var x 42))\n        (var x 0) \u27e7 \u2261 \u27e6 var x 42 \u27e7\ncheck-const = refl \n\n-- (\u03bbx0.x0 x0)(\u03bbx0.x0 x0) = ...\n-- check-divergence :\n--   \u27e6 app (lam (x 0) (app (var x 0) (var x 0))) \n--         (lam (x 0) (app (var x 0) (var x 0))) \u27e7\n--   \u2261 \u27e6 var x 42 \u27e7\n-- check-divergence = refl \n\n-- (\u03bbx1.x42)((\u03bbx0.x0 x0)(\u03bbx0.x0 x0)) = x42\ncheck-convergence :\n  \u27e6 app (lam (x 1) (var x 42))\n        (app (lam (x 0) (app (var x 0) (var x 0))) \n             (lam (x 0) (app (var x 0) (var x 0)))) \u27e7\n  \u2261 \u27e6 var x 42 \u27e7\ncheck-convergence = refl \n\n-- (\u03bbx1.x1)(\u03bbx1.x42) = \u03bbx2.x42\ncheck-abs :\n  \u27e6 app (lam (x 1) (var x 1))\n        (lam (x 1) (var x 42)) \u27e7\n     \u2261 \u27e6 lam (x 2) (var x 42) \u27e7\ncheck-abs = refl\n\n-- (\u03bbx1.(\u03bbx42.x1)x2)x42 = x42\ncheck-free :\n  \u27e6 app (lam (x 1) \n          (app (lam (x 42) (var x 1))\n               (var x 2)))\n        (var x 42) \u27e7 \u2261 \u27e6 var x 42 \u27e7\ncheck-free = refl\n</pre>"},{"location":"md/LC/Variables/","title":"LC.Variables","text":"<pre>\nmodule LC.Variables where\n\nopen import Data.Bool using (Bool)\nopen import Data.Nat  using (\u2115; _\u2261\u1d47_)\n\ndata Var : Set where\n  x : \u2115 \u2192 Var  -- variables\n\nvariable v : Var\n\n_==_ : Var \u2192 Var \u2192 Bool\nx n == x n\u2032 = (n \u2261\u1d47 n\u2032)\n</pre>"},{"location":"md/LC/index/","title":"LC.index","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\n\nmodule LC.index where\n\nimport LC.Definitions\nimport LC.Domains\nimport LC.Environments\nimport LC.Semantics\nimport LC.Terms\nimport LC.Tests\nimport LC.Variables\n</pre>"},{"location":"md/Level/","title":"Level","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Universe levels\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Level where\n\n-- Levels.\n\nopen import Agda.Primitive as Prim public\n  using    (Level; _\u2294_; Set\u03c9)\n  renaming (lzero to zero; lsuc to suc)\n\n-- Lifting.\n\nrecord Lift {a} \u2113 (A : Set a) : Set (a \u2294 \u2113) where\n  constructor lift\n  field lower : A\n\nopen Lift public\n\n-- Synonyms\n\n0\u2113 : Level\n0\u2113 = zero\n\nlevelOfType : \u2200 {a} \u2192 Set a \u2192 Level\nlevelOfType {a} _ = a\n\nlevelOfTerm : \u2200 {a} {A : Set a} \u2192 A \u2192 Level\nlevelOfTerm {a} _ = a\n</pre>"},{"location":"md/PCF/Checks/","title":"PCF.Checks","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\nopen import Agda.Builtin.Equality\nopen import Agda.Builtin.Equality.Rewrite\n\nmodule PCF.Checks where\n\nopen import Data.Bool.Base \nopen import Agda.Builtin.Nat\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; cong-app)\n\nopen import PCF.Domain-Notation\nopen import PCF.Types\nopen import PCF.Constants\nopen import PCF.Variables\nopen import PCF.Environments\nopen import PCF.Terms\n\nfix-app  : \u2200 {P D} (f : (P \u2192 D) \u2192 (P \u2192 D)) (p : P) \u2192\n              fix f p \u2261 f (fix f) p\nfix-app  = \u03bb f \u2192 cong-app (fix-fix f) \n\n{-# REWRITE fix-app elim-\u266f-\u03b7 elim-\u266f-\u22a5 true-cond false-cond #-} \n\n-- Constants\npattern \ud835\udc41 n    = \ud835\udc3f (k n)\npattern succ   = \ud835\udc3f +1\u2032\npattern pred\u22a5  = \ud835\udc3f -1\u2032\npattern if     = \ud835\udc3f \u2283\u1d62\npattern \ud835\udc4c      = \ud835\udc3f Y\npattern \ud835\udc4d     = \ud835\udc3f Z\n\n-- Variables\nf  = var 0 \u03b9\ng  = var 1 (\u03b9 \u21d2 \u03b9)\nh  = var 2 (\u03b9 \u21d2 \u03b9 \u21d2 \u03b9)\na  = var 3 \u03b9\nb  = var 4 \u03b9\n\n-- Arithmetic\ncheck-41+1 : \ud835\udc9c\u2032\u27e6 succ \u2423 \ud835\udc41 41 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-41+1 = refl\n\ncheck-43-1 : \ud835\udc9c\u2032\u27e6 pred\u22a5 \u2423 \ud835\udc41 43 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-43-1 = refl\n\n-- Binding\ncheck-id : \ud835\udc9c\u2032\u27e6 (\u019b a \u2423 \ud835\udc49 a) \u2423 \ud835\udc41 42 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-id = refl\n\ncheck-k : \ud835\udc9c\u2032\u27e6 (\u019b a \u2423 \u019b b \u2423 \ud835\udc49 a) \u2423 \ud835\udc41 42 \u2423 \ud835\udc41 41 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-k = refl\n\ncheck-ki : \ud835\udc9c\u2032\u27e6 (\u019b a \u2423 \u019b b \u2423 \ud835\udc49 b) \u2423 \ud835\udc41 41 \u2423 \ud835\udc41 42 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-ki = refl\n\n</pre> <pre>\ncheck-suc-41 : \ud835\udc9c\u2032\u27e6 (\u019b a \u2423 (succ \u2423 \ud835\udc49 a )) \u2423 \ud835\udc41 41 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-suc-41 = refl\n\ncheck-pred-42 : \ud835\udc9c\u2032\u27e6 (\u019b a \u2423 (pred\u22a5 \u2423 \ud835\udc49 a)) \u2423 \ud835\udc41 43 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-pred-42 = refl\n\ncheck-if-zero : \ud835\udc9c\u2032\u27e6 if \u2423 (\ud835\udc4d \u2423 \ud835\udc41 0) \u2423 \ud835\udc41 42 \u2423 \ud835\udc41 0 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-if-zero = refl\n\ncheck-if-nonzero : \ud835\udc9c\u2032\u27e6 if \u2423 (\ud835\udc4d \u2423 \ud835\udc41 42) \u2423 \ud835\udc41 0 \u2423 \ud835\udc41 42 \u27e7 \u03c1\u22a5 \u2261 \u03b7 42\ncheck-if-nonzero = refl\n\n-- fix (\u03bbf. 42) \u2261 42\ncheck-fix-const :\n  \ud835\udc9c\u2032\u27e6 \ud835\udc4c \u2423 (\u019b f \u2423 \ud835\udc41 42) \u27e7 \u03c1\u22a5 \n  \u2261 \u03b7 42\ncheck-fix-const = fix-fix (\u03bb x \u2192 \u03b7 42)\n\n-- fix (\u03bbg. \u03bba. 42) 2 \u2261 42\ncheck-fix-lambda :\n  \ud835\udc9c\u2032\u27e6 \ud835\udc4c \u2423 (\u019b g \u2423 \u019b a \u2423 \ud835\udc41 42) \u2423 \ud835\udc41 2 \u27e7 \u03c1\u22a5 \n  \u2261 \u03b7 42\ncheck-fix-lambda = refl\n\n-- fix (\u03bbg. \u03bba. ifz a then 42 else g (pred a)) 101 \u2261 42\ncheck-countdown :\n  \ud835\udc9c\u2032\u27e6 \ud835\udc4c \u2423 (\u019b g \u2423 \u019b a \u2423\n              (if \u2423 (\ud835\udc4d \u2423 \ud835\udc49 a) \u2423 \ud835\udc41 42 \u2423 (\ud835\udc49 g \u2423 (pred\u22a5 \u2423 \ud835\udc49 a))))\n      \u2423 \ud835\udc41 101\n    \u27e7 \u03c1\u22a5 \n  \u2261 \u03b7 42\ncheck-countdown = refl\n\n-- fix (\u03bbh. \u03bba. \u03bbb. ifz a then b else h (pred a) (succ b)) 4 38 \u2261 42\ncheck-sum-42 :\n  \ud835\udc9c\u2032\u27e6 (\ud835\udc4c \u2423 (\u019b h \u2423 \u019b a \u2423 \u019b b \u2423\n              (if \u2423 (\ud835\udc4d \u2423 \ud835\udc49 a) \u2423 \ud835\udc49 b \u2423 (\ud835\udc49 h \u2423 (pred\u22a5 \u2423 \ud835\udc49 a) \u2423 (succ \u2423 \ud835\udc49 b)))))\n      \u2423 \ud835\udc41 4 \u2423 \ud835\udc41 38\n    \u27e7 \u03c1\u22a5 \n  \u2261 \u03b7 42\ncheck-sum-42 = refl\n-- Exponential in first arg?\n</pre>"},{"location":"md/PCF/Constants/","title":"PCF.Constants","text":"<pre>\nmodule PCF.Constants where\n\nopen import Data.Bool.Base \n  using (Bool; true; false; if_then_else_)\nopen import Agda.Builtin.Nat\n  using (Nat; _+_; _-_; _==_)\n\nopen import PCF.Domain-Notation\n  using (\u03b7; _\u266f; fix; \u22a5; _\u27f6_,_)\nopen import PCF.Types\n  using (Types; o; \u03b9; _\u21d2_; \u03c3; \ud835\udc9f)\n\n-- Syntax\n\ndata \u2112 : Types \u2192 Set where\n  tt   : \u2112 o\n  ff   : \u2112 o\n  \u2283\u1d62   : \u2112 (o \u21d2 \u03b9 \u21d2 \u03b9 \u21d2 \u03b9)\n  \u2283\u2092   : \u2112 (o \u21d2 o \u21d2 o \u21d2 o)\n  Y    : {\u03c3 : Types} \u2192 \u2112 ((\u03c3 \u21d2 \u03c3) \u21d2 \u03c3)\n  k    : (n : Nat) \u2192 \u2112 \u03b9\n  +1\u2032  : \u2112 (\u03b9 \u21d2 \u03b9)\n  -1\u2032  : \u2112 (\u03b9 \u21d2 \u03b9)\n  Z    : \u2112 (\u03b9 \u21d2 o)\n\nvariable c : \u2112 \u03c3\n\n-- Semantics\n\n\ud835\udc9c\u27e6_\u27e7 : \u2112 \u03c3 \u2192 \ud835\udc9f \u03c3\n\n\ud835\udc9c\u27e6 tt   \u27e7 =  \u03b7 true\n\ud835\udc9c\u27e6 ff   \u27e7 =  \u03b7 false\n\ud835\udc9c\u27e6 \u2283\u1d62   \u27e7 =  _\u27f6_,_\n\ud835\udc9c\u27e6 \u2283\u2092   \u27e7 =  _\u27f6_,_\n\ud835\udc9c\u27e6 Y    \u27e7 =  fix\n\ud835\udc9c\u27e6 k n  \u27e7 =  \u03b7 n\n\ud835\udc9c\u27e6 +1\u2032  \u27e7 =  (\u03bb n \u2192 \u03b7 (n + 1)) \u266f\n\ud835\udc9c\u27e6 -1\u2032  \u27e7 =  (\u03bb n \u2192 if n == 0 then \u22a5 else \u03b7 (n - 1)) \u266f\n\ud835\udc9c\u27e6 Z    \u27e7 =  (\u03bb n \u2192 \u03b7 (n == 0)) \u266f\n</pre>"},{"location":"md/PCF/Domain-Notation/","title":"PCF.Domain-Notation","text":"<pre>\nmodule PCF.Domain-Notation where\n\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_) public\n\nvariable D E : Set  -- Set should be a sort of domains\n\n-- Domains are pointed\npostulate\n  \u22a5 : {D : Set} \u2192 D\n\n-- Fixed points of endofunctions on function domains\n\npostulate\n  fix : {D : Set} \u2192 (D \u2192 D) \u2192 D\n\n  -- Properties\n  fix-fix : \u2200 {D} (f : D \u2192 D) \u2192 fix f \u2261 f (fix f)\n\n-- Lifted domains\n\npostulate\n  \ud835\udd43   : Set \u2192 Set\n  \u03b7   : {P : Set} \u2192 P \u2192 \ud835\udd43 P\n  _\u266f  : {P : Set} {D : Set} \u2192 (P \u2192 D) \u2192 (\ud835\udd43 P \u2192 D)\n\n  -- Properties\n  elim-\u266f-\u03b7  : \u2200 {P D} (f : P \u2192 D) (p : P) \u2192  (f \u266f) (\u03b7 p)  \u2261 f p\n  elim-\u266f-\u22a5  : \u2200 {P D} (f : P \u2192 D) \u2192          (f \u266f) \u22a5      \u2261 \u22a5\n\n-- Flat domains\n\n_+\u22a5   : Set \u2192 Set\nS +\u22a5  = \ud835\udd43 S\n\n-- McCarthy conditional\n\n-- t \u27f6 d\u2081 , d\u2082 : D  (t : Bool +\u22a5 ; d\u2081, d\u2082 : D)\n\nopen import Data.Bool.Base\n  using (Bool; true; false; if_then_else_) public\n\npostulate\n  _\u27f6_,_ : {D : Set} \u2192 Bool +\u22a5 \u2192 D \u2192 D \u2192 D\n\n  -- Properties\n  true-cond    : \u2200 {D} {d\u2081 d\u2082 : D} \u2192 (\u03b7 true \u27f6 d\u2081 , d\u2082)  \u2261 d\u2081\n  false-cond   : \u2200 {D} {d\u2081 d\u2082 : D} \u2192 (\u03b7 false \u27f6 d\u2081 , d\u2082) \u2261 d\u2082\n  bottom-cond  : \u2200 {D} {d\u2081 d\u2082 : D} \u2192 (\u22a5 \u27f6 d\u2081 , d\u2082)       \u2261 \u22a5\n</pre>"},{"location":"md/PCF/Environments/","title":"PCF.Environments","text":"<pre>\nmodule PCF.Environments where\n\nopen import Data.Bool.Base \n  using (Bool; if_then_else_)\nopen import Data.Maybe.Base\n  using (Maybe; just; nothing)\nopen import Agda.Builtin.Nat\n  using (Nat; _==_)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; trans; cong)\n\nopen import PCF.Domain-Notation\n  using (\u22a5)\nopen import PCF.Types\n  using (Types; \u03b9; o; _\u21d2_; \ud835\udc9f)\nopen import PCF.Variables\n  using (\ud835\udcb1; var; Env)\n\n-- \u03c1\u22a5 is the initial environment\n\n\u03c1\u22a5 : Env\n\u03c1\u22a5 \u03b1 = \u22a5\n\n-- (\u03c1 [ x / \u03b1 ]) \u03b1\u2032 = x when \u03b1 and \u03b1\u2032 are identical, otherwise \u03c1 \u03b1\u2032\n\n_[_/_] : {\u03c3 : Types} \u2192 Env \u2192 \ud835\udc9f \u03c3 \u2192 \ud835\udcb1 \u03c3 \u2192 Env\n\u03c1 [ x / \u03b1 ] = \u03bb \u03b1\u2032 \u2192 h \u03c1 x \u03b1 \u03b1\u2032 (\u03b1 ==V \u03b1\u2032) where\n\n  h : {\u03c3 \u03c4 : Types} \u2192 Env \u2192 \ud835\udc9f \u03c3 \u2192 \ud835\udcb1 \u03c3 \u2192 \ud835\udcb1 \u03c4 \u2192 Maybe (\u03c3 \u2261 \u03c4) \u2192 \ud835\udc9f \u03c4\n  h \u03c1 x \u03b1 \u03b1\u2032 (just refl)  = x\n  h \u03c1 x \u03b1 \u03b1\u2032 nothing      = \u03c1 \u03b1\u2032\n\n  _==T_ : (\u03c3 \u03c4 : Types) \u2192 Maybe (\u03c3 \u2261 \u03c4)\n  (\u03c3 \u21d2 \u03c4) ==T (\u03c3\u2032 \u21d2 \u03c4\u2032) = f (\u03c3 ==T \u03c3\u2032) (\u03c4 ==T \u03c4\u2032) where\n        f : Maybe (\u03c3 \u2261 \u03c3\u2032) \u2192 Maybe (\u03c4 \u2261 \u03c4\u2032) \u2192 Maybe ((\u03c3 \u21d2 \u03c4) \u2261 (\u03c3\u2032 \u21d2 \u03c4\u2032))\n        f = \u03bb { (just p) (just q) \u2192 just (trans (cong (_\u21d2 \u03c4) p) (cong (\u03c3\u2032 \u21d2_) q))\n              ; _ _ \u2192 nothing }\n  \u03b9       ==T \u03b9         = just refl\n  o       ==T o         = just refl\n  _       ==T _         = nothing\n\n  _==V_ : {\u03c3 \u03c4 : Types} \u2192 \ud835\udcb1 \u03c3 \u2192 \ud835\udcb1 \u03c4 \u2192 Maybe (\u03c3 \u2261 \u03c4)\n  var i \u03c3 ==V var i\u2032 \u03c4 = \n    if i == i\u2032 then \u03c3 ==T \u03c4 else nothing\n</pre>"},{"location":"md/PCF/Terms/","title":"PCF.Terms","text":"<pre>\nmodule PCF.Terms where\n\nopen import PCF.Types\n  using (Types; _\u21d2_; \u03c3; \ud835\udc9f)\nopen import PCF.Constants\n  using (\u2112; \ud835\udc9c\u27e6_\u27e7; c)\nopen import PCF.Variables\n  using (\ud835\udcb1; Env; _\u27e6_\u27e7)\nopen import PCF.Environments\n  using (_[_/_])\n\n-- Syntax\n\ndata Terms : Types \u2192 Set where\n  \ud835\udc49     : {\u03c3   : Types} \u2192 \ud835\udcb1 \u03c3 \u2192 Terms \u03c3                      -- variables\n  \ud835\udc3f     : {\u03c3   : Types} \u2192 \u2112 \u03c3 \u2192 Terms \u03c3                      -- constants\n  _\u2423_   : {\u03c3 \u03c4 : Types} \u2192 Terms (\u03c3 \u21d2 \u03c4) \u2192 Terms \u03c3 \u2192 Terms \u03c4  -- application\n  \u019b_\u2423_  : {\u03c3 \u03c4 : Types} \u2192 \ud835\udcb1 \u03c3 \u2192 Terms \u03c4 \u2192 Terms (\u03c3 \u21d2 \u03c4)      -- \u03bb-abstraction\n\nvariable M N : Terms \u03c3\ninfixl 20 _\u2423_\n\n-- Semantics\n\n\ud835\udc9c\u2032\u27e6_\u27e7 : Terms \u03c3 \u2192 Env \u2192 \ud835\udc9f \u03c3\n\n\ud835\udc9c\u2032\u27e6 \ud835\udc49 \u03b1      \u27e7 \u03c1 = \u03c1 \u27e6 \u03b1 \u27e7\n\ud835\udc9c\u2032\u27e6 \ud835\udc3f c      \u27e7 \u03c1 = \ud835\udc9c\u27e6 c \u27e7\n\ud835\udc9c\u2032\u27e6 M \u2423 N    \u27e7 \u03c1 = \ud835\udc9c\u2032\u27e6 M \u27e7 \u03c1 (\ud835\udc9c\u2032\u27e6 N \u27e7 \u03c1) \n\ud835\udc9c\u2032\u27e6 \u019b \u03b1 \u2423 M  \u27e7 \u03c1 = \u03bb x \u2192 \ud835\udc9c\u2032\u27e6 M \u27e7 (\u03c1 [ x / \u03b1 ])\n</pre>"},{"location":"md/PCF/Types/","title":"PCF.Types","text":"<pre>\nmodule PCF.Types where\n\nopen import Data.Bool.Base \n  using (Bool)\nopen import Agda.Builtin.Nat\n  using (Nat)\n\nopen import PCF.Domain-Notation\n  using (_+\u22a5)\n\n-- Syntax\n\ndata Types : Set where\n  \u03b9    : Types                  -- natural numbers\n  o    : Types                  -- Boolean truthvalues\n  _\u21d2_  : Types \u2192 Types \u2192 Types  -- functions\n\nvariable \u03c3 \u03c4 : Types\n\ninfixr 1 _\u21d2_\n\n-- Semantics \ud835\udc9f\n\n\ud835\udc9f : Types \u2192 Set  -- Set should be a sort of domains\n\n\ud835\udc9f \u03b9        = Nat  +\u22a5\n\ud835\udc9f o        = Bool +\u22a5\n\ud835\udc9f (\u03c3 \u21d2 \u03c4)  = \ud835\udc9f \u03c3 \u2192 \ud835\udc9f \u03c4\n\nvariable x y z : \ud835\udc9f \u03c3\n</pre>"},{"location":"md/PCF/Variables/","title":"PCF.Variables","text":"<pre>\nmodule PCF.Variables where\n\nopen import Agda.Builtin.Nat\n  using (Nat)\n\nopen import PCF.Types\n  using (Types; \u03c3; \ud835\udc9f)\n\n-- Syntax\n\ndata \ud835\udcb1 : Types \u2192 Set where\n  var : Nat \u2192 (\u03c3 : Types) \u2192 \ud835\udcb1 \u03c3\n\nvariable \u03b1 : \ud835\udcb1 \u03c3\n\n-- Environments\n\nEnv = \u2200 {\u03c3} \u2192 \ud835\udcb1 \u03c3 \u2192 \ud835\udc9f \u03c3\n\nvariable \u03c1 : Env\n\n-- Semantics\n\n_\u27e6_\u27e7 : Env \u2192 \ud835\udcb1 \u03c3 \u2192 \ud835\udc9f \u03c3\n\n\u03c1 \u27e6 \u03b1 \u27e7 = \u03c1 \u03b1\n</pre>"},{"location":"md/PCF/index/","title":"PCF.index","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\n\nmodule PCF.index where\n\nimport PCF.Domain-Notation\nimport PCF.Types\nimport PCF.Constants\nimport PCF.Variables\nimport PCF.Environments\nimport PCF.Terms\nimport PCF.Checks\n</pre>"},{"location":"md/Relation/Binary/Bundles/","title":"Relation.Binary.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Bundles where\n\nopen import Function.Base using (flip)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles.Raw using (RawRelation; RawSetoid)\nopen import Relation.Binary.Structures -- most of it\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\n------------------------------------------------------------------------\n-- Setoids\n------------------------------------------------------------------------\n\nrecord PartialSetoid a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier              : Set a\n    _\u2248_                  : Rel Carrier \u2113\n    isPartialEquivalence : IsPartialEquivalence _\u2248_\n\n  open IsPartialEquivalence isPartialEquivalence public\n\n  rawSetoid : RawSetoid _ _\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public\n    hiding (Carrier; _\u2248_ )\n\n\nrecord Setoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier       : Set c\n    _\u2248_           : Rel Carrier \u2113\n    isEquivalence : IsEquivalence _\u2248_\n\n  open IsEquivalence isEquivalence public\n    using (refl; reflexive; isPartialEquivalence)\n\n  partialSetoid : PartialSetoid c \u2113\n  partialSetoid = record\n    { isPartialEquivalence = isPartialEquivalence\n    }\n\n  open PartialSetoid partialSetoid public\n    hiding (Carrier; _\u2248_; isPartialEquivalence)\n\n\nrecord DecSetoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\n    isDecEquivalence : IsDecEquivalence _\u2248_\n\n  open IsDecEquivalence isDecEquivalence public\n    using (_\u225f_; isEquivalence)\n\n  setoid : Setoid c \u2113\n  setoid = record\n    { isEquivalence = isEquivalence\n    }\n\n  open Setoid setoid public\n    hiding (Carrier; _\u2248_; isEquivalence)\n\n------------------------------------------------------------------------\n-- Preorders\n------------------------------------------------------------------------\n\nrecord Preorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2272_\n  field\n    Carrier    : Set c\n    _\u2248_        : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_        : Rel Carrier \u2113\u2082  -- The relation.\n    isPreorder : IsPreorder _\u2248_ _\u2272_\n\n  open IsPreorder isPreorder public\n    hiding (module Eq)\n\n  module Eq where\n    setoid : Setoid c \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\n      }\n\n    open Setoid setoid public\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _\u2272_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u22e6_; _\u223c\u1d52_ to _\u2273_; _\u2241\u1d52_ to _\u22e7_)\n    hiding (Carrier; _\u2248_)\n  -- Deprecated.\n  {-# WARNING_ON_USAGE _\u223c_\n  \"Warning: _\u223c_ was deprecated in v2.0.\n  Please use _\u2272_ instead. \"\n  #-}\n\n\nrecord TotalPreorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2272_\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_             : Rel Carrier \u2113\u2082  -- The relation.\n    isTotalPreorder : IsTotalPreorder _\u2248_ _\u2272_\n\n  open IsTotalPreorder isTotalPreorder public\n    using (total; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder)\n\n\nrecord DecPreorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_             : Rel Carrier \u2113\u2082  -- The relation.\n    isDecPreorder   : IsDecPreorder _\u2248_ _\u2272_\n\n  private module DPO = IsDecPreorder isDecPreorder\n\n  open DPO public\n    using (_\u225f_; _\u2272?_; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder; module Eq)\n\n  module Eq where\n    decSetoid : DecSetoid c \u2113\u2081\n    decSetoid = record\n      { isDecEquivalence = DPO.Eq.isDecEquivalence\n      }\n\n    open DecSetoid decSetoid public\n\n\n------------------------------------------------------------------------\n-- Partial orders\n------------------------------------------------------------------------\n\nrecord Poset c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier        : Set c\n    _\u2248_            : Rel Carrier \u2113\u2081\n    _\u2264_            : Rel Carrier \u2113\u2082\n    isPartialOrder : IsPartialOrder _\u2248_ _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n    using (antisym; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder; _\u22e6_; _\u2273_; _\u22e7_)\n    renaming\n    ( \u2272-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n    ; \u2272-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n    ; \u2272-resp-\u2248  to \u2264-resp-\u2248\n    )\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u2270_; _\u223c\u1d52_ to _\u2265_; _\u2241\u1d52_ to _\u2271_)\n    hiding (Carrier; _\u2248_ ; _\u223c_; _\u2249_; rawSetoid)\n\n\nrecord DecPoset c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\u2081\n    _\u2264_               : Rel Carrier \u2113\u2082\n    isDecPartialOrder : IsDecPartialOrder _\u2248_ _\u2264_\n\n  private module DPO = IsDecPartialOrder isDecPartialOrder\n\n  open DPO public\n    using (_\u225f_; _\u2264?_; isPartialOrder; isDecPreorder)\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record\n    { isPartialOrder = isPartialOrder\n    }\n\n  open Poset poset public\n    hiding (Carrier; _\u2248_; _\u2264_; isPartialOrder; module Eq)\n\n  decPreorder : DecPreorder c \u2113\u2081 \u2113\u2082\n  decPreorder = record { isDecPreorder = isDecPreorder }\n\n  open DecPreorder decPreorder public\n    using (module Eq)\n\n\nrecord StrictPartialOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier              : Set c\n    _\u2248_                  : Rel Carrier \u2113\u2081\n    _&lt;_                  : Rel Carrier \u2113\u2082\n    isStrictPartialOrder : IsStrictPartialOrder _\u2248_ _&lt;_\n\n  open IsStrictPartialOrder isStrictPartialOrder public\n    hiding (module Eq)\n\n  module Eq where\n    setoid : Setoid c \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\n      }\n\n    open Setoid setoid public\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _&lt;_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u226e_; _\u223c\u1d52_ to _&gt;_; _\u2241\u1d52_ to _\u226f_)\n    hiding (Carrier; _\u2248_ ; _\u223c_)\n\n\nrecord DecStrictPartialOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier                 : Set c\n    _\u2248_                     : Rel Carrier \u2113\u2081\n    _&lt;_                     : Rel Carrier \u2113\u2082\n    isDecStrictPartialOrder : IsDecStrictPartialOrder _\u2248_ _&lt;_\n\n  private module DSPO = IsDecStrictPartialOrder isDecStrictPartialOrder\n\n  open DSPO public\n    using (_&lt;?_; _\u225f_; isStrictPartialOrder)\n\n  strictPartialOrder : StrictPartialOrder c \u2113\u2081 \u2113\u2082\n  strictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    }\n\n  open StrictPartialOrder strictPartialOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictPartialOrder; module Eq)\n\n  module Eq where\n\n    decSetoid : DecSetoid c \u2113\u2081\n    decSetoid = record\n      { isDecEquivalence = DSPO.Eq.isDecEquivalence\n      }\n\n    open DecSetoid decSetoid public\n\n\n------------------------------------------------------------------------\n-- Total orders\n------------------------------------------------------------------------\n\nrecord TotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier      : Set c\n    _\u2248_          : Rel Carrier \u2113\u2081\n    _\u2264_          : Rel Carrier \u2113\u2082\n    isTotalOrder : IsTotalOrder _\u2248_ _\u2264_\n\n  open IsTotalOrder isTotalOrder public\n    using (total; isPartialOrder; isTotalPreorder)\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record\n    { isPartialOrder = isPartialOrder\n    }\n\n  open Poset poset public\n    hiding (Carrier; _\u2248_; _\u2264_; isPartialOrder)\n\n  totalPreorder : TotalPreorder c \u2113\u2081 \u2113\u2082\n  totalPreorder = record\n    { isTotalPreorder = isTotalPreorder\n    }\n\n\nrecord DecTotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081\n    _\u2264_             : Rel Carrier \u2113\u2082\n    isDecTotalOrder : IsDecTotalOrder _\u2248_ _\u2264_\n\n  private module DTO = IsDecTotalOrder isDecTotalOrder\n\n  open DTO public\n    using (_\u225f_; _\u2264?_; isTotalOrder; isDecPartialOrder)\n\n  totalOrder : TotalOrder c \u2113\u2081 \u2113\u2082\n  totalOrder = record\n    { isTotalOrder = isTotalOrder\n    }\n\n  open TotalOrder totalOrder public\n    hiding (Carrier; _\u2248_; _\u2264_; isTotalOrder; module Eq)\n\n  decPoset : DecPoset c \u2113\u2081 \u2113\u2082\n  decPoset = record\n    { isDecPartialOrder = isDecPartialOrder\n    }\n\n  open DecPoset decPoset public\n    using (module Eq)\n\n\n-- Note that these orders are decidable. The current implementation\n-- of `Trichotomous` subsumes irreflexivity and asymmetry. Any reasonable\n-- definition capturing these three properties implies decidability\n-- as `Trichotomous` necessarily separates out the equality case.\n\nrecord StrictTotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\u2081\n    _&lt;_                : Rel Carrier \u2113\u2082\n    isStrictTotalOrder : IsStrictTotalOrder _\u2248_ _&lt;_\n\n  open IsStrictTotalOrder isStrictTotalOrder public\n    using\n    ( _\u225f_; _&lt;?_; compare; isStrictPartialOrder\n    ; isDecStrictPartialOrder; isDecEquivalence\n    )\n\n  strictPartialOrder : StrictPartialOrder c \u2113\u2081 \u2113\u2082\n  strictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    }\n\n  open StrictPartialOrder strictPartialOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictPartialOrder; module Eq)\n\n  decStrictPartialOrder : DecStrictPartialOrder c \u2113\u2081 \u2113\u2082\n  decStrictPartialOrder = record\n    { isDecStrictPartialOrder = isDecStrictPartialOrder\n    }\n\n  open DecStrictPartialOrder decStrictPartialOrder public\n    using (module Eq)\n\n  decSetoid : DecSetoid c \u2113\u2081\n  decSetoid = record\n    { isDecEquivalence = Eq.isDecEquivalence\n    }\n  {-# WARNING_ON_USAGE decSetoid\n  \"Warning: decSetoid was deprecated in v1.3.\n  Please use Eq.decSetoid instead.\"\n  #-}\n\n\nrecord DenseLinearOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\u2081\n    _&lt;_                : Rel Carrier \u2113\u2082\n    isDenseLinearOrder : IsDenseLinearOrder _\u2248_ _&lt;_\n\n  open IsDenseLinearOrder isDenseLinearOrder public\n    using (isStrictTotalOrder; dense)\n\n  strictTotalOrder : StrictTotalOrder c \u2113\u2081 \u2113\u2082\n  strictTotalOrder = record\n    { isStrictTotalOrder = isStrictTotalOrder\n    }\n\n  open StrictTotalOrder strictTotalOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictTotalOrder)\n\n\n------------------------------------------------------------------------\n-- Apartness relations\n------------------------------------------------------------------------\n\nrecord ApartnessRelation c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _#_\n  field\n    Carrier             : Set c\n    _\u2248_                 : Rel Carrier \u2113\u2081\n    _#_                 : Rel Carrier \u2113\u2082\n    isApartnessRelation : IsApartnessRelation _\u2248_ _#_\n\n  open IsApartnessRelation isApartnessRelation public\n    hiding (_\u00ac#_)\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _#_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u00ac#_; _\u223c\u1d52_ to _#\u1d52_; _\u2241\u1d52_ to _\u00ac#\u1d52_)\n    hiding (Carrier; _\u2248_ ; _\u223c_)\n\n</pre>"},{"location":"md/Relation/Binary/Bundles/Raw/","title":"Relation.Binary.Bundles.Raw","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Raw bundles for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Bundles.Raw where\n\nopen import Function.Base using (flip)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\n\n------------------------------------------------------------------------\n-- RawSetoid\n------------------------------------------------------------------------\n\nrecord RawSetoid a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier              : Set a\n    _\u2248_                  : Rel Carrier \u2113\n\n  infix 4 _\u2249_\n  _\u2249_ : Rel Carrier _\n  x \u2249 y = \u00ac (x \u2248 y)\n\n\n------------------------------------------------------------------------\n-- RawRelation: basis for Relation.Binary.Bundles.*Order\n------------------------------------------------------------------------\n\nrecord RawRelation c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u223c_\n  field\n    Carrier    : Set c\n    _\u2248_        : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u223c_        : Rel Carrier \u2113\u2082  -- The underlying relation.\n\n  rawSetoid : RawSetoid c \u2113\u2081\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public\n    using (_\u2249_)\n\n  infix 4 _\u2241_\n  _\u2241_ : Rel Carrier _\n  x \u2241 y = \u00ac (x \u223c y)\n\n  infix 4 _\u223c\u1d52_\n  _\u223c\u1d52_ = flip _\u223c_\n\n  infix 4 _\u2241\u1d52_\n  _\u2241\u1d52_ = flip _\u2241_\n\n</pre>"},{"location":"md/Relation/Binary/Consequences/","title":"Relation.Binary.Consequences","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some properties imply others\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Consequences where\n\nopen import Data.Product.Base using (_,_)\nopen import Data.Sum.Base as Sum using (inj\u2081; inj\u2082; [_,_]\u2032)\nopen import Function.Base using (_\u2218_; _\u2218\u2082_; _$_; flip)\nopen import Level using (Level)\nopen import Relation.Binary.Core\nopen import Relation.Binary.Definitions\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Nullary.Decidable.Core\n  using (yes; no; recompute; map\u2032; dec\u21d2maybe)\nopen import Relation.Unary using (\u2201; Pred)\n\nprivate\n  variable\n    a \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 \u2113\u2084 p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Substitutive properties\n\nmodule _ {_\u223c_ : Rel A \u2113} (R : Rel A p) where\n\n  subst\u21d2resp\u02e1 : Substitutive _\u223c_ p \u2192 R Respects\u02e1 _\u223c_\n  subst\u21d2resp\u02e1 subst {y} x\u2032\u223cx Px\u2032y = subst (flip R y) x\u2032\u223cx Px\u2032y\n\n  subst\u21d2resp\u02b3 : Substitutive _\u223c_ p \u2192 R Respects\u02b3 _\u223c_\n  subst\u21d2resp\u02b3 subst {x} y\u2032\u223cy Pxy\u2032 = subst (R x) y\u2032\u223cy Pxy\u2032\n\n  subst\u21d2resp\u2082 : Substitutive _\u223c_ p \u2192 R Respects\u2082 _\u223c_\n  subst\u21d2resp\u2082 subst = subst\u21d2resp\u02b3 subst , subst\u21d2resp\u02e1 subst\n\nmodule _ {_\u223c_ : Rel A \u2113} {P : Pred A p} where\n\n  resp\u21d2\u00ac-resp : Symmetric _\u223c_ \u2192 P Respects _\u223c_ \u2192 (\u2201 P) Respects _\u223c_\n  resp\u21d2\u00ac-resp sym resp x\u223cy \u00acPx Py = \u00acPx (resp (sym x\u223cy) Py)\n\n------------------------------------------------------------------------\n-- Proofs for negation\n\nmodule _ {_\u223c_ : Rel A \u2113} where\n\n  sym\u21d2\u00ac-sym : Symmetric _\u223c_ \u2192 Symmetric (\u00ac_ \u2218\u2082 _\u223c_)\n  sym\u21d2\u00ac-sym sym\u2241 x\u2241y y\u223cx = x\u2241y (sym\u2241 y\u223cx)\n\n  -- N.B. the implicit arguments to Cotransitive are permuted w.r.t.\n  -- those of Transitive\n  cotrans\u21d2\u00ac-trans : Cotransitive _\u223c_ \u2192 Transitive (\u00ac_ \u2218\u2082 _\u223c_)\n  cotrans\u21d2\u00ac-trans cotrans {j = z} x\u2241z z\u2241y x\u223cy =\n    [ x\u2241z , z\u2241y ]\u2032 (cotrans x\u223cy z)\n\n------------------------------------------------------------------------\n-- Proofs for Irreflexive relations\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_\u223c_ : Rel A \u2113\u2082} where\n\n  irrefl\u21d2\u00ac-refl : Reflexive _\u2248_ \u2192 Irreflexive _\u2248_ _\u223c_ \u2192\n                  Reflexive (\u00ac_ \u2218\u2082 _\u223c_)\n  irrefl\u21d2\u00ac-refl re irr = irr re\n\n------------------------------------------------------------------------\n-- Proofs for non-strict orders\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_\u2264_ : Rel A \u2113\u2082} where\n\n  total\u21d2refl : _\u2264_ Respects\u2082 _\u2248_ \u2192 Symmetric _\u2248_ \u2192\n               Total _\u2264_ \u2192 _\u2248_ \u21d2 _\u2264_\n  total\u21d2refl (resp\u02b3 , resp\u02e1) sym total {x} {y} x\u2248y with total x y\n  ... | inj\u2081 x\u223cy = x\u223cy\n  ... | inj\u2082 y\u223cx = resp\u02b3 x\u2248y (resp\u02e1 (sym x\u2248y) y\u223cx)\n\n  total\u2227dec\u21d2dec : _\u2248_ \u21d2 _\u2264_ \u2192 Antisymmetric _\u2248_ _\u2264_ \u2192\n                  Total _\u2264_ \u2192 Decidable _\u2248_ \u2192 Decidable _\u2264_\n  total\u2227dec\u21d2dec refl antisym total _\u225f_ x y with total x y\n  ... | inj\u2081 x\u2264y = yes x\u2264y\n  ... | inj\u2082 y\u2264x = map\u2032 refl (flip antisym y\u2264x) (x \u225f y)\n\nmodule _ (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) {\u2264\u2081 : Rel A \u2113\u2083} {\u2264\u2082 : Rel B \u2113\u2084} where\n\n  mono\u21d2cong : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192\n              \u2200 {f} \u2192 Monotonic\u2081 \u2264\u2081 \u2264\u2082 f \u2192 Monotonic\u2081 \u2248\u2081 \u2248\u2082 f\n  mono\u21d2cong sym reflexive antisym mono x\u2248y = antisym\n    (mono (reflexive x\u2248y))\n    (mono (reflexive (sym x\u2248y)))\n\n  antimono\u21d2cong : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192\n                  \u2200 {f} \u2192 f Preserves \u2264\u2081 \u27f6 (flip \u2264\u2082) \u2192 Monotonic\u2081 \u2248\u2081 \u2248\u2082 f\n  antimono\u21d2cong sym reflexive antisym antimono p\u2248q = antisym\n    (antimono (reflexive (sym p\u2248q)))\n    (antimono (reflexive p\u2248q))\n\n  mono\u2082\u21d2cong\u2082 : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192\n                \u2200 {f} \u2192 Monotonic\u2082 \u2264\u2081 \u2264\u2081 \u2264\u2082 f \u2192 Monotonic\u2082 \u2248\u2081 \u2248\u2081 \u2248\u2082 f\n  mono\u2082\u21d2cong\u2082 sym reflexive antisym mono x\u2248y u\u2248v = antisym\n    (mono (reflexive x\u2248y) (reflexive u\u2248v))\n    (mono (reflexive (sym x\u2248y)) (reflexive (sym u\u2248v)))\n\nmodule _ (\u2264\u2081 : Rel A \u2113\u2081) (\u2264\u2082 : Rel B \u2113\u2082) (\u2264\u2083 : Rel C \u2113\u2082) where\n\n  mono\u2082\u21d2mono\u02e1 : \u2200 {f} \u2192 Reflexive \u2264\u2081 \u2192\n                Monotonic\u2082 \u2264\u2081 \u2264\u2082 \u2264\u2083 f \u2192 LeftMonotonic \u2264\u2082 \u2264\u2083 f\n  mono\u2082\u21d2mono\u02e1 refl mono x = mono (refl {x = x})\n\n  mono\u2082\u21d2mono\u02b3 : \u2200 {f} \u2192 Reflexive \u2264\u2082 \u2192\n                Monotonic\u2082 \u2264\u2081 \u2264\u2082 \u2264\u2083 f \u2192 RightMonotonic \u2264\u2081 \u2264\u2083 f\n  mono\u2082\u21d2mono\u02b3 refl mono y = flip mono (refl {x = y})\n\n  mono\u02e1\u2227mono\u02b3\u21d2mono\u2082 : \u2200 {f} \u2192 Transitive \u2264\u2083 \u2192\n                      LeftMonotonic \u2264\u2082 \u2264\u2083 f \u2192 RightMonotonic \u2264\u2081 \u2264\u2083 f \u2192\n                      Monotonic\u2082 \u2264\u2081 \u2264\u2082 \u2264\u2083 f\n  mono\u02e1\u2227mono\u02b3\u21d2mono\u2082 trans mono\u02e1 mono\u02b3 x\u2264\u2081y u\u2264\u2082v =\n    trans (mono\u02e1 _ u\u2264\u2082v) (mono\u02b3 _ x\u2264\u2081y)\n\n------------------------------------------------------------------------\n-- Proofs for strict orders\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_&lt;_ : Rel A \u2113\u2082} where\n\n  trans\u2227irr\u21d2asym : Reflexive _\u2248_ \u2192 Transitive _&lt;_ \u2192\n                   Irreflexive _\u2248_ _&lt;_ \u2192 Asymmetric _&lt;_\n  trans\u2227irr\u21d2asym refl trans irrefl x&lt;y y&lt;x =\n    irrefl refl (trans x&lt;y y&lt;x)\n\n  irr\u2227antisym\u21d2asym : Irreflexive _\u2248_ _&lt;_ \u2192 Antisymmetric _\u2248_ _&lt;_ \u2192\n                     Asymmetric _&lt;_\n  irr\u2227antisym\u21d2asym irrefl antisym x&lt;y y&lt;x =\n    irrefl (antisym x&lt;y y&lt;x) x&lt;y\n\n  asym\u21d2antisym : Asymmetric _&lt;_ \u2192 Antisymmetric _\u2248_ _&lt;_\n  asym\u21d2antisym asym x&lt;y y&lt;x = contradiction y&lt;x (asym x&lt;y)\n\n  asym\u21d2irr : _&lt;_ Respects\u2082 _\u2248_ \u2192 Symmetric _\u2248_ \u2192\n             Asymmetric _&lt;_ \u2192 Irreflexive _\u2248_ _&lt;_\n  asym\u21d2irr (resp\u02b3 , resp\u02e1) sym asym {x} {y} x\u2248y x&lt;y =\n    asym x&lt;y (resp\u02b3 (sym x\u2248y) (resp\u02e1 x\u2248y x&lt;y))\n\n  tri\u21d2asym : Trichotomous _\u2248_ _&lt;_ \u2192 Asymmetric _&lt;_\n  tri\u21d2asym tri {x} {y} x&lt;y x&gt;y with tri x y\n  ... | tri&lt; _   _ x\u226fy = x\u226fy x&gt;y\n  ... | tri\u2248 _   _ x\u226fy = x\u226fy x&gt;y\n  ... | tri&gt; x\u226ey _ _   = x\u226ey x&lt;y\n\n  tri\u21d2irr : Trichotomous _\u2248_ _&lt;_ \u2192 Irreflexive _\u2248_ _&lt;_\n  tri\u21d2irr compare {x} {y} x\u2248y x&lt;y with compare x y\n  ... | tri&lt; _   x\u2249y y\u226ex = x\u2249y x\u2248y\n  ... | tri&gt; x\u226ey x\u2249y y&lt;x = x\u2249y x\u2248y\n  ... | tri\u2248 x\u226ey _   y\u226ex = x\u226ey x&lt;y\n\n  tri\u21d2dec\u2248 : Trichotomous _\u2248_ _&lt;_ \u2192 Decidable _\u2248_\n  tri\u21d2dec\u2248 compare x y with compare x y\n  ... | tri&lt; _ x\u2249y _ = no  x\u2249y\n  ... | tri\u2248 _ x\u2248y _ = yes x\u2248y\n  ... | tri&gt; _ x\u2249y _ = no  x\u2249y\n\n  tri\u21d2dec&lt; : Trichotomous _\u2248_ _&lt;_ \u2192 Decidable _&lt;_\n  tri\u21d2dec&lt; compare x y with compare x y\n  ... | tri&lt; x&lt;y _ _ = yes x&lt;y\n  ... | tri\u2248 x\u226ey _ _ = no  x\u226ey\n  ... | tri&gt; x\u226ey _ _ = no  x\u226ey\n\n  trans\u2227tri\u21d2resp\u02b3 : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192\n                    Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                    _&lt;_ Respects\u02b3 _\u2248_\n  trans\u2227tri\u21d2resp\u02b3 sym \u2248-tr &lt;-tr tri {x} {y} {z} y\u2248z x&lt;y with tri x z\n  ... | tri&lt; x&lt;z _ _ = x&lt;z\n  ... | tri\u2248 _ x\u2248z _ = contradiction x&lt;y (tri\u21d2irr tri (\u2248-tr x\u2248z (sym y\u2248z)))\n  ... | tri&gt; _ _ z&lt;x = contradiction (&lt;-tr z&lt;x x&lt;y) (tri\u21d2irr tri (sym y\u2248z))\n\n  trans\u2227tri\u21d2resp\u02e1 : Transitive _\u2248_ \u2192\n                    Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                    _&lt;_ Respects\u02e1 _\u2248_\n  trans\u2227tri\u21d2resp\u02e1 \u2248-tr &lt;-tr tri {z} {_} {y} x\u2248y x&lt;z with tri y z\n  ... | tri&lt; y&lt;z _ _ = y&lt;z\n  ... | tri\u2248 _ y\u2248z _ = contradiction x&lt;z (tri\u21d2irr tri (\u2248-tr x\u2248y y\u2248z))\n  ... | tri&gt; _ _ z&lt;y = contradiction (&lt;-tr x&lt;z z&lt;y) (tri\u21d2irr tri x\u2248y)\n\n  trans\u2227tri\u21d2resp : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192\n                   Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                   _&lt;_ Respects\u2082 _\u2248_\n  trans\u2227tri\u21d2resp sym \u2248-tr &lt;-tr tri =\n    trans\u2227tri\u21d2resp\u02b3 sym \u2248-tr &lt;-tr tri ,\n    trans\u2227tri\u21d2resp\u02e1 \u2248-tr &lt;-tr tri\n\n------------------------------------------------------------------------\n-- Without Loss of Generality\n\nmodule _  {_R_ : Rel A \u2113\u2081} {Q : Rel A \u2113\u2082} where\n\n  wlog : Total _R_ \u2192 Symmetric Q \u2192\n         (\u2200 a b \u2192 a R b \u2192 Q a b) \u2192\n         \u2200 a b \u2192 Q a b\n  wlog r-total q-sym prf a b with r-total a b\n  ... | inj\u2081 aRb = prf a b aRb\n  ... | inj\u2082 bRa = q-sym (prf b a bRa)\n\n------------------------------------------------------------------------\n-- Other proofs\n\nmodule _ {R : REL A B p} where\n\n  dec\u21d2weaklyDec : Decidable R \u2192 WeaklyDecidable R\n  dec\u21d2weaklyDec dec x y = dec\u21d2maybe (dec x y)\n\n  dec\u21d2recomputable : Decidable R \u2192 Recomputable R\n  dec\u21d2recomputable dec {a} {b} = recompute $ dec a b\n\nmodule _ {R : REL A B \u2113\u2081} {S : REL A B \u2113\u2082} where\n\n  map-NonEmpty : R \u21d2 S \u2192 NonEmpty R \u2192 NonEmpty S\n  map-NonEmpty f x = nonEmpty (f (NonEmpty.proof x))\n\nmodule _ {R : REL A B \u2113\u2081} {S : REL B A \u2113\u2082} where\n\n  flip-Connex : Connex R S \u2192 Connex S R\n  flip-Connex f x y = Sum.swap (f y x)\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.6\n\nsubst\u27f6resp\u02e1 = subst\u21d2resp\u02e1\n{-# WARNING_ON_USAGE subst\u27f6resp\u02e1\n\"Warning: subst\u27f6resp\u02e1 was deprecated in v1.6.\nPlease use subst\u21d2resp\u02e1 instead.\"\n#-}\nsubst\u27f6resp\u02b3 = subst\u21d2resp\u02b3\n{-# WARNING_ON_USAGE subst\u27f6resp\u02b3\n\"Warning: subst\u27f6resp\u02b3 was deprecated in v1.6.\nPlease use subst\u21d2resp\u02b3 instead.\"\n#-}\nsubst\u27f6resp\u2082 = subst\u21d2resp\u2082\n{-# WARNING_ON_USAGE subst\u27f6resp\u2082\n\"Warning: subst\u27f6resp\u2082 was deprecated in v1.6.\nPlease use subst\u21d2resp\u2082 instead.\"\n#-}\nP-resp\u27f6\u00acP-resp = resp\u21d2\u00ac-resp\n{-# WARNING_ON_USAGE P-resp\u27f6\u00acP-resp\n\"Warning: P-resp\u27f6\u00acP-resp was deprecated in v1.6.\nPlease use resp\u21d2\u00ac-resp instead.\"\n#-}\ntotal\u27f6refl = total\u21d2refl\n{-# WARNING_ON_USAGE total\u27f6refl\n\"Warning: total\u27f6refl was deprecated in v1.6.\nPlease use total\u21d2refl instead.\"\n#-}\ntotal+dec\u27f6dec = total\u2227dec\u21d2dec\n{-# WARNING_ON_USAGE total+dec\u27f6dec\n\"Warning: total+dec\u27f6dec was deprecated in v1.6.\nPlease use total\u2227dec\u21d2dec instead.\"\n#-}\ntrans\u2227irr\u27f6asym = trans\u2227irr\u21d2asym\n{-# WARNING_ON_USAGE trans\u2227irr\u27f6asym\n\"Warning: trans\u2227irr\u27f6asym was deprecated in v1.6.\nPlease use trans\u2227irr\u21d2asym instead.\"\n#-}\nirr\u2227antisym\u27f6asym = irr\u2227antisym\u21d2asym\n{-# WARNING_ON_USAGE irr\u2227antisym\u27f6asym\n\"Warning: irr\u2227antisym\u27f6asym was deprecated in v1.6.\nPlease use irr\u2227antisym\u21d2asym instead.\"\n#-}\nasym\u27f6antisym = asym\u21d2antisym\n{-# WARNING_ON_USAGE asym\u27f6antisym\n\"Warning: asym\u27f6antisym was deprecated in v1.6.\nPlease use asym\u21d2antisym instead.\"\n#-}\nasym\u27f6irr = asym\u21d2irr\n{-# WARNING_ON_USAGE asym\u27f6irr\n\"Warning: asym\u27f6irr was deprecated in v1.6.\nPlease use asym\u21d2irr instead.\"\n#-}\ntri\u27f6asym = tri\u21d2asym\n{-# WARNING_ON_USAGE tri\u27f6asym\n\"Warning: tri\u27f6asym was deprecated in v1.6.\nPlease use tri\u21d2asym instead.\"\n#-}\ntri\u27f6irr = tri\u21d2irr\n{-# WARNING_ON_USAGE tri\u27f6irr\n\"Warning: tri\u27f6irr was deprecated in v1.6.\nPlease use tri\u21d2irr instead.\"\n#-}\ntri\u27f6dec\u2248 = tri\u21d2dec\u2248\n{-# WARNING_ON_USAGE tri\u27f6dec\u2248\n\"Warning: tri\u27f6dec\u2248 was deprecated in v1.6.\nPlease use tri\u21d2dec\u2248 instead.\"\n#-}\ntri\u27f6dec&lt; = tri\u21d2dec&lt;\n{-# WARNING_ON_USAGE tri\u27f6dec&lt;\n\"Warning: tri\u27f6dec&lt; was deprecated in v1.6.\nPlease use tri\u21d2dec&lt; instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u02b3\u2248 = trans\u2227tri\u21d2resp\u02b3\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u02b3\u2248\n\"Warning: trans\u2227tri\u27f6resp\u02b3\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp\u02b3 instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u02e1\u2248 = trans\u2227tri\u21d2resp\u02e1\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u02e1\u2248\n\"Warning: trans\u2227tri\u27f6resp\u02e1\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp\u02e1 instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u2248 = trans\u2227tri\u21d2resp\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u2248\n\"Warning: trans\u2227tri\u27f6resp\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp instead.\"\n#-}\ndec\u27f6weaklyDec = dec\u21d2weaklyDec\n{-# WARNING_ON_USAGE dec\u27f6weaklyDec\n\"Warning: dec\u27f6weaklyDec was deprecated in v1.6.\nPlease use dec\u21d2weaklyDec instead.\"\n#-}\ndec\u27f6recomputable = dec\u21d2recomputable\n{-# WARNING_ON_USAGE dec\u27f6recomputable\n\"Warning: dec\u27f6recomputable was deprecated in v1.6.\nPlease use dec\u21d2recomputable instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Construct/Closure/Reflexive/","title":"Relation.Binary.Construct.Closure.Reflexive","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Reflexive closures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Closure.Reflexive where\n\nopen import Data.Unit.Base\nopen import Level\nopen import Function.Base using (_\u220b_)\nopen import Relation.Binary.Core using (Rel; _=[_]\u21d2_; _\u21d2_)\nopen import Relation.Binary.Definitions using (Reflexive)\nopen import Relation.Binary.Construct.Constant.Core using (Const)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_ ; refl)\n\nprivate\n  variable\n    a \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Definition\n\ndata ReflClosure {A : Set a} (_\u223c_ : Rel A \u2113) : Rel A (a \u2294 \u2113) where\n  refl : Reflexive (ReflClosure _\u223c_)\n  [_]  : \u2200 {x y} (x\u223cy : x \u223c y) \u2192 ReflClosure _\u223c_ x y\n\n------------------------------------------------------------------------\n-- Operations\n\nmap : \u2200 {R : Rel A \u2113\u2081} {S : Rel B \u2113\u2082} {f : A \u2192 B} \u2192\n      R =[ f ]\u21d2 S \u2192 ReflClosure R =[ f ]\u21d2 ReflClosure S\nmap R\u21d2S [ xRy ] = [ R\u21d2S xRy ]\nmap R\u21d2S refl    = refl\n\n------------------------------------------------------------------------\n-- Properties\n\n-- The reflexive closure has no effect on reflexive relations.\ndrop-refl : {R : Rel A \u2113} \u2192 Reflexive R \u2192 ReflClosure R \u21d2 R\ndrop-refl rfl [ xRy ] = xRy\ndrop-refl rfl refl    = rfl\n\nreflexive : {R : Rel A \u2113} \u2192 _\u2261_ \u21d2 ReflClosure R\nreflexive refl = refl\n\n[]-injective : {R : Rel A \u2113} \u2192 \u2200 {x y p q} \u2192\n               (ReflClosure R x y \u220b [ p ]) \u2261 [ q ] \u2192 p \u2261 q\n[]-injective refl = refl\n\n------------------------------------------------------------------------\n-- Example usage\n\nprivate\n  module Maybe where\n    Maybe : Set a \u2192 Set a\n    Maybe A = ReflClosure (Const A) tt tt\n\n    nothing : Maybe A\n    nothing = refl\n\n    just : A \u2192 Maybe A\n    just = [_]\n\n\n\n------------------------------------------------------------------------\n-- Deprecations\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- v1.5\n\nRefl = ReflClosure\n{-# WARNING_ON_USAGE Refl\n\"Warning: Refl was deprecated in v1.5.\nPlease use ReflClosure instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Construct/Composition/","title":"Relation.Binary.Construct.Composition","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Composition of two binary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Composition where\n\nopen import Data.Product.Base using (\u2203; _\u00d7_; _,_)\nopen import Function.Base using (_\u2218_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Core using (Rel; REL; _\u21d2_)\nopen import Relation.Binary.Structures using (IsPreorder)\nopen import Relation.Binary.Definitions\n  using (_Respects_; _Respects\u02b3_; _Respects\u02e1_; _Respects\u2082_\n        ; Reflexive; Transitive)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 9 _\u037e_\n\n_\u037e_ : {A : Set a} {B : Set b} {C : Set c} \u2192\n      REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C (b \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nL \u037e R = \u03bb i j \u2192 \u2203 \u03bb k \u2192 L i k \u00d7 R k j\n\n------------------------------------------------------------------------\n-- Properties\n\nmodule _ (L : Rel A \u2113\u2081) (R : Rel A \u2113\u2082) where\n\n  reflexive : Reflexive L \u2192 Reflexive R \u2192 Reflexive (L \u037e R)\n  reflexive L-refl R-refl = _ , L-refl , R-refl\n\n  respects : \u2200 {p} {P : A \u2192 Set p} \u2192\n             P Respects L \u2192 P Respects R \u2192 P Respects (L \u037e R)\n  respects resp-L resp-R (k , Lik , Rkj) = resp-R Rkj \u2218 resp-L Lik\n\nmodule _ {\u2248 : Rel A \u2113} (L : REL A B \u2113\u2081) (R : REL B C \u2113\u2082) where\n\n  respects\u02e1 : L Respects\u02e1 \u2248 \u2192 (L \u037e R) Respects\u02e1 \u2248\n  respects\u02e1 L\u02e1 i\u2248i\u2032 (k , Lik , Rkj) = k , L\u02e1 i\u2248i\u2032 Lik , Rkj\n\nmodule _ {\u2248 : Rel C \u2113} (L : REL A B \u2113\u2081) (R : REL B C \u2113\u2082) where\n\n  respects\u02b3 : R Respects\u02b3 \u2248 \u2192 (L \u037e R) Respects\u02b3 \u2248\n  respects\u02b3 R\u02b3 j\u2248j\u2032 (k , Lik , Rkj) = k , Lik , R\u02b3 j\u2248j\u2032 Rkj\n\nmodule _ {\u2248 : Rel A \u2113} (L : REL A B \u2113\u2081) (R : REL B A \u2113\u2082) where\n\n  respects\u2082 :  L Respects\u02e1 \u2248 \u2192 R Respects\u02b3 \u2248 \u2192 (L \u037e R) Respects\u2082 \u2248\n  respects\u2082 L\u02e1 R\u02b3 = respects\u02b3 L R R\u02b3 , respects\u02e1 L R L\u02e1\n\nmodule _ {\u2248 : REL A B \u2113} (L : REL A B \u2113\u2081) (R : Rel B \u2113\u2082) where\n\n  implies\u02e1 : Reflexive R \u2192 (\u2248 \u21d2 L) \u2192 (\u2248 \u21d2 L \u037e R)\n  implies\u02e1 R-refl \u2248\u21d2L {i} {j} i\u2248j = j , \u2248\u21d2L i\u2248j , R-refl\n\nmodule _ {\u2248 : REL A B \u2113} (L : Rel A \u2113\u2081) (R : REL A B \u2113\u2082) where\n\n  implies\u02b3 : Reflexive L \u2192 (\u2248 \u21d2 R) \u2192 (\u2248 \u21d2 L \u037e R)\n  implies\u02b3 L-refl \u2248\u21d2R {i} {j} i\u2248j = i , L-refl , \u2248\u21d2R i\u2248j\n\nmodule _ (L : Rel A \u2113\u2081) (R : Rel A \u2113\u2082) (comm : R \u037e L \u21d2 L \u037e R) where\n\n  transitive : Transitive L \u2192 Transitive R \u2192 Transitive (L \u037e R)\n  transitive L-trans R-trans {i} {j} {k} (x , Lix , Rxj) (y , Ljy , Ryk) =\n    let z , Lxz , Rzy = comm (j , Rxj , Ljy) in z , L-trans Lix  Lxz , R-trans Rzy Ryk\n\n  isPreorder : {\u2248 : Rel A \u2113} \u2192 IsPreorder \u2248 L \u2192 IsPreorder \u2248 R \u2192 IsPreorder \u2248 (L \u037e R)\n  isPreorder O\u02e1 O\u02b3 = record\n    { isEquivalence = O\u02e1.isEquivalence\n    ; reflexive     = implies\u02e1 L R O\u02b3.refl O\u02e1.reflexive\n    ; trans         = transitive O\u02e1.trans O\u02b3.trans\n    }\n    where module O\u02e1 = IsPreorder O\u02e1; module O\u02b3 = IsPreorder O\u02b3\n\ntransitive\u21d2\u2248\u037e\u2248\u2286\u2248 : (\u2248 : Rel A \u2113) \u2192 Transitive \u2248 \u2192 (\u2248 \u037e \u2248) \u21d2 \u2248\ntransitive\u21d2\u2248\u037e\u2248\u2286\u2248 _ trans (_ , l , r) = trans l r\n</pre>"},{"location":"md/Relation/Binary/Construct/Constant/Core/","title":"Relation.Binary.Construct.Constant.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The binary relation defined by a constant\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Constant.Core where\n\nopen import Level using (Level)\nopen import Relation.Binary.Core using (REL)\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Definition\n\nConst : Set c \u2192 REL A B c\nConst I = \u03bb _ _ \u2192 I\n</pre>"},{"location":"md/Relation/Binary/Construct/Flip/EqAndOrd/","title":"Relation.Binary.Construct.Flip.EqAndOrd","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Many properties which hold for `\u223c` also hold for `flip \u223c`. Unlike\n-- the module `Relation.Binary.Construct.Flip.Ord` this module does not\n-- flip the underlying equality.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Flip.EqAndOrd where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (flip; _\u2218_)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel; REL; _\u21d2_)\nopen import Relation.Binary.Bundles\n  using (Setoid; DecSetoid; Preorder; Poset; TotalOrder; DecTotalOrder\n        ; StrictPartialOrder; StrictTotalOrder; TotalPreorder)\nopen import Relation.Binary.Structures\n  using (IsEquivalence; IsDecEquivalence; IsPreorder; IsPartialOrder\n        ; IsTotalOrder; IsDecTotalOrder; IsStrictPartialOrder\n        ; IsStrictTotalOrder; IsTotalPreorder)\nopen import Relation.Binary.Definitions\n  using (Reflexive; Symmetric; Transitive; Asymmetric; Total; _Respects_\n        ; _Respects\u2082_; Minimum; Maximum; Irreflexive; Antisymmetric\n        ; Trichotomous; Decidable; tri&lt;; tri&gt;; tri\u2248)\n\nprivate\n  variable\n    a b p \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n    \u2248 \u223c \u2264 &lt; : Rel A \u2113\n\n------------------------------------------------------------------------\n-- Properties\n\nmodule _ (\u223c : Rel A \u2113) where\n\n  refl : Reflexive \u223c \u2192 Reflexive (flip \u223c)\n  refl refl = refl\n\n  sym : Symmetric \u223c \u2192 Symmetric (flip \u223c)\n  sym sym = sym\n\n  trans : Transitive \u223c \u2192 Transitive (flip \u223c)\n  trans trans = flip trans\n\n  asym : Asymmetric \u223c \u2192 Asymmetric (flip \u223c)\n  asym asym = asym\n\n  total : Total \u223c \u2192 Total (flip \u223c)\n  total total x y = total y x\n\n  resp : \u2200 {p} (P : A \u2192 Set p) \u2192 Symmetric \u223c \u2192\n             P Respects \u223c \u2192 P Respects (flip \u223c)\n  resp _ sym resp \u223c = resp (sym \u223c)\n\n  max : \u2200 {\u22a5} \u2192 Minimum \u223c \u22a5 \u2192 Maximum (flip \u223c) \u22a5\n  max min = min\n\n  min : \u2200 {\u22a4} \u2192 Maximum \u223c \u22a4 \u2192 Minimum (flip \u223c) \u22a4\n  min max = max\n\nmodule _ {\u2248 : Rel A \u2113\u2081} (\u223c : Rel A \u2113\u2082) where\n\n  reflexive : Symmetric \u2248 \u2192 (\u2248 \u21d2 \u223c) \u2192 (\u2248 \u21d2 flip \u223c)\n  reflexive sym impl = impl \u2218 sym\n\n  irrefl : Symmetric \u2248 \u2192 Irreflexive \u2248 \u223c \u2192 Irreflexive \u2248 (flip \u223c)\n  irrefl sym irrefl x\u2248y y\u223cx = irrefl (sym x\u2248y) y\u223cx\n\n  antisym : Antisymmetric \u2248 \u223c \u2192 Antisymmetric \u2248 (flip \u223c)\n  antisym antisym = flip antisym\n\n  compare : Trichotomous \u2248 \u223c \u2192 Trichotomous \u2248 (flip \u223c)\n  compare cmp x y with cmp x y\n  ... | tri&lt; x&lt;y x\u2249y y\u226ex = tri&gt; y\u226ex x\u2249y x&lt;y\n  ... | tri\u2248 x\u226ey x\u2248y y\u226ex = tri\u2248 y\u226ex x\u2248y x\u226ey\n  ... | tri&gt; x\u226ey x\u2249y y&lt;x = tri&lt; y&lt;x x\u2249y x\u226ey\n\nmodule _ (\u223c\u2081 : Rel A \u2113\u2081) (\u223c\u2082 : Rel A \u2113\u2082) where\n\n  resp\u2082 : \u223c\u2081 Respects\u2082 \u223c\u2082 \u2192 (flip \u223c\u2081) Respects\u2082 \u223c\u2082\n  resp\u2082 (resp\u2081 , resp\u2082) = resp\u2082 , resp\u2081\n\nmodule _ (\u223c : REL A B \u2113) where\n\n  dec : Decidable \u223c \u2192 Decidable (flip \u223c)\n  dec dec = flip dec\n\n------------------------------------------------------------------------\n-- Structures\n\nisEquivalence : IsEquivalence \u2248 \u2192 IsEquivalence (flip \u2248)\nisEquivalence {\u2248 = \u2248} eq = record\n  { refl  = refl  \u2248 Eq.refl\n  ; sym   = sym   \u2248 Eq.sym\n  ; trans = trans \u2248 Eq.trans\n  } where module Eq = IsEquivalence eq\n\nisDecEquivalence : IsDecEquivalence \u2248 \u2192 IsDecEquivalence (flip \u2248)\nisDecEquivalence {\u2248 = \u2248} eq = record\n  { isEquivalence = isEquivalence Dec.isEquivalence\n  ; _\u225f_           = dec \u2248 Dec._\u225f_\n  } where module Dec = IsDecEquivalence eq\n\nisPreorder : IsPreorder \u2248 \u223c \u2192 IsPreorder \u2248 (flip \u223c)\nisPreorder {\u2248 = \u2248} {\u223c = \u223c} O = record\n  { isEquivalence = O.isEquivalence\n  ; reflexive     = reflexive \u223c O.Eq.sym O.reflexive\n  ; trans         = trans \u223c O.trans\n  } where module O = IsPreorder O\n\nisTotalPreorder : IsTotalPreorder \u2248 \u223c \u2192 IsTotalPreorder \u2248 (flip \u223c)\nisTotalPreorder O = record\n  { isPreorder = isPreorder O.isPreorder\n  ; total      = total _ O.total\n  } where module O = IsTotalPreorder O\n\nisPartialOrder : IsPartialOrder \u2248 \u2264 \u2192 IsPartialOrder \u2248 (flip \u2264)\nisPartialOrder {\u2264 = \u2264} O = record\n  { isPreorder = isPreorder O.isPreorder\n  ; antisym    = antisym \u2264 O.antisym\n  } where module O = IsPartialOrder O\n\nisTotalOrder : IsTotalOrder \u2248 \u2264 \u2192 IsTotalOrder \u2248 (flip \u2264)\nisTotalOrder O = record\n  { isPartialOrder = isPartialOrder O.isPartialOrder\n  ; total          = total _ O.total\n  } where module O = IsTotalOrder O\n\nisDecTotalOrder : IsDecTotalOrder \u2248 \u2264 \u2192 IsDecTotalOrder \u2248 (flip \u2264)\nisDecTotalOrder O = record\n  { isTotalOrder = isTotalOrder O.isTotalOrder\n  ; _\u225f_          = O._\u225f_\n  ; _\u2264?_         = dec _ O._\u2264?_\n  } where module O = IsDecTotalOrder O\n\nisStrictPartialOrder : IsStrictPartialOrder \u2248 &lt; \u2192\n                       IsStrictPartialOrder \u2248 (flip &lt;)\nisStrictPartialOrder {&lt; = &lt;} O = record\n  { isEquivalence = O.isEquivalence\n  ; irrefl        = irrefl &lt; O.Eq.sym O.irrefl\n  ; trans         = trans &lt; O.trans\n  ; &lt;-resp-\u2248      = resp\u2082 _ _ O.&lt;-resp-\u2248\n  } where module O = IsStrictPartialOrder O\n\nisStrictTotalOrder : IsStrictTotalOrder \u2248 &lt; \u2192\n                     IsStrictTotalOrder \u2248 (flip &lt;)\nisStrictTotalOrder {&lt; = &lt;} O = record\n  { isStrictPartialOrder = isStrictPartialOrder O.isStrictPartialOrder\n  ; compare              = compare _ O.compare\n  } where module O = IsStrictTotalOrder O\n\n------------------------------------------------------------------------\n-- Bundles\n\nsetoid : Setoid a \u2113 \u2192 Setoid a \u2113\nsetoid S = record\n  { isEquivalence = isEquivalence S.isEquivalence\n  } where module S = Setoid S\n\ndecSetoid : DecSetoid a \u2113 \u2192 DecSetoid a \u2113\ndecSetoid S = record\n  { isDecEquivalence = isDecEquivalence S.isDecEquivalence\n  } where module S = DecSetoid S\n\npreorder : Preorder a \u2113\u2081 \u2113\u2082 \u2192 Preorder a \u2113\u2081 \u2113\u2082\npreorder O = record\n  { isPreorder = isPreorder O.isPreorder\n  } where module O = Preorder O\n\ntotalPreorder : TotalPreorder a \u2113\u2081 \u2113\u2082 \u2192 TotalPreorder a \u2113\u2081 \u2113\u2082\ntotalPreorder O = record\n  { isTotalPreorder = isTotalPreorder O.isTotalPreorder\n  } where module O = TotalPreorder O\n\nposet : Poset a \u2113\u2081 \u2113\u2082 \u2192 Poset a \u2113\u2081 \u2113\u2082\nposet O = record\n  { isPartialOrder = isPartialOrder O.isPartialOrder\n  } where module O = Poset O\n\ntotalOrder : TotalOrder a \u2113\u2081 \u2113\u2082 \u2192 TotalOrder a \u2113\u2081 \u2113\u2082\ntotalOrder O = record\n  { isTotalOrder = isTotalOrder O.isTotalOrder\n  } where module O = TotalOrder O\n\ndecTotalOrder : DecTotalOrder a \u2113\u2081 \u2113\u2082 \u2192 DecTotalOrder a \u2113\u2081 \u2113\u2082\ndecTotalOrder O = record\n  { isDecTotalOrder = isDecTotalOrder O.isDecTotalOrder\n  } where module O = DecTotalOrder O\n\nstrictPartialOrder : StrictPartialOrder a \u2113\u2081 \u2113\u2082 \u2192\n                     StrictPartialOrder a \u2113\u2081 \u2113\u2082\nstrictPartialOrder O = record\n  { isStrictPartialOrder = isStrictPartialOrder O.isStrictPartialOrder\n  } where module O = StrictPartialOrder O\n\nstrictTotalOrder : StrictTotalOrder a \u2113\u2081 \u2113\u2082 \u2192\n                   StrictTotalOrder a \u2113\u2081 \u2113\u2082\nstrictTotalOrder O = record\n  { isStrictTotalOrder = isStrictTotalOrder O.isStrictTotalOrder\n  } where module O = StrictTotalOrder O\n</pre>"},{"location":"md/Relation/Binary/Construct/NaturalOrder/Left/","title":"Relation.Binary.Construct.NaturalOrder.Left","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Conversion of binary operators to binary relations via the left\n-- natural order.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Core using (Op\u2082)\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\n\nmodule Relation.Binary.Construct.NaturalOrder.Left\n  {a \u2113} {A : Set a} (_\u2248_ : Rel A \u2113) (_\u2219_ : Op\u2082 A) where\n\nopen import Data.Product.Base using (_,_; _\u00d7_)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082; map)\nopen import Relation.Binary.Bundles\n  using (Preorder; Poset; DecPoset; TotalOrder; DecTotalOrder)\nopen import Relation.Binary.Structures\n  using (IsEquivalence; IsPreorder; IsPartialOrder; IsDecPartialOrder\n        ; IsTotalOrder; IsDecTotalOrder)\nopen import Relation.Binary.Definitions\n  using (Symmetric; Transitive; Reflexive; Antisymmetric; Total; _Respects\u02b3_\n        ; _Respects\u02e1_; _Respects\u2082_; Decidable)\nopen import Relation.Nullary.Negation using (\u00ac_)\nimport Relation.Binary.Reasoning.Setoid as \u2248-Reasoning\nopen import Relation.Binary.Lattice using (Infimum)\n\nopen import Algebra.Definitions _\u2248_\nopen import Algebra.Structures _\u2248_\nopen import Algebra.Lattice.Structures _\u2248_\n\n------------------------------------------------------------------------\n-- Definition\n\ninfix 4 _\u2264_\n\n_\u2264_ : Rel A \u2113\nx \u2264 y = x \u2248 (x \u2219 y)\n\n------------------------------------------------------------------------\n-- Relational properties\n\nreflexive : IsMagma _\u2219_ \u2192 Idempotent _\u2219_ \u2192 _\u2248_ \u21d2 _\u2264_\nreflexive magma idem {x} {y} x\u2248y = begin\n  x     \u2248\u27e8 sym (idem x) \u27e9\n  x \u2219 x \u2248\u27e8 \u2219-cong refl x\u2248y \u27e9\n  x \u2219 y \u220e\n  where open IsMagma magma; open \u2248-Reasoning setoid\n\nrefl : Symmetric _\u2248_ \u2192 Idempotent _\u2219_ \u2192 Reflexive _\u2264_\nrefl sym idem {x} = sym (idem x)\n\nantisym : IsEquivalence _\u2248_ \u2192 Commutative _\u2219_ \u2192 Antisymmetric _\u2248_ _\u2264_\nantisym isEq comm {x} {y} x\u2264y y\u2264x = begin\n  x     \u2248\u27e8 x\u2264y \u27e9\n  x \u2219 y \u2248\u27e8 comm x y \u27e9\n  y \u2219 x \u2248\u27e8 sym y\u2264x \u27e9\n  y     \u220e\n  where open IsEquivalence isEq; open \u2248-Reasoning (record { isEquivalence = isEq })\n\ntotal : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192 Selective _\u2219_ \u2192 Commutative _\u2219_ \u2192 Total _\u2264_\ntotal sym trans sel comm x y = map sym (\u03bb x\u2219y\u2248y \u2192 trans (sym x\u2219y\u2248y) (comm x y)) (sel x y)\n\ntrans : IsSemigroup _\u2219_ \u2192 Transitive _\u2264_\ntrans semi {x} {y} {z} x\u2264y y\u2264z = begin\n  x           \u2248\u27e8 x\u2264y \u27e9\n  x \u2219 y       \u2248\u27e8 \u2219-cong S.refl y\u2264z \u27e9\n  x \u2219 (y \u2219 z) \u2248\u27e8 sym (assoc x y z) \u27e9\n  (x \u2219 y) \u2219 z \u2248\u27e8 \u2219-cong (sym x\u2264y) S.refl \u27e9\n  x \u2219 z       \u220e\n  where open module S = IsSemigroup semi; open \u2248-Reasoning S.setoid\n\nresp\u02b3 : IsMagma _\u2219_ \u2192 _\u2264_ Respects\u02b3 _\u2248_\nresp\u02b3 magma {x} {y} {z} y\u2248z x\u2264y = begin\n  x     \u2248\u27e8 x\u2264y \u27e9\n  x \u2219 y \u2248\u27e8 \u2219-cong M.refl y\u2248z \u27e9\n  x \u2219 z \u220e\n  where open module M = IsMagma magma; open \u2248-Reasoning M.setoid\n\nresp\u02e1 : IsMagma _\u2219_ \u2192 _\u2264_ Respects\u02e1 _\u2248_\nresp\u02e1 magma {x} {y} {z} y\u2248z y\u2264x = begin\n  z     \u2248\u27e8 sym y\u2248z \u27e9\n  y     \u2248\u27e8 y\u2264x \u27e9\n  y \u2219 x \u2248\u27e8 \u2219-cong y\u2248z M.refl \u27e9\n  z \u2219 x \u220e\n  where open module M = IsMagma magma; open \u2248-Reasoning M.setoid\n\nresp\u2082 : IsMagma _\u2219_ \u2192  _\u2264_ Respects\u2082 _\u2248_\nresp\u2082 magma = resp\u02b3 magma , resp\u02e1 magma\n\ndec : Decidable _\u2248_ \u2192 Decidable _\u2264_\ndec _\u225f_ x y = x \u225f (x \u2219 y)\n\nmodule _ (semi : IsSemilattice _\u2219_) where\n\n  private open module S = IsSemilattice semi\n  open \u2248-Reasoning setoid\n\n  x\u2219y\u2264x : \u2200 x y \u2192 (x \u2219 y) \u2264 x\n  x\u2219y\u2264x x y = begin\n    x \u2219 y       \u2248\u27e8 \u2219-cong (sym (idem x)) S.refl \u27e9\n    (x \u2219 x) \u2219 y \u2248\u27e8 assoc x x y \u27e9\n    x \u2219 (x \u2219 y) \u2248\u27e8 comm x (x \u2219 y) \u27e9\n    (x \u2219 y) \u2219 x \u220e\n\n  x\u2219y\u2264y : \u2200 x y \u2192 (x \u2219 y) \u2264 y\n  x\u2219y\u2264y x y = begin\n    x \u2219 y        \u2248\u27e8 \u2219-cong S.refl (sym (idem y)) \u27e9\n    x \u2219 (y \u2219 y)  \u2248\u27e8 sym (assoc x y y) \u27e9\n    (x \u2219 y) \u2219 y  \u220e\n\n  \u2219-pres\u02b3-\u2264 : \u2200 {x y} z \u2192 z \u2264 x \u2192 z \u2264 y \u2192 z \u2264 (x \u2219 y)\n  \u2219-pres\u02b3-\u2264 {x} {y} z z\u2264x z\u2264y = begin\n    z            \u2248\u27e8 z\u2264y \u27e9\n    z \u2219 y        \u2248\u27e8 \u2219-cong z\u2264x S.refl \u27e9\n    (z \u2219 x) \u2219 y  \u2248\u27e8 assoc z x y \u27e9\n    z \u2219 (x \u2219 y)  \u220e\n\n  infimum : Infimum _\u2264_ _\u2219_\n  infimum x y = x\u2219y\u2264x x y , x\u2219y\u2264y x y , \u2219-pres\u02b3-\u2264\n\n------------------------------------------------------------------------\n-- Structures\n\nisPreorder : IsBand _\u2219_ \u2192 IsPreorder _\u2248_ _\u2264_\nisPreorder band = record\n  { isEquivalence = isEquivalence\n  ; reflexive     = reflexive isMagma idem\n  ; trans         = trans isSemigroup\n  }\n  where open IsBand band hiding (reflexive; trans)\n\nisPartialOrder : IsSemilattice _\u2219_ \u2192 IsPartialOrder _\u2248_ _\u2264_\nisPartialOrder semilattice = record\n  { isPreorder = isPreorder isBand\n  ; antisym    = antisym isEquivalence comm\n  }\n  where open IsSemilattice semilattice\n\nisDecPartialOrder : IsSemilattice _\u2219_ \u2192 Decidable _\u2248_ \u2192\n                    IsDecPartialOrder _\u2248_ _\u2264_\nisDecPartialOrder semilattice _\u225f_ = record\n  { isPartialOrder = isPartialOrder semilattice\n  ; _\u225f_            = _\u225f_\n  ; _\u2264?_           = dec _\u225f_\n  }\n\nisTotalOrder : IsSemilattice _\u2219_ \u2192 Selective _\u2219_ \u2192 IsTotalOrder _\u2248_ _\u2264_\nisTotalOrder latt sel  = record\n  { isPartialOrder = isPartialOrder latt\n  ; total          = total sym S.trans sel comm\n  }\n  where open module S = IsSemilattice latt\n\nisDecTotalOrder : IsSemilattice _\u2219_ \u2192 Selective _\u2219_ \u2192\n                  Decidable _\u2248_ \u2192 IsDecTotalOrder _\u2248_ _\u2264_\nisDecTotalOrder latt sel _\u225f_ = record\n  { isTotalOrder = isTotalOrder latt sel\n  ; _\u225f_          = _\u225f_\n  ; _\u2264?_         = dec _\u225f_\n  }\n\n------------------------------------------------------------------------\n-- Bundles\n\npreorder : IsBand _\u2219_ \u2192 Preorder a \u2113 \u2113\npreorder band = record\n  { isPreorder = isPreorder band\n  }\n\nposet : IsSemilattice _\u2219_ \u2192 Poset a \u2113 \u2113\nposet latt = record\n  { isPartialOrder = isPartialOrder latt\n  }\n\ndecPoset : IsSemilattice _\u2219_ \u2192 Decidable _\u2248_ \u2192 DecPoset a \u2113 \u2113\ndecPoset latt dec = record\n  { isDecPartialOrder = isDecPartialOrder latt dec\n  }\n\ntotalOrder : IsSemilattice _\u2219_ \u2192 Selective _\u2219_ \u2192 TotalOrder a \u2113 \u2113\ntotalOrder latt sel = record\n  { isTotalOrder = isTotalOrder latt sel\n  }\n\ndecTotalOrder : IsSemilattice _\u2219_ \u2192 Selective _\u2219_ \u2192\n                Decidable _\u2248_ \u2192 DecTotalOrder a \u2113 \u2113\ndecTotalOrder latt sel dec = record\n  { isDecTotalOrder = isDecTotalOrder latt sel dec\n  }\n</pre>"},{"location":"md/Relation/Binary/Construct/NonStrictToStrict/","title":"Relation.Binary.Construct.NonStrictToStrict","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Conversion of _\u2264_ to _&lt;_\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\n\nmodule Relation.Binary.Construct.NonStrictToStrict\n  {a \u2113\u2081 \u2113\u2082} {A : Set a} (_\u2248_ : Rel A \u2113\u2081) (_\u2264_ : Rel A \u2113\u2082) where\n\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nopen import Function.Base using (_\u2218_; flip)\nopen import Relation.Nullary using (\u00ac_; yes; no)\nopen import Relation.Nullary.Decidable using (\u00ac?; _\u00d7-dec_)\nopen import Relation.Nullary.Negation using (contradiction)\nopen import Relation.Binary.Structures\n  using (IsPartialOrder; IsEquivalence; IsStrictPartialOrder; IsDecPartialOrder\n        ; IsDecStrictPartialOrder; IsTotalOrder; IsStrictTotalOrder\n        ; IsDecTotalOrder)\nopen import Relation.Binary.Definitions\n  using (Trichotomous; Antisymmetric; Symmetric; Total; Decidable; Irreflexive\n        ; Transitive; _Respects\u02b3_; _Respects\u02e1_; _Respects\u2082_; Trans; Asymmetric\n        ; tri\u2248; tri&lt;; tri&gt;)\n\nprivate\n  _\u2249_ : Rel A \u2113\u2081\n  x \u2249 y = \u00ac (x \u2248 y)\n\n------------------------------------------------------------------------\n-- _\u2264_ can be turned into _&lt;_ as follows:\n\ninfix 4  _&lt;_\n\n_&lt;_ : Rel A _\nx &lt; y = x \u2264 y \u00d7 x \u2249 y\n\n------------------------------------------------------------------------\n-- Relationship between relations\n\n&lt;\u21d2\u2264 : _&lt;_ \u21d2 _\u2264_\n&lt;\u21d2\u2264 = proj\u2081\n\n&lt;\u21d2\u2249 : \u2200 {x y} \u2192 x &lt; y \u2192 x \u2249 y\n&lt;\u21d2\u2249 = proj\u2082\n\n\u2264\u2227\u2249\u21d2&lt; : \u2200 {x y} \u2192 x \u2264 y \u2192 x \u2249 y \u2192 x &lt; y\n\u2264\u2227\u2249\u21d2&lt; = _,_\n\n&lt;\u21d2\u2271 : Antisymmetric _\u2248_ _\u2264_ \u2192 \u2200 {x y} \u2192 x &lt; y \u2192 \u00ac (y \u2264 x)\n&lt;\u21d2\u2271 antisym (x\u2264y , x\u2249y) y\u2264x = x\u2249y (antisym x\u2264y y\u2264x)\n\n\u2264\u21d2\u226f : Antisymmetric _\u2248_ _\u2264_ \u2192 \u2200 {x y} \u2192 x \u2264 y \u2192 \u00ac (y &lt; x)\n\u2264\u21d2\u226f antisym x\u2264y y&lt;x = &lt;\u21d2\u2271 antisym y&lt;x x\u2264y\n\n\u2270\u21d2&gt; : Symmetric _\u2248_ \u2192 (_\u2248_ \u21d2 _\u2264_) \u2192 Total _\u2264_ \u2192\n      \u2200 {x y} \u2192 \u00ac (x \u2264 y) \u2192 y &lt; x\n\u2270\u21d2&gt; sym refl total {x} {y} x\u2270y with total x y\n... | inj\u2081 x\u2264y = contradiction x\u2264y x\u2270y\n... | inj\u2082 y\u2264x = y\u2264x , x\u2270y \u2218 refl \u2218 sym\n\n\u226e\u21d2\u2265 : Symmetric _\u2248_ \u2192 Decidable _\u2248_ \u2192 _\u2248_ \u21d2 _\u2264_ \u2192 Total _\u2264_ \u2192\n      \u2200 {x y} \u2192 \u00ac (x &lt; y) \u2192 y \u2264 x\n\u226e\u21d2\u2265 sym _\u225f_ \u2264-refl _\u2264?_ {x} {y} x\u226ey with x \u225f y | y \u2264? x\n... | yes x\u2248y  | _        = \u2264-refl (sym x\u2248y)\n... | _        | inj\u2081 y\u2264x = y\u2264x\n... | no  x\u2249y  | inj\u2082 x\u2264y = contradiction (x\u2264y , x\u2249y) x\u226ey\n\n------------------------------------------------------------------------\n-- Relational properties\n\n&lt;-irrefl : Irreflexive _\u2248_ _&lt;_\n&lt;-irrefl x\u2248y (_ , x\u2249y) = x\u2249y x\u2248y\n\n&lt;-trans : IsPartialOrder _\u2248_ _\u2264_ \u2192 Transitive _&lt;_\n&lt;-trans po (x\u2264y , x\u2249y) (y\u2264z , y\u2249z) =\n  (trans x\u2264y y\u2264z , x\u2249y \u2218 antisym x\u2264y \u2218 trans y\u2264z \u2218 reflexive \u2218 Eq.sym)\n  where open IsPartialOrder po\n\n&lt;-\u2264-trans : Symmetric _\u2248_ \u2192 Transitive _\u2264_ \u2192 Antisymmetric _\u2248_ _\u2264_ \u2192\n           _\u2264_ Respects\u02b3 _\u2248_ \u2192 Trans _&lt;_ _\u2264_ _&lt;_\n&lt;-\u2264-trans sym trans antisym resp\u02b3 (x\u2264y , x\u2249y) y\u2264z =\n  trans x\u2264y y\u2264z , (\u03bb x\u2248z \u2192 x\u2249y (antisym x\u2264y (resp\u02b3 (sym x\u2248z) y\u2264z)))\n\n\u2264-&lt;-trans : Transitive _\u2264_ \u2192 Antisymmetric _\u2248_ _\u2264_ \u2192\n           _\u2264_ Respects\u02e1 _\u2248_ \u2192 Trans _\u2264_ _&lt;_ _&lt;_\n\u2264-&lt;-trans trans antisym resp\u02b3 x\u2264y (y\u2264z , y\u2249z) =\n  trans x\u2264y y\u2264z , (\u03bb x\u2248z \u2192 y\u2249z (antisym y\u2264z (resp\u02b3 x\u2248z x\u2264y)))\n\n&lt;-asym : Antisymmetric _\u2248_ _\u2264_ \u2192 Asymmetric _&lt;_\n&lt;-asym antisym (x\u2264y , x\u2249y) (y\u2264x , _) = x\u2249y (antisym x\u2264y y\u2264x)\n\n&lt;-resp\u02e1-\u2248 : Transitive _\u2248_ \u2192 _\u2264_ Respects\u02e1 _\u2248_ \u2192 _&lt;_ Respects\u02e1 _\u2248_\n&lt;-resp\u02e1-\u2248 trans resp\u02e1 y\u2248z (y\u2264x , y\u2249x) =\n  resp\u02e1 y\u2248z y\u2264x , y\u2249x \u2218 trans y\u2248z\n\n&lt;-resp\u02b3-\u2248 : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192\n            _\u2264_ Respects\u02b3 _\u2248_ \u2192 _&lt;_ Respects\u02b3 _\u2248_\n&lt;-resp\u02b3-\u2248 sym trans resp\u02b3 y\u2248z (x\u2264y , x\u2249y) =\n  (resp\u02b3 y\u2248z x\u2264y) , \u03bb x\u2248z \u2192 x\u2249y (trans x\u2248z (sym y\u2248z))\n\n&lt;-resp-\u2248 : IsEquivalence _\u2248_ \u2192 _\u2264_ Respects\u2082 _\u2248_ \u2192 _&lt;_ Respects\u2082 _\u2248_\n&lt;-resp-\u2248 eq (resp\u02b3 , resp\u02e1) =\n  &lt;-resp\u02b3-\u2248 sym trans resp\u02b3 , &lt;-resp\u02e1-\u2248 trans resp\u02e1\n  where open IsEquivalence eq\n\n&lt;-trichotomous : Symmetric _\u2248_ \u2192 Decidable _\u2248_ \u2192\n                 Antisymmetric _\u2248_ _\u2264_ \u2192 Total _\u2264_ \u2192\n                 Trichotomous _\u2248_ _&lt;_\n&lt;-trichotomous \u2248-sym _\u225f_ antisym total x y with x \u225f y\n... | yes x\u2248y = tri\u2248 (&lt;-irrefl x\u2248y) x\u2248y (&lt;-irrefl (\u2248-sym x\u2248y))\n... | no  x\u2249y with total x y\n...   | inj\u2081 x\u2264y = tri&lt; (x\u2264y , x\u2249y) x\u2249y (x\u2249y \u2218 antisym x\u2264y \u2218 proj\u2081)\n...   | inj\u2082 y\u2264x = tri&gt; (x\u2249y \u2218 flip antisym y\u2264x \u2218 proj\u2081) x\u2249y (y\u2264x , x\u2249y \u2218 \u2248-sym)\n\n&lt;-decidable : Decidable _\u2248_ \u2192 Decidable _\u2264_ \u2192 Decidable _&lt;_\n&lt;-decidable _\u225f_ _\u2264?_ x y = x \u2264? y \u00d7-dec \u00ac? (x \u225f y)\n\n------------------------------------------------------------------------\n-- Structures\n\n&lt;-isStrictPartialOrder : IsPartialOrder _\u2248_ _\u2264_ \u2192\n                         IsStrictPartialOrder _\u2248_ _&lt;_\n&lt;-isStrictPartialOrder po = record\n  { isEquivalence = isEquivalence\n  ; irrefl        = &lt;-irrefl\n  ; trans         = &lt;-trans po\n  ; &lt;-resp-\u2248      = &lt;-resp-\u2248 isEquivalence \u2264-resp-\u2248\n  } where open IsPartialOrder po\n\n&lt;-isDecStrictPartialOrder : IsDecPartialOrder _\u2248_ _\u2264_ \u2192\n                            IsDecStrictPartialOrder _\u2248_ _&lt;_\n&lt;-isDecStrictPartialOrder dpo = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder isPartialOrder\n  ; _\u225f_ = _\u225f_\n  ; _&lt;?_ = &lt;-decidable _\u225f_ _\u2264?_\n  } where open IsDecPartialOrder dpo\n\n&lt;-isStrictTotalOrder\u2081 : Decidable _\u2248_ \u2192 IsTotalOrder _\u2248_ _\u2264_ \u2192\n                        IsStrictTotalOrder _\u2248_ _&lt;_\n&lt;-isStrictTotalOrder\u2081 \u225f tot = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder isPartialOrder\n  ; compare              = &lt;-trichotomous Eq.sym \u225f antisym total\n  } where open IsTotalOrder tot\n\n&lt;-isStrictTotalOrder\u2082 : IsDecTotalOrder _\u2248_ _\u2264_ \u2192\n                        IsStrictTotalOrder _\u2248_ _&lt;_\n&lt;-isStrictTotalOrder\u2082 dtot = &lt;-isStrictTotalOrder\u2081 _\u225f_ isTotalOrder\n  where open IsDecTotalOrder dtot\n</pre>"},{"location":"md/Relation/Binary/Core/","title":"Relation.Binary.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Core where\n\nopen import Data.Product.Base using (_\u00d7_)\nopen import Function.Base using (_on_)\nopen import Level using (Level; _\u2294_; suc)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definitions\n------------------------------------------------------------------------\n\n-- Heterogeneous binary relations\n\nREL : Set a \u2192 Set b \u2192 (\u2113 : Level) \u2192 Set (a \u2294 b \u2294 suc \u2113)\nREL A B \u2113 = A \u2192 B \u2192 Set \u2113\n\n-- Homogeneous binary relations\n\nRel : Set a \u2192 (\u2113 : Level) \u2192 Set (a \u2294 suc \u2113)\nRel A \u2113 = REL A A \u2113\n\n------------------------------------------------------------------------\n-- Relationships between relations\n------------------------------------------------------------------------\n\ninfix 4 _\u21d2_ _\u21d4_ _=[_]\u21d2_\n\n-- Implication/containment - could also be written _\u2286_.\n-- and corresponding notion of equivalence\n\n_\u21d2_ : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nP \u21d2 Q = \u2200 {x y} \u2192 P x y \u2192 Q x y\n\n_\u21d4_ : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nP \u21d4 Q = P \u21d2 Q \u00d7 Q \u21d2 P\n\n-- Generalised implication - if P \u2261 Q it can be read as \"f preserves P\".\n\n_=[_]\u21d2_ : Rel A \u2113\u2081 \u2192 (A \u2192 B) \u2192 Rel B \u2113\u2082 \u2192 Set _\nP =[ f ]\u21d2 Q = P \u21d2 (Q on f)\n\n-- A synonym for _=[_]\u21d2_.\n\n_Preserves_\u27f6_ : (A \u2192 B) \u2192 Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Set _\nf Preserves P \u27f6 Q = P =[ f ]\u21d2 Q\n\n-- A binary variant of _Preserves_\u27f6_.\n\n_Preserves\u2082_\u27f6_\u27f6_ : (A \u2192 B \u2192 C) \u2192 Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 Set _\n_\u2219_ Preserves\u2082 P \u27f6 Q \u27f6 R = \u2200 {x y u v} \u2192 P x y \u2192 Q u v \u2192 R (x \u2219 u) (y \u2219 v)\n</pre>"},{"location":"md/Relation/Binary/Definitions/","title":"Relation.Binary.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Definitions where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Data.Product.Base using (_\u00d7_; \u2203-syntax)\nopen import Data.Sum.Base using (_\u228e_)\nopen import Function.Base using (_on_; flip)\nopen import Level using (Level; _\u2294_; suc)\nopen import Relation.Binary.Core\nopen import Relation.Nullary as Nullary using (\u00ac_; Dec)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definitions\n------------------------------------------------------------------------\n\n-- Reflexivity - defined without an underlying equality. It could\n-- alternatively be defined as `_\u2248_ \u21d2 _\u223c_` for some equality `_\u2248_`.\n\n-- Confusingly the convention in the library is to use the name \"refl\"\n-- for proofs of Reflexive and `reflexive` for proofs of type `_\u2248_ \u21d2 _\u223c_`,\n-- e.g. in the definition of `IsEquivalence` later in this file. This\n-- convention is a legacy from the early days of the library.\n\nReflexive : Rel A \u2113 \u2192 Set _\nReflexive _\u223c_ = \u2200 {x} \u2192 x \u223c x\n\n-- Generalised symmetry.\n\nSym : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 Set _\nSym P Q = P \u21d2 flip Q\n\n-- Symmetry.\n\nSymmetric : Rel A \u2113 \u2192 Set _\nSymmetric _\u223c_ = Sym _\u223c_ _\u223c_\n\n-- Generalised transitivity.\n\nTrans : REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C \u2113\u2083 \u2192 Set _\nTrans P Q R = \u2200 {i j k} \u2192 P i j \u2192 Q j k \u2192 R i k\n\nRightTrans : REL A B \u2113\u2081 \u2192 REL B B \u2113\u2082 \u2192 Set _\nRightTrans R S = Trans R S R\n\nLeftTrans : REL A A \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nLeftTrans S R = Trans S R R\n\n-- A flipped variant of generalised transitivity.\n\nTransFlip : REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C \u2113\u2083 \u2192 Set _\nTransFlip P Q R = \u2200 {i j k} \u2192 Q j k \u2192 P i j \u2192 R i k\n\n-- Transitivity.\n\nTransitive : Rel A \u2113 \u2192 Set _\nTransitive _\u223c_ = Trans _\u223c_ _\u223c_ _\u223c_\n\n-- Generalised antisymmetry\n\nAntisym : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 REL A B \u2113\u2083 \u2192 Set _\nAntisym R S E = \u2200 {i j} \u2192 R i j \u2192 S j i \u2192 E i j\n\n-- Antisymmetry.\n\nAntisymmetric : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nAntisymmetric _\u2248_ _\u2264_ = Antisym _\u2264_ _\u2264_ _\u2248_\n\n-- Irreflexivity - this is defined terms of the underlying equality.\n\nIrreflexive : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nIrreflexive _\u2248_ _&lt;_ = \u2200 {x y} \u2192 x \u2248 y \u2192 \u00ac (x &lt; y)\n\n-- Asymmetry.\n\nAsymmetric : Rel A \u2113 \u2192 Set _\nAsymmetric _&lt;_ = \u2200 {x y} \u2192 x &lt; y \u2192 \u00ac (y &lt; x)\n\n-- Density\n\nDense : Rel A \u2113 \u2192 Set _\nDense _&lt;_ = \u2200 {x y} \u2192 x &lt; y \u2192 \u2203[ z ] x &lt; z \u00d7 z &lt; y\n\n-- Generalised connex - at least one of the two relations holds.\n\nConnex : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 Set _\nConnex P Q = \u2200 x y \u2192 P x y \u228e Q y x\n\n-- Totality.\n\nTotal : Rel A \u2113 \u2192 Set _\nTotal _\u223c_ = Connex _\u223c_ _\u223c_\n\n-- Generalised trichotomy - exactly one of three types has a witness.\n\ndata Tri (A : Set a) (B : Set b) (C : Set c) : Set (a \u2294 b \u2294 c) where\n  tri&lt; : ( a :   A) (\u00acb : \u00ac B) (\u00acc : \u00ac C) \u2192 Tri A B C\n  tri\u2248 : (\u00aca : \u00ac A) ( b :   B) (\u00acc : \u00ac C) \u2192 Tri A B C\n  tri&gt; : (\u00aca : \u00ac A) (\u00acb : \u00ac B) ( c :   C) \u2192 Tri A B C\n\n-- Trichotomy.\n\nTrichotomous : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nTrichotomous _\u2248_ _&lt;_ = \u2200 x y \u2192 Tri (x &lt; y) (x \u2248 y) (x &gt; y)\n  where _&gt;_ = flip _&lt;_\n\n-- Generalised maximum element.\n\nMax : REL A B \u2113 \u2192 B \u2192 Set _\nMax _\u2264_ T = \u2200 x \u2192 x \u2264 T\n\n-- Maximum element.\n\nMaximum : Rel A \u2113 \u2192 A \u2192 Set _\nMaximum = Max\n\n-- Generalised minimum element.\n\nMin : REL A B \u2113 \u2192 A \u2192 Set _\nMin R = Max (flip R)\n\n-- Minimum element.\n\nMinimum : Rel A \u2113 \u2192 A \u2192 Set _\nMinimum = Min\n\n-- Definitions for apartness relations\n\n-- Note that Cotransitive's arguments are permuted with respect to Transitive's.\nCotransitive : Rel A \u2113 \u2192 Set _\nCotransitive _#_ = \u2200 {x y} \u2192 x # y \u2192 \u2200 z \u2192 (x # z) \u228e (z # y)\n\nTight : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nTight _\u2248_ _#_ = \u2200 x y \u2192 (\u00ac x # y \u2192 x \u2248 y) \u00d7 (x \u2248 y \u2192 \u00ac x # y)\n\n-- Properties of order morphisms, aka order-preserving maps\n\nMonotonic\u2081 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nMonotonic\u2081 _\u2264_ _\u2291_ f = f Preserves _\u2264_ \u27f6 _\u2291_\n\nAntitonic\u2081 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nAntitonic\u2081 _\u2264_ = Monotonic\u2081 (flip _\u2264_)\n\nLeftMonotonic : Rel B \u2113\u2081 \u2192 Rel C \u2113\u2082 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nLeftMonotonic _\u2264_ _\u2291_ _\u2219_ = \u2200 x \u2192 Monotonic\u2081 _\u2264_ _\u2291_ (x \u2219_)\n\nRightMonotonic : Rel A \u2113\u2081 \u2192 Rel C \u2113\u2082 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nRightMonotonic _\u2264_ _\u2291_ _\u2219_ = \u2200 y \u2192 Monotonic\u2081 _\u2264_ _\u2291_ (_\u2219 y)\n\nMonotonic\u2082 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nMonotonic\u2082 _\u2264_ _\u2291_ _\u227c_ \u2219 = \u2219 Preserves\u2082 _\u2264_ \u27f6 _\u2291_ \u27f6 _\u227c_\n\nMonotonicAntitonic : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nMonotonicAntitonic _\u2264_ _\u2291_ = Monotonic\u2082 _\u2264_ (flip _\u2291_)\n\nAntitonicMonotonic : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nAntitonicMonotonic _\u2264_ = Monotonic\u2082 (flip _\u2264_)\n\nAntitonic\u2082 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nAntitonic\u2082 _\u2264_ _\u2291_ = Monotonic\u2082 (flip _\u2264_) (flip _\u2291_)\n\nAdjoint : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nAdjoint _\u2264_ _\u2291_ f g = \u2200 {x y} \u2192 (f x \u2291 y \u2192 x \u2264 g y) \u00d7 (x \u2264 g y \u2192 f x \u2291 y)\n\n-- Unary relations respecting a binary relation.\n\n_\u27f6_Respects_ : (A \u2192 Set \u2113\u2081) \u2192 (B \u2192 Set \u2113\u2082) \u2192 REL A B \u2113\u2083 \u2192 Set _\nP \u27f6 Q Respects _\u223c_ = \u2200 {x y} \u2192 x \u223c y \u2192 P x \u2192 Q y\n\n-- Unary relation respects a binary relation.\n\n_Respects_ : (A \u2192 Set \u2113\u2081) \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects _\u223c_ = P \u27f6 P Respects _\u223c_\n\n-- Right respecting - relatedness is preserved on the right by equality.\n\n_Respects\u02b3_ : REL A B \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Set _\n_\u223c_ Respects\u02b3 _\u2248_ = \u2200 {x} \u2192 (x \u223c_) Respects _\u2248_\n\n-- Left respecting - relatedness is preserved on the left by equality.\n\n_Respects\u02e1_ : REL A B \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects\u02e1 _\u223c_ = \u2200 {y} \u2192 (flip P y) Respects _\u223c_\n\n-- Respecting - relatedness is preserved on both sides by equality\n\n_Respects\u2082_ : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects\u2082 _\u223c_ = (P Respects\u02b3 _\u223c_) \u00d7 (P Respects\u02e1 _\u223c_)\n\n-- Substitutivity - any two related elements satisfy exactly the same\n-- set of unary relations. Note that only the various derivatives\n-- of propositional equality can satisfy this property.\n\nSubstitutive : Rel A \u2113\u2081 \u2192 (\u2113\u2082 : Level) \u2192 Set _\nSubstitutive {A = A} _\u223c_ p = (P : A \u2192 Set p) \u2192 P Respects _\u223c_\n\n-- Irrelevancy - all proofs that a given pair of elements are related\n-- are indistinguishable.\n\nIrrelevant : REL A B \u2113 \u2192 Set _\nIrrelevant _\u223c_ = \u2200 {x y} \u2192 Nullary.Irrelevant (x \u223c y)\n\n-- Recomputability - we can rebuild a relevant proof given an\n-- irrelevant one.\n\nRecomputable : REL A B \u2113 \u2192 Set _\nRecomputable _\u223c_ = \u2200 {x y} \u2192 Nullary.Recomputable (x \u223c y)\n\n-- Stability\n\nStable : REL A B \u2113 \u2192 Set _\nStable _\u223c_ = \u2200 x y \u2192 Nullary.Stable (x \u223c y)\n\n-- Weak decidability - it is sometimes possible to determine if a given\n-- pair of elements are related.\n\nWeaklyDecidable : REL A B \u2113 \u2192 Set _\nWeaklyDecidable _\u223c_ = \u2200 x y \u2192 Nullary.WeaklyDecidable (x \u223c y)\n\n-- Decidability - it is possible to determine whether a given pair of\n-- elements are related.\n\nDecidable : REL A B \u2113 \u2192 Set _\nDecidable _\u223c_ = \u2200 x y \u2192 Dec (x \u223c y)\n\n-- Propositional equality is decidable for the type.\n\nDecidableEquality : (A : Set a) \u2192 Set _\nDecidableEquality A = Decidable {A = A} _\u2261_\n\n-- Universal - all pairs of elements are related\n\nUniversal : REL A B \u2113 \u2192 Set _\nUniversal _\u223c_ = \u2200 x y \u2192 x \u223c y\n\n-- Empty - no elements are related\n\nEmpty : REL A B \u2113 \u2192 Set _\nEmpty _\u223c_ = \u2200 {x y} \u2192 \u00ac (x \u223c y)\n\n-- Non-emptiness - at least one pair of elements are related.\n\nrecord NonEmpty {A : Set a} {B : Set b}\n                (T : REL A B \u2113) : Set (a \u2294 b \u2294 \u2113) where\n  constructor nonEmpty\n  field\n    {x}   : A\n    {y}   : B\n    proof : T x y\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/","title":"Relation.Binary.Indexed.Heterogeneous","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Heterogeneously-indexed binary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous where\n\n------------------------------------------------------------------------\n-- Publicly export core definitions\n\nopen import Relation.Binary.Indexed.Heterogeneous.Core public\nopen import Relation.Binary.Indexed.Heterogeneous.Definitions public\nopen import Relation.Binary.Indexed.Heterogeneous.Structures public\nopen import Relation.Binary.Indexed.Heterogeneous.Bundles public\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Bundles/","title":"Relation.Binary.Indexed.Heterogeneous.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Indexed binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Indexed.Heterogeneous`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous.Bundles where\n\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Indexed.Heterogeneous.Core using (IRel)\nopen import Relation.Binary.Indexed.Heterogeneous.Structures\n  using (IsIndexedEquivalence; IsIndexedPreorder)\n\n------------------------------------------------------------------------\n-- Definitions\n\nrecord IndexedSetoid {i} (I : Set i) c \u2113 : Set (suc (i \u2294 c \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier       : I \u2192 Set c\n    _\u2248_           : IRel Carrier \u2113\n    isEquivalence : IsIndexedEquivalence Carrier _\u2248_\n\n  open IsIndexedEquivalence isEquivalence public\n\n\nrecord IndexedPreorder {i} (I : Set i) c \u2113\u2081 \u2113\u2082 :\n                       Set (suc (i \u2294 c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2272_\n  field\n    Carrier    : I \u2192 Set c\n    _\u2248_        : IRel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_        : IRel Carrier \u2113\u2082  -- The relation.\n    isPreorder : IsIndexedPreorder Carrier _\u2248_ _\u2272_\n\n  open IsIndexedPreorder isPreorder public\n\n  infix 4 _\u223c_\n  _\u223c_ = _\u2272_\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\n{-# WARNING_ON_USAGE IndexedPreorder._\u223c_\n\"Warning: IndexedPreorder._\u223c_ was deprecated in v2.0. Please use IndexedPreorder._\u2272_ instead. \"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Construct/Trivial/","title":"Relation.Binary.Indexed.Heterogeneous.Construct.Trivial","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Creates trivially indexed records from their non-indexed counterpart.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous.Construct.Trivial\n  {i} {I : Set i} where\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid; Preorder)\nopen import Relation.Binary.Structures using (IsEquivalence; IsPreorder)\nopen import Relation.Binary.Indexed.Heterogeneous\n  using (IndexedSetoid; IndexedPreorder\n        ; IsIndexedEquivalence; IsIndexedPreorder)\n\n------------------------------------------------------------------------\n-- Structures\n\nmodule _ {a} {A : Set a} where\n\n  private\n    A\u1d62 : I \u2192 Set a\n    A\u1d62 i = A\n\n  isIndexedEquivalence : \u2200 {\u2113} {_\u2248_ : Rel A \u2113} \u2192 IsEquivalence _\u2248_ \u2192\n                         IsIndexedEquivalence A\u1d62 _\u2248_\n  isIndexedEquivalence isEq = record\n    { refl  = refl\n    ; sym   = sym\n    ; trans = trans\n    }\n    where open IsEquivalence isEq\n\n  isIndexedPreorder : \u2200 {\u2113\u2081 \u2113\u2082} {_\u2248_ : Rel A \u2113\u2081} {_\u223c_ : Rel A \u2113\u2082} \u2192\n                      IsPreorder _\u2248_ _\u223c_ \u2192\n                      IsIndexedPreorder A\u1d62 _\u2248_ _\u223c_\n  isIndexedPreorder isPreorder = record\n    { isEquivalence = isIndexedEquivalence isEquivalence\n    ; reflexive     = reflexive\n    ; trans         = trans\n    }\n    where open IsPreorder isPreorder\n\n------------------------------------------------------------------------\n-- Bundles\n\nindexedSetoid : \u2200 {a \u2113} \u2192 Setoid a \u2113 \u2192 IndexedSetoid I a \u2113\nindexedSetoid S = record\n  { isEquivalence = isIndexedEquivalence isEquivalence\n  }\n  where open Setoid S\n\nindexedPreorder : \u2200 {a \u2113\u2081 \u2113\u2082} \u2192 Preorder a \u2113\u2081 \u2113\u2082 \u2192\n                  IndexedPreorder I a \u2113\u2081 \u2113\u2082\nindexedPreorder O = record\n  { isPreorder = isIndexedPreorder isPreorder\n  }\n  where open Preorder O\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Core/","title":"Relation.Binary.Indexed.Heterogeneous.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Indexed binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Indexed.Heterogeneous`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous.Core where\n\nopen import Level using (Level)\nimport Relation.Binary.Core as B using (Rel; REL; _\u21d2_)\n\n------------------------------------------------------------------------\n-- Indexed binary relations\n\n-- Heterogeneous types\n\nIREL : \u2200 {i\u2081 i\u2082 a\u2081 a\u2082} {I\u2081 : Set i\u2081} {I\u2082 : Set i\u2082} \u2192\n      (I\u2081 \u2192 Set a\u2081) \u2192 (I\u2082 \u2192 Set a\u2082) \u2192 (\u2113 : Level) \u2192 Set _\nIREL A\u2081 A\u2082 \u2113 = \u2200 {i\u2081 i\u2082} \u2192 A\u2081 i\u2081 \u2192 A\u2082 i\u2082 \u2192 Set \u2113\n\n-- Homogeneous types\n\nIRel : \u2200 {i a} {I : Set i} \u2192 (I \u2192 Set a) \u2192 (\u2113 : Level) \u2192 Set _\nIRel A \u2113 = IREL A A \u2113\n\n------------------------------------------------------------------------\n-- Generalised implication.\n\ninfixr 4 _=[_]\u21d2_\n\n_=[_]\u21d2_ : \u2200 {a b \u2113\u2081 \u2113\u2082} {A : Set a} {B : A \u2192 Set b} \u2192\n          B.Rel A \u2113\u2081 \u2192 ((x : A) \u2192 B x) \u2192 IRel B \u2113\u2082 \u2192 Set _\nP =[ f ]\u21d2 Q = \u2200 {i j} \u2192 P i j \u2192 Q (f i) (f j)\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Definitions/","title":"Relation.Binary.Indexed.Heterogeneous.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Indexed binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Indexed.Heterogeneous`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous.Definitions where\n\nopen import Level using (Level)\nimport Relation.Binary.Definitions as B\n  using (Reflexive; Symmetric; Transitive; Sym; Trans)\nopen import Relation.Binary.Indexed.Heterogeneous.Core using (IRel)\n\nprivate\n  variable\n    i a \u2113 : Level\n    I : Set i\n\n------------------------------------------------------------------------\n-- Simple properties of indexed binary relations\n\nReflexive : (A : I \u2192 Set a) \u2192 IRel A \u2113 \u2192 Set _\nReflexive _ _\u223c_ = \u2200 {i} \u2192 B.Reflexive (_\u223c_ {i})\n\nSymmetric : (A : I \u2192 Set a) \u2192 IRel A \u2113 \u2192 Set _\nSymmetric _ _\u223c_ = \u2200 {i j} \u2192 B.Sym (_\u223c_ {i} {j}) _\u223c_\n\nTransitive : (A : I \u2192 Set a) \u2192 IRel A \u2113 \u2192 Set _\nTransitive _ _\u223c_ = \u2200 {i j k} \u2192 B.Trans _\u223c_ (_\u223c_ {j}) (_\u223c_ {i} {k})\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Structures/","title":"Relation.Binary.Indexed.Heterogeneous.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Indexed binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Indexed.Heterogeneous`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Indexed.Heterogeneous.Core\n\nmodule Relation.Binary.Indexed.Heterogeneous.Structures\n  {i a \u2113} {I : Set i} (A : I \u2192 Set a) (_\u2248_ : IRel A \u2113)\n  where\n\nopen import Function.Base using (id; _\u27e8_\u27e9_)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Core using (_\u21d2_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Indexed.Heterogeneous.Definitions\n  using (Reflexive; Symmetric; Transitive)\n\n------------------------------------------------------------------------\n-- Equivalences\n\nrecord IsIndexedEquivalence : Set (i \u2294 a \u2294 \u2113) where\n  field\n    refl  : Reflexive  A _\u2248_\n    sym   : Symmetric  A _\u2248_\n    trans : Transitive A _\u2248_\n\n  reflexive : \u2200 {i} \u2192 _\u2261_ \u27e8 _\u21d2_ \u27e9 _\u2248_ {i}\n  reflexive \u2261.refl = refl\n\n\nrecord IsIndexedPreorder {\u2113\u2082} (_\u2272_ : IRel A \u2113\u2082) : Set (i \u2294 a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsIndexedEquivalence\n    reflexive     : \u2200 {i j} \u2192 (_\u2248_ {i} {j}) \u27e8 _\u21d2_ \u27e9 _\u2272_\n    trans         : Transitive A _\u2272_\n\n  module Eq = IsIndexedEquivalence isEquivalence\n\n  refl : Reflexive A _\u2272_\n  refl = reflexive Eq.refl\n</pre>"},{"location":"md/Relation/Binary/Lattice/","title":"Relation.Binary.Lattice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Order-theoretic lattices\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Lattice where\n\n------------------------------------------------------------------------\n-- Re-export various components of the lattice hierarchy\n\nopen import Relation.Binary.Lattice.Definitions public\nopen import Relation.Binary.Lattice.Structures public\nopen import Relation.Binary.Lattice.Bundles public\n</pre>"},{"location":"md/Relation/Binary/Lattice/Bundles/","title":"Relation.Binary.Lattice.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for order-theoretic lattices\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Lattice`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Lattice.Bundles where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Poset; Setoid)\nopen import Relation.Binary.Lattice.Structures\n\n------------------------------------------------------------------------\n-- Join semilattices\n\nrecord JoinSemilattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_               : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_               : Op\u2082 Carrier     -- The join operation.\n    isJoinSemilattice : IsJoinSemilattice _\u2248_ _\u2264_ _\u2228_\n\n  open IsJoinSemilattice isJoinSemilattice public\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record { isPartialOrder = isPartialOrder }\n\n  open Poset poset public using (preorder)\n\n\nrecord BoundedJoinSemilattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  field\n    Carrier                  : Set c\n    _\u2248_                      : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_                      : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_                      : Op\u2082 Carrier     -- The join operation.\n    \u22a5                        : Carrier         -- The minimum.\n    isBoundedJoinSemilattice : IsBoundedJoinSemilattice _\u2248_ _\u2264_ _\u2228_ \u22a5\n\n  open IsBoundedJoinSemilattice isBoundedJoinSemilattice public\n\n  joinSemilattice : JoinSemilattice c \u2113\u2081 \u2113\u2082\n  joinSemilattice = record { isJoinSemilattice = isJoinSemilattice }\n\n  open JoinSemilattice joinSemilattice public using (preorder; poset)\n\n------------------------------------------------------------------------\n-- Meet semilattices\n\nrecord MeetSemilattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 7 _\u2227_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_               : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2227_               : Op\u2082 Carrier     -- The meet operation.\n    isMeetSemilattice : IsMeetSemilattice _\u2248_ _\u2264_ _\u2227_\n\n  open IsMeetSemilattice isMeetSemilattice public\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record { isPartialOrder = isPartialOrder }\n\n  open Poset poset public using (preorder)\n\nrecord BoundedMeetSemilattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 7 _\u2227_\n  field\n    Carrier                  : Set c\n    _\u2248_                      : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_                      : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2227_                      : Op\u2082 Carrier     -- The join operation.\n    \u22a4                        : Carrier         -- The maximum.\n    isBoundedMeetSemilattice : IsBoundedMeetSemilattice _\u2248_ _\u2264_ _\u2227_ \u22a4\n\n  open IsBoundedMeetSemilattice isBoundedMeetSemilattice public\n\n  meetSemilattice : MeetSemilattice c \u2113\u2081 \u2113\u2082\n  meetSemilattice = record { isMeetSemilattice = isMeetSemilattice }\n\n  open MeetSemilattice meetSemilattice public using (preorder; poset)\n\n------------------------------------------------------------------------\n-- Lattices\n\nrecord Lattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  infixr 7 _\u2227_\n  field\n    Carrier   : Set c\n    _\u2248_       : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_       : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_       : Op\u2082 Carrier     -- The join operation.\n    _\u2227_       : Op\u2082 Carrier     -- The meet operation.\n    isLattice : IsLattice _\u2248_ _\u2264_ _\u2228_ _\u2227_\n\n  open IsLattice isLattice public\n\n  setoid : Setoid c \u2113\u2081\n  setoid = record { isEquivalence = isEquivalence }\n\n  joinSemilattice : JoinSemilattice c \u2113\u2081 \u2113\u2082\n  joinSemilattice = record { isJoinSemilattice = isJoinSemilattice }\n\n  meetSemilattice : MeetSemilattice c \u2113\u2081 \u2113\u2082\n  meetSemilattice = record { isMeetSemilattice = isMeetSemilattice }\n\n  open JoinSemilattice joinSemilattice public using (poset; preorder)\n\nrecord DistributiveLattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  infixr 7 _\u2227_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_     : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_     : Op\u2082 Carrier     -- The join operation.\n    _\u2227_     : Op\u2082 Carrier     -- The meet operation.\n    isDistributiveLattice : IsDistributiveLattice _\u2248_ _\u2264_ _\u2228_ _\u2227_\n\n  open IsDistributiveLattice isDistributiveLattice using (\u2227-distrib\u02e1-\u2228) public\n  open IsDistributiveLattice isDistributiveLattice using (isLattice)\n\n  lattice : Lattice c \u2113\u2081 \u2113\u2082\n  lattice = record { isLattice = isLattice }\n\n  open Lattice lattice hiding (Carrier; _\u2248_; _\u2264_; _\u2228_; _\u2227_) public\n\nrecord BoundedLattice c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  infixr 7 _\u2227_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_              : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_              : Op\u2082 Carrier     -- The join operation.\n    _\u2227_              : Op\u2082 Carrier     -- The meet operation.\n    \u22a4                : Carrier         -- The maximum.\n    \u22a5                : Carrier         -- The minimum.\n    isBoundedLattice : IsBoundedLattice _\u2248_ _\u2264_ _\u2228_ _\u2227_ \u22a4 \u22a5\n\n  open IsBoundedLattice isBoundedLattice public\n\n  boundedJoinSemilattice : BoundedJoinSemilattice c \u2113\u2081 \u2113\u2082\n  boundedJoinSemilattice = record\n    { isBoundedJoinSemilattice = isBoundedJoinSemilattice }\n\n  boundedMeetSemilattice : BoundedMeetSemilattice c \u2113\u2081 \u2113\u2082\n  boundedMeetSemilattice = record\n    { isBoundedMeetSemilattice = isBoundedMeetSemilattice }\n\n  lattice : Lattice c \u2113\u2081 \u2113\u2082\n  lattice = record { isLattice = isLattice }\n\n  open Lattice lattice public\n    using (joinSemilattice; meetSemilattice; poset; preorder; setoid)\n\n------------------------------------------------------------------------\n-- Heyting algebras (a bounded lattice with exponential operator)\n\nrecord HeytingAlgebra c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 5 _\u21e8_\n  infixr 6 _\u2228_\n  infixr 7 _\u2227_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_              : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_              : Op\u2082 Carrier     -- The join operation.\n    _\u2227_              : Op\u2082 Carrier     -- The meet operation.\n    _\u21e8_              : Op\u2082 Carrier     -- The exponential operation.\n    \u22a4                : Carrier         -- The maximum.\n    \u22a5                : Carrier         -- The minimum.\n    isHeytingAlgebra : IsHeytingAlgebra _\u2248_ _\u2264_ _\u2228_ _\u2227_ _\u21e8_ \u22a4 \u22a5\n\n  boundedLattice : BoundedLattice c \u2113\u2081 \u2113\u2082\n  boundedLattice = record\n    { isBoundedLattice = IsHeytingAlgebra.isBoundedLattice isHeytingAlgebra }\n\n  open IsHeytingAlgebra isHeytingAlgebra\n    using (exponential; transpose-\u21e8; transpose-\u2227) public\n  open BoundedLattice boundedLattice\n    hiding (Carrier; _\u2248_; _\u2264_; _\u2228_; _\u2227_; \u22a4; \u22a5) public\n\n------------------------------------------------------------------------\n-- Boolean algebras (a specialized Heyting algebra)\n\nrecord BooleanAlgebra c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix  4 _\u2248_ _\u2264_\n  infixr 6 _\u2228_\n  infixr 7 _\u2227_\n  infix 8 \u00ac_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2264_              : Rel Carrier \u2113\u2082  -- The partial order.\n    _\u2228_              : Op\u2082 Carrier     -- The join operation.\n    _\u2227_              : Op\u2082 Carrier     -- The meet operation.\n    \u00ac_               : Op\u2081 Carrier     -- The negation operation.\n    \u22a4                : Carrier         -- The maximum.\n    \u22a5                : Carrier         -- The minimum.\n    isBooleanAlgebra : IsBooleanAlgebra _\u2248_ _\u2264_ _\u2228_ _\u2227_ \u00ac_ \u22a4 \u22a5\n\n  open IsBooleanAlgebra isBooleanAlgebra using (isHeytingAlgebra)\n\n  heytingAlgebra : HeytingAlgebra c \u2113\u2081 \u2113\u2082\n  heytingAlgebra = record { isHeytingAlgebra = isHeytingAlgebra }\n\n  open HeytingAlgebra heytingAlgebra public\n    hiding (Carrier; _\u2248_; _\u2264_; _\u2228_; _\u2227_; \u22a4; \u22a5)\n</pre>"},{"location":"md/Relation/Binary/Lattice/Definitions/","title":"Relation.Binary.Lattice.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions for order-theoretic lattices\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Lattice`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Lattice.Definitions where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Data.Product.Base using (_\u00d7_; _,_)\nopen import Function.Base using (flip)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\n\nprivate\n  variable\n    a \u2113 : Level\n    A : Set a\n\n------------------------------------------------------------------------\n-- Relationships between orders and operators\n\nSupremum : Rel A \u2113 \u2192 Op\u2082 A \u2192 Set _\nSupremum _\u2264_ _\u2228_ =\n  \u2200 x y \u2192 x \u2264 (x \u2228 y) \u00d7 y \u2264 (x \u2228 y) \u00d7 \u2200 z \u2192 x \u2264 z \u2192 y \u2264 z \u2192 (x \u2228 y) \u2264 z\n\nInfimum : Rel A \u2113 \u2192 Op\u2082 A \u2192 Set _\nInfimum _\u2264_ = Supremum (flip _\u2264_)\n\nExponential : Rel A \u2113 \u2192 Op\u2082 A \u2192 Op\u2082 A \u2192 Set _\nExponential _\u2264_ _\u2227_ _\u21e8_ =\n  \u2200 w x y \u2192 ((w \u2227 x) \u2264 y \u2192 w \u2264 (x \u21e8 y)) \u00d7 (w \u2264 (x \u21e8 y) \u2192 (w \u2227 x) \u2264 y)\n</pre>"},{"location":"md/Relation/Binary/Lattice/Structures/","title":"Relation.Binary.Lattice.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Structures for order-theoretic lattices\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Lattice`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\n\nmodule Relation.Binary.Lattice.Structures\n {a \u2113\u2081 \u2113\u2082} {A : Set a}\n (_\u2248_ : Rel A \u2113\u2081) -- The underlying equality.\n (_\u2264_ : Rel A \u2113\u2082) -- The partial order.\n where\n\nopen import Algebra.Core using (Op\u2081; Op\u2082)\nopen import Algebra.Definitions using (_DistributesOver\u02e1_)\nopen import Data.Product.Base using (_\u00d7_; _,_)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Binary.Definitions using (Minimum; Maximum)\nopen import Relation.Binary.Lattice.Definitions\n  using (Supremum; Infimum; Exponential)\nopen import Relation.Binary.Structures using (IsPartialOrder)\n\n------------------------------------------------------------------------\n-- Join semilattices\n\nrecord IsJoinSemilattice (_\u2228_ : Op\u2082 A)    -- The join operation.\n                         : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isPartialOrder : IsPartialOrder _\u2248_ _\u2264_\n    supremum       : Supremum _\u2264_ _\u2228_\n\n  x\u2264x\u2228y : \u2200 x y \u2192 x \u2264 (x \u2228 y)\n  x\u2264x\u2228y x y = let pf , _ , _ = supremum x y in pf\n\n  y\u2264x\u2228y : \u2200 x y \u2192 y \u2264 (x \u2228 y)\n  y\u2264x\u2228y x y = let _ , pf , _ = supremum x y in pf\n\n  \u2228-least : \u2200 {x y z} \u2192 x \u2264 z \u2192 y \u2264 z \u2192 (x \u2228 y) \u2264 z\n  \u2228-least {x} {y} {z} = let _ , _ , pf = supremum x y in pf z\n\n  open IsPartialOrder isPartialOrder public\n\nrecord IsBoundedJoinSemilattice (_\u2228_ : Op\u2082 A)    -- The join operation.\n                                (\u22a5   : A)        -- The minimum.\n                                : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isJoinSemilattice : IsJoinSemilattice _\u2228_\n    minimum           : Minimum _\u2264_ \u22a5\n\n  open IsJoinSemilattice isJoinSemilattice public\n\n------------------------------------------------------------------------\n-- Meet semilattices\n\nrecord IsMeetSemilattice (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                         : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isPartialOrder : IsPartialOrder _\u2248_ _\u2264_\n    infimum        : Infimum _\u2264_ _\u2227_\n\n  x\u2227y\u2264x : \u2200 x y \u2192 (x \u2227 y) \u2264 x\n  x\u2227y\u2264x x y = let pf , _ , _ = infimum x y in pf\n\n  x\u2227y\u2264y : \u2200 x y \u2192 (x \u2227 y) \u2264 y\n  x\u2227y\u2264y x y = let _ , pf , _ = infimum x y in pf\n\n  \u2227-greatest : \u2200 {x y z} \u2192 x \u2264 y \u2192 x \u2264 z \u2192 x \u2264 (y \u2227 z)\n  \u2227-greatest {x} {y} {z} = let _ , _ , pf = infimum y z in pf x\n\n  open IsPartialOrder isPartialOrder public\n\nrecord IsBoundedMeetSemilattice (_\u2227_ : Op\u2082 A)    -- The join operation.\n                                (\u22a4   : A)        -- The maximum.\n                                : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isMeetSemilattice : IsMeetSemilattice _\u2227_\n    maximum           : Maximum _\u2264_ \u22a4\n\n  open IsMeetSemilattice isMeetSemilattice public\n\n------------------------------------------------------------------------\n-- Lattices\n\nrecord IsLattice (_\u2228_ : Op\u2082 A)    -- The join operation.\n                 (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                 : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isPartialOrder : IsPartialOrder _\u2248_ _\u2264_\n    supremum       : Supremum _\u2264_ _\u2228_\n    infimum        : Infimum _\u2264_ _\u2227_\n\n  isJoinSemilattice : IsJoinSemilattice  _\u2228_\n  isJoinSemilattice = record\n    { isPartialOrder = isPartialOrder\n    ; supremum       = supremum\n    }\n\n  isMeetSemilattice : IsMeetSemilattice  _\u2227_\n  isMeetSemilattice = record\n    { isPartialOrder = isPartialOrder\n    ; infimum        = infimum\n    }\n\n  open IsJoinSemilattice isJoinSemilattice public\n    using (x\u2264x\u2228y; y\u2264x\u2228y; \u2228-least)\n  open IsMeetSemilattice isMeetSemilattice public\n    using (x\u2227y\u2264x; x\u2227y\u2264y; \u2227-greatest)\n  open IsPartialOrder isPartialOrder public\n\nrecord IsDistributiveLattice (_\u2228_ : Op\u2082 A)    -- The join operation.\n                             (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                             : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLattice    : IsLattice _\u2228_ _\u2227_\n    \u2227-distrib\u02e1-\u2228 : _DistributesOver\u02e1_ _\u2248_ _\u2227_ _\u2228_\n\n  open IsLattice isLattice public\n\nrecord IsBoundedLattice (_\u2228_ : Op\u2082 A)    -- The join operation.\n                        (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                        (\u22a4   : A)        -- The maximum.\n                        (\u22a5   : A)        -- The minimum.\n                        : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLattice : IsLattice _\u2228_ _\u2227_\n    maximum   : Maximum _\u2264_ \u22a4\n    minimum   : Minimum _\u2264_ \u22a5\n\n  open IsLattice isLattice public\n\n  isBoundedJoinSemilattice : IsBoundedJoinSemilattice  _\u2228_ \u22a5\n  isBoundedJoinSemilattice = record\n    { isJoinSemilattice = isJoinSemilattice\n    ; minimum           = minimum\n    }\n\n  isBoundedMeetSemilattice : IsBoundedMeetSemilattice _\u2227_ \u22a4\n  isBoundedMeetSemilattice = record\n    { isMeetSemilattice = isMeetSemilattice\n    ; maximum           = maximum\n    }\n\n------------------------------------------------------------------------\n-- Heyting algebras (a bounded lattice with exponential operator)\n\nrecord IsHeytingAlgebra (_\u2228_ : Op\u2082 A)    -- The join operation.\n                        (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                        (_\u21e8_ : Op\u2082 A)    -- The exponential operation.\n                        (\u22a4   : A)        -- The maximum.\n                        (\u22a5   : A)        -- The minimum.\n                        : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isBoundedLattice : IsBoundedLattice _\u2228_ _\u2227_ \u22a4 \u22a5\n    exponential      : Exponential _\u2264_ _\u2227_ _\u21e8_\n\n  transpose-\u21e8 : \u2200 {w x y} \u2192 (w \u2227 x) \u2264 y \u2192 w \u2264 (x \u21e8 y)\n  transpose-\u21e8 {w} {x} {y} = let pf , _ = exponential w x y in pf\n\n  transpose-\u2227 : \u2200 {w x y} \u2192 w \u2264 (x \u21e8 y) \u2192 (w \u2227 x) \u2264 y\n  transpose-\u2227 {w} {x} {y} = let _ , pf = exponential w x y in pf\n\n  open IsBoundedLattice isBoundedLattice public\n\n------------------------------------------------------------------------\n-- Boolean algebras (a specialized Heyting algebra)\n\nrecord IsBooleanAlgebra (_\u2228_ : Op\u2082 A)    -- The join operation.\n                        (_\u2227_ : Op\u2082 A)    -- The meet operation.\n                        (\u00ac_ : Op\u2081 A)     -- The negation operation.\n                        (\u22a4   : A)        -- The maximum.\n                        (\u22a5   : A)        -- The minimum.\n                        : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  infixr 5 _\u21e8_\n  _\u21e8_ : Op\u2082 A\n  x \u21e8 y = (\u00ac x) \u2228 y\n\n  field\n    isHeytingAlgebra : IsHeytingAlgebra _\u2228_ _\u2227_ _\u21e8_ \u22a4 \u22a5\n\n  open IsHeytingAlgebra isHeytingAlgebra public\n</pre>"},{"location":"md/Relation/Binary/Morphism/Definitions/","title":"Relation.Binary.Morphism.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definitions for morphisms between algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core\n\nmodule Relation.Binary.Morphism.Definitions\n  {a} (A : Set a)     -- The domain of the morphism\n  {b} (B : Set b)     -- The codomain of the morphism\n  where\n\nopen import Level using (Level)\n\nprivate\n  variable\n    \u2113\u2081 \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Morphism definition in Function.Core\n\nopen import Function.Core public\n  using (Morphism)\n\n------------------------------------------------------------------------\n-- Basic definitions\n\nHomomorphic\u2082 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nHomomorphic\u2082 _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7 = \u2200 {x y} \u2192 x \u223c\u2081 y \u2192 \u27e6 x \u27e7 \u223c\u2082 \u27e6 y \u27e7\n</pre>"},{"location":"md/Relation/Binary/Morphism/Structures/","title":"Relation.Binary.Morphism.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Order morphisms\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\n\nmodule Relation.Binary.Morphism.Structures\n  {a b} {A : Set a} {B : Set b}\n  where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Definitions using (Injective; Surjective; Bijective)\nopen import Level using (Level; _\u2294_)\n\nopen import Relation.Binary.Morphism.Definitions A B\n\nprivate\n  variable\n    \u2113\u2081 \u2113\u2082 \u2113\u2083 \u2113\u2084 : Level\n\n------------------------------------------------------------------------\n-- Relations\n------------------------------------------------------------------------\n\nrecord IsRelHomomorphism (_\u223c\u2081_ : Rel A \u2113\u2081) (_\u223c\u2082_ : Rel B \u2113\u2082)\n                         (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    cong : Homomorphic\u2082 _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n\n\nrecord IsRelMonomorphism (_\u223c\u2081_ : Rel A \u2113\u2081) (_\u223c\u2082_ : Rel B \u2113\u2082)\n                         (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isHomomorphism : IsRelHomomorphism _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n    injective      : Injective _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n\n  open IsRelHomomorphism isHomomorphism public\n\n\nrecord IsRelIsomorphism (_\u223c\u2081_ : Rel A \u2113\u2081) (_\u223c\u2082_ : Rel B \u2113\u2082)\n                        (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isMonomorphism : IsRelMonomorphism _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n    surjective     : Surjective _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n\n  open IsRelMonomorphism isMonomorphism public\n\n  bijective : Bijective _\u223c\u2081_ _\u223c\u2082_ \u27e6_\u27e7\n  bijective = injective , surjective\n\n\n------------------------------------------------------------------------\n-- Orders\n------------------------------------------------------------------------\n\nrecord IsOrderHomomorphism (_\u2248\u2081_ : Rel A \u2113\u2081) (_\u2248\u2082_ : Rel B \u2113\u2082)\n                           (_\u2272\u2081_ : Rel A \u2113\u2083) (_\u2272\u2082_ : Rel B \u2113\u2084)\n                           (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083 \u2294 \u2113\u2084)\n                           where\n  field\n    cong  : Homomorphic\u2082 _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    mono  : Homomorphic\u2082 _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n\n  module Eq where\n    isRelHomomorphism : IsRelHomomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelHomomorphism = record { cong = cong }\n\n  isRelHomomorphism : IsRelHomomorphism _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n  isRelHomomorphism = record { cong = mono }\n\n\nrecord IsOrderMonomorphism (_\u2248\u2081_ : Rel A \u2113\u2081) (_\u2248\u2082_ : Rel B \u2113\u2082)\n                           (_\u2272\u2081_ : Rel A \u2113\u2083) (_\u2272\u2082_ : Rel B \u2113\u2084)\n                           (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083 \u2294 \u2113\u2084)\n                           where\n  field\n    isOrderHomomorphism : IsOrderHomomorphism _\u2248\u2081_ _\u2248\u2082_ _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n    injective           : Injective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    cancel              : Injective _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n\n  open IsOrderHomomorphism isOrderHomomorphism public\n    hiding (module Eq)\n\n  module Eq where\n    isRelMonomorphism : IsRelMonomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelMonomorphism = record\n      { isHomomorphism = IsOrderHomomorphism.Eq.isRelHomomorphism isOrderHomomorphism\n      ; injective      = injective\n      }\n\n  isRelMonomorphism : IsRelMonomorphism _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n  isRelMonomorphism = record\n    { isHomomorphism = isRelHomomorphism\n    ; injective      = cancel\n    }\n\n\nrecord IsOrderIsomorphism (_\u2248\u2081_ : Rel A \u2113\u2081) (_\u2248\u2082_ : Rel B \u2113\u2082)\n                          (_\u2272\u2081_ : Rel A \u2113\u2083) (_\u2272\u2082_ : Rel B \u2113\u2084)\n                          (\u27e6_\u27e7 : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083 \u2294 \u2113\u2084)\n                          where\n  field\n    isOrderMonomorphism : IsOrderMonomorphism _\u2248\u2081_ _\u2248\u2082_ _\u2272\u2081_ _\u2272\u2082_ \u27e6_\u27e7\n    surjective          : Surjective _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n\n  open IsOrderMonomorphism isOrderMonomorphism public\n    hiding (module Eq)\n\n  module Eq where\n    isRelIsomorphism : IsRelIsomorphism _\u2248\u2081_ _\u2248\u2082_ \u27e6_\u27e7\n    isRelIsomorphism = record\n      { isMonomorphism = IsOrderMonomorphism.Eq.isRelMonomorphism isOrderMonomorphism\n      ; surjective     = surjective\n      }\n</pre>"},{"location":"md/Relation/Binary/Properties/Poset/","title":"Relation.Binary.Properties.Poset","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties satisfied by posets\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Poset; StrictPartialOrder)\n\nmodule Relation.Binary.Properties.Poset\n   {p\u2081 p\u2082 p\u2083} (P : Poset p\u2081 p\u2082 p\u2083) where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (flip; _\u2218_)\nopen import Relation.Binary.Core using (Rel; _Preserves_\u27f6_)\nimport Relation.Binary.Consequences as Consequences\n  using (mono\u21d2cong; antimono\u21d2cong)\nopen import Relation.Binary.Definitions\n  using (_Respects\u02e1_; _Respects\u02b3_; Decidable)\nopen import Relation.Binary.Structures\n  using (IsPartialOrder; IsStrictPartialOrder; IsDecPartialOrder)\nopen import Relation.Nullary.Decidable.Core using (yes; no)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\n\nopen Poset P renaming (Carrier to A)\n\nimport Relation.Binary.Construct.NonStrictToStrict _\u2248_ _\u2264_ as ToStrict\nimport Relation.Binary.Properties.Preorder preorder as PreorderProperties\n\n\n------------------------------------------------------------------------\n-- The _\u2265_ relation is also a poset.\n\nopen PreorderProperties public\n  using () renaming\n  ( converse-isPreorder to \u2265-isPreorder\n  ; converse-preorder   to \u2265-preorder\n  )\n\n\u2265-isPartialOrder : IsPartialOrder _\u2248_ _\u2265_\n\u2265-isPartialOrder = record\n  { isPreorder   = \u2265-isPreorder\n  ; antisym      = flip antisym\n  }\n\n\u2265-poset : Poset p\u2081 p\u2082 p\u2083\n\u2265-poset = record\n  { isPartialOrder = \u2265-isPartialOrder\n  }\n\nopen Poset \u2265-poset public\n  using () renaming\n  ( refl      to \u2265-refl\n  ; reflexive to \u2265-reflexive\n  ; trans     to \u2265-trans\n  ; antisym   to \u2265-antisym\n  )\n\n------------------------------------------------------------------------\n-- Negated order\n\n\u2270-resp\u02e1-\u2248 : _\u2270_ Respects\u02e1 _\u2248_\n\u2270-resp\u02e1-\u2248 x\u2248y = _\u2218 \u2264-resp\u02e1-\u2248 (Eq.sym x\u2248y)\n\n\u2270-resp\u02b3-\u2248 : _\u2270_ Respects\u02b3 _\u2248_\n\u2270-resp\u02b3-\u2248 x\u2248y = _\u2218 \u2264-resp\u02b3-\u2248 (Eq.sym x\u2248y)\n\n------------------------------------------------------------------------\n-- Partial orders can be turned into strict partial orders\n\ninfix 4 _&lt;_\n\n_&lt;_ : Rel A _\n_&lt;_ = ToStrict._&lt;_\n\n&lt;-isStrictPartialOrder : IsStrictPartialOrder _\u2248_ _&lt;_\n&lt;-isStrictPartialOrder = ToStrict.&lt;-isStrictPartialOrder isPartialOrder\n\n&lt;-strictPartialOrder : StrictPartialOrder _ _ _\n&lt;-strictPartialOrder = record\n  { isStrictPartialOrder = &lt;-isStrictPartialOrder\n  }\n\nopen StrictPartialOrder &lt;-strictPartialOrder public\n  using (_\u226e_; &lt;-resp-\u2248; &lt;-resp\u02b3-\u2248; &lt;-resp\u02e1-\u2248)\n  renaming\n  ( irrefl to &lt;-irrefl\n  ; asym   to &lt;-asym\n  ; trans  to &lt;-trans\n  )\n\n&lt;\u21d2\u2249 : \u2200 {x y} \u2192 x &lt; y \u2192 x \u2249 y\n&lt;\u21d2\u2249 = ToStrict.&lt;\u21d2\u2249\n\n\u2264\u2227\u2249\u21d2&lt; : \u2200 {x y} \u2192 x \u2264 y \u2192 x \u2249 y \u2192 x &lt; y\n\u2264\u2227\u2249\u21d2&lt; = ToStrict.\u2264\u2227\u2249\u21d2&lt;\n\n&lt;\u21d2\u2271 : \u2200 {x y} \u2192 x &lt; y \u2192 y \u2270 x\n&lt;\u21d2\u2271 = ToStrict.&lt;\u21d2\u2271 antisym\n\n\u2264\u21d2\u226f : \u2200 {x y} \u2192 x \u2264 y \u2192 y \u226e x\n\u2264\u21d2\u226f = ToStrict.\u2264\u21d2\u226f antisym\n\n------------------------------------------------------------------------\n-- If \u2264 is decidable then so is \u2248\n\n\u2264-dec\u21d2\u2248-dec : Decidable _\u2264_ \u2192 Decidable _\u2248_\n\u2264-dec\u21d2\u2248-dec _\u2264?_ x y with x \u2264? y | y \u2264? x\n... | yes x\u2264y | yes y\u2264x = yes (antisym x\u2264y y\u2264x)\n... | yes x\u2264y | no  y\u2270x = no \u03bb x\u2248y \u2192 contradiction (reflexive (Eq.sym x\u2248y)) y\u2270x\n... | no  x\u2270y | _       = no \u03bb x\u2248y \u2192 contradiction (reflexive x\u2248y) x\u2270y\n\n\u2264-dec\u21d2isDecPartialOrder : Decidable _\u2264_ \u2192 IsDecPartialOrder _\u2248_ _\u2264_\n\u2264-dec\u21d2isDecPartialOrder _\u2264?_ = record\n  { isPartialOrder = isPartialOrder\n  ; _\u225f_            = \u2264-dec\u21d2\u2248-dec _\u2264?_\n  ; _\u2264?_           = _\u2264?_\n  }\n\n------------------------------------------------------------------------\n-- Other properties\n\nmono\u21d2cong : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2264_ \u2192 f Preserves _\u2248_ \u27f6 _\u2248_\nmono\u21d2cong = Consequences.mono\u21d2cong _\u2248_ _\u2248_ Eq.sym reflexive antisym\n\nantimono\u21d2cong : \u2200 {f} \u2192 f Preserves _\u2264_ \u27f6 _\u2265_ \u2192 f Preserves _\u2248_ \u27f6 _\u2248_\nantimono\u21d2cong = Consequences.antimono\u21d2cong _\u2248_ _\u2248_ Eq.sym reflexive antisym\n</pre>"},{"location":"md/Relation/Binary/Properties/Preorder/","title":"Relation.Binary.Properties.Preorder","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties satisfied by preorders\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Preorder; Setoid)\n\nmodule Relation.Binary.Properties.Preorder\n  {p\u2081 p\u2082 p\u2083} (P : Preorder p\u2081 p\u2082 p\u2083) where\n\nopen import Function.Base using (flip)\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; swap)\nimport Relation.Binary.Construct.Flip.EqAndOrd as EqAndOrd\n  using (isPreorder; preorder)\nopen import Relation.Binary.Structures using (IsPreorder)\n\nopen Preorder P\n\n\n------------------------------------------------------------------------\n-- The converse relation is also a preorder.\n\nconverse-isPreorder : IsPreorder _\u2248_ _\u2273_\nconverse-isPreorder = EqAndOrd.isPreorder isPreorder\n\nconverse-preorder : Preorder p\u2081 p\u2082 p\u2083\nconverse-preorder = EqAndOrd.preorder P\n\n------------------------------------------------------------------------\n-- For every preorder there is an induced equivalence\n\nInducedEquivalence : Setoid _ _\nInducedEquivalence = record\n  { _\u2248_           = \u03bb x y \u2192 x \u2272 y \u00d7 x \u2273 y\n  ; isEquivalence = record\n    { refl  = (refl , refl)\n    ; sym   = swap\n    ; trans = Product.zip trans (flip trans)\n    }\n  }\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\ninvIsPreorder = converse-isPreorder\n{-# WARNING_ON_USAGE invIsPreorder\n\"Warning: invIsPreorder was deprecated in v2.0.\nPlease use converse-isPreorder instead.\"\n#-}\ninvPreorder = converse-preorder\n{-# WARNING_ON_USAGE invPreorder\n\"Warning: invPreorder was deprecated in v2.0.\nPlease use converse-preorder instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Properties/Setoid/","title":"Relation.Binary.Properties.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Additional properties for setoids\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Setoid; Preorder; Poset)\n\nmodule Relation.Binary.Properties.Setoid {a \u2113} (S : Setoid a \u2113) where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (_\u2218_; id; _$_; flip)\nopen import Relation.Binary.Core using (_\u21d2_)\nopen import Relation.Binary.Construct.Composition\n  using (_\u037e_; implies\u02e1; transitive\u21d2\u2248\u037e\u2248\u2286\u2248)\nopen import Relation.Binary.Definitions\n  using (Symmetric; _Respects\u02e1_; _Respects\u02b3_; _Respects\u2082_; Irreflexive)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Structures using (IsPreorder; IsPartialOrder)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\n\nopen Setoid S\n\n------------------------------------------------------------------------\n-- Every setoid is a preorder and partial order with respect to\n-- propositional equality\n\nisPreorder : IsPreorder _\u2261_ _\u2248_\nisPreorder = record\n  { isEquivalence = record\n    { refl  = \u2261.refl\n    ; sym   = \u2261.sym\n    ; trans = \u2261.trans\n    }\n  ; reflexive     = reflexive\n  ; trans         = trans\n  }\n\n\u2248-isPreorder : IsPreorder _\u2248_ _\u2248_\n\u2248-isPreorder = record\n  { isEquivalence = isEquivalence\n  ; reflexive     = id\n  ; trans         = trans\n  }\n\n\u2248-isPartialOrder : IsPartialOrder _\u2248_ _\u2248_\n\u2248-isPartialOrder = record\n  { isPreorder = \u2248-isPreorder\n  ; antisym    = \u03bb i\u2248j _ \u2192 i\u2248j\n  }\n\npreorder : Preorder a a \u2113\npreorder = record\n  { isPreorder = isPreorder\n  }\n\n\u2248-preorder : Preorder a \u2113 \u2113\n\u2248-preorder = record\n  { isPreorder = \u2248-isPreorder\n  }\n\n\u2248-poset : Poset a \u2113 \u2113\n\u2248-poset = record\n  { isPartialOrder = \u2248-isPartialOrder\n  }\n\n------------------------------------------------------------------------\n-- Properties of _\u2249_\n\n\u2249-sym :  Symmetric _\u2249_\n\u2249-sym x\u2249y =  x\u2249y \u2218 sym\n\n\u2249-resp\u02e1 : _\u2249_ Respects\u02e1 _\u2248_\n\u2249-resp\u02e1 x\u2248x\u2032 x\u2249y = x\u2249y \u2218 trans x\u2248x\u2032\n\n\u2249-resp\u02b3 : _\u2249_ Respects\u02b3 _\u2248_\n\u2249-resp\u02b3 y\u2248y\u2032 x\u2249y x\u2248y\u2032 = x\u2249y $ trans x\u2248y\u2032 (sym y\u2248y\u2032)\n\n\u2249-resp\u2082 : _\u2249_ Respects\u2082 _\u2248_\n\u2249-resp\u2082 = \u2249-resp\u02b3 , \u2249-resp\u02e1\n\n\u2249-irrefl : Irreflexive _\u2248_ _\u2249_\n\u2249-irrefl x\u2248y x\u2249y = contradiction x\u2248y x\u2249y\n\n------------------------------------------------------------------------\n-- Equality is closed under composition\n\n\u2248\u037e\u2248\u21d2\u2248 : _\u2248_ \u037e _\u2248_ \u21d2 _\u2248_\n\u2248\u037e\u2248\u21d2\u2248 = transitive\u21d2\u2248\u037e\u2248\u2286\u2248 _ trans\n\n\u2248\u21d2\u2248\u037e\u2248 : _\u2248_ \u21d2 _\u2248_ \u037e _\u2248_\n\u2248\u21d2\u2248\u037e\u2248 = implies\u02e1 _\u2248_ _\u2248_ refl id\n\n------------------------------------------------------------------------\n-- Other properties\n\nresp\u02b3-flip : _\u2248_ Respects\u02b3 (flip _\u2248_)\nresp\u02b3-flip y\u2248z x\u2248z = trans x\u2248z (sym y\u2248z)\n\nresp\u02e1-flip : _\u2248_ Respects\u02e1 (flip _\u2248_)\nresp\u02e1-flip = trans\n\n</pre>"},{"location":"md/Relation/Binary/Properties/TotalOrder/","title":"Relation.Binary.Properties.TotalOrder","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties satisfied by total orders\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (TotalOrder; DecTotalOrder)\n\nmodule Relation.Binary.Properties.TotalOrder\n  {t\u2081 t\u2082 t\u2083} (T : TotalOrder t\u2081 t\u2082 t\u2083) where\n\nopen import Data.Product.Base using (proj\u2081)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nimport Relation.Binary.Construct.Flip.EqAndOrd as EqAndOrd\nopen import Relation.Binary.Definitions using (Decidable)\nopen import Relation.Binary.Structures using (IsTotalOrder)\nopen import Relation.Binary.Consequences using (total\u2227dec\u21d2dec)\n\nopen TotalOrder T\n\nimport Relation.Binary.Construct.NonStrictToStrict _\u2248_ _\u2264_ as ToStrict\nimport Relation.Binary.Properties.Poset poset as PosetProperties\n\n------------------------------------------------------------------------\n-- Total orders are almost decidable total orders\n\ndecTotalOrder : Decidable _\u2248_ \u2192 DecTotalOrder _ _ _\ndecTotalOrder \u225f = record\n  { isDecTotalOrder = record\n    { isTotalOrder = isTotalOrder\n    ; _\u225f_          = \u225f\n    ; _\u2264?_         = total\u2227dec\u21d2dec reflexive antisym total \u225f\n    }\n  }\n\n------------------------------------------------------------------------\n-- _\u2265_ - the flipped relation is also a total order\n\nopen PosetProperties public\n  using\n  ( \u2265-refl\n  ; \u2265-reflexive\n  ; \u2265-trans\n  ; \u2265-antisym\n  ; \u2265-isPreorder\n  ; \u2265-isPartialOrder\n  ; \u2265-preorder\n  ; \u2265-poset\n  )\n\n\u2265-isTotalOrder : IsTotalOrder _\u2248_ _\u2265_\n\u2265-isTotalOrder = EqAndOrd.isTotalOrder isTotalOrder\n\n\u2265-totalOrder : TotalOrder _ _ _\n\u2265-totalOrder = record\n  { isTotalOrder = \u2265-isTotalOrder\n  }\n\nopen TotalOrder \u2265-totalOrder public\n  using () renaming (total to \u2265-total)\n\n------------------------------------------------------------------------\n-- _&lt;_ - the strict version is a strict partial order\n\n-- Note that total orders can NOT be turned into strict total orders as\n-- in order to distinguish between the _\u2264_ and _&lt;_ cases we must have\n-- decidable equality _\u2248_.\n\nopen PosetProperties public\n  using\n  ( _&lt;_\n  ; &lt;-resp-\u2248\n  ; &lt;-resp\u02b3-\u2248\n  ; &lt;-resp\u02e1-\u2248\n  ; &lt;-irrefl\n  ; &lt;-asym\n  ; &lt;-trans\n  ; &lt;-isStrictPartialOrder\n  ; &lt;-strictPartialOrder\n  ; &lt;\u21d2\u2249\n  ; \u2264\u2227\u2249\u21d2&lt;\n  ; &lt;\u21d2\u2271\n  ; \u2264\u21d2\u226f\n  )\n\n------------------------------------------------------------------------\n-- _\u2270_ - the negated order\n\nopen PosetProperties public\n  using\n  ( \u2270-resp\u02b3-\u2248\n  ; \u2270-resp\u02e1-\u2248\n  )\n\n\u2270\u21d2&gt; : \u2200 {x y} \u2192 x \u2270 y \u2192 y &lt; x\n\u2270\u21d2&gt; = ToStrict.\u2270\u21d2&gt; Eq.sym reflexive total\n\n\u2270\u21d2\u2265 : \u2200 {x y} \u2192 x \u2270 y \u2192 y \u2264 x\n\u2270\u21d2\u2265 x\u2270y = proj\u2081 (\u2270\u21d2&gt; x\u2270y)\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/","title":"Relation.Binary.PropositionalEquality","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional (intensional) equality\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality where\n\nopen import Axiom.UniquenessOfIdentityProofs\nopen import Function.Base using (id; _\u2218_)\nimport Function.Dependent.Bundles as Dependent using (Func)\nopen import Function.Indexed.Relation.Binary.Equality using (\u2261-setoid)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Nullary.Irrelevant using (Irrelevant)\nopen import Relation.Nullary.Decidable using (yes; no; dec-yes-irr; dec-no)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Definitions using (DecidableEquality)\nopen import Relation.Binary.Indexed.Heterogeneous\n  using (IndexedSetoid)\nimport Relation.Binary.Indexed.Heterogeneous.Construct.Trivial\n  as Trivial using (indexedSetoid)\n\nprivate\n  variable\n    a b c \u2113 p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Re-export contents modules that make up the parts\n\nopen import Relation.Binary.PropositionalEquality.Core public\nopen import Relation.Binary.PropositionalEquality.Properties public\nopen import Relation.Binary.PropositionalEquality.Algebra public\n\n------------------------------------------------------------------------\n-- Pointwise equality\n\n_\u2192-setoid_ : \u2200 (A : Set a) (B : Set b) \u2192 Setoid _ _\nA \u2192-setoid B = \u2261-setoid A (Trivial.indexedSetoid (setoid B))\n\n:\u2192-to-\u03a0 : \u2200 {A : Set a} {B : IndexedSetoid A b \u2113} \u2192\n          ((x : A) \u2192 IndexedSetoid.Carrier B x) \u2192\n          Dependent.Func (setoid A) B\n:\u2192-to-\u03a0 {B = B} f = record\n  { to = f\n  ; cong = \u03bb { refl \u2192 IndexedSetoid.refl B }\n  }\n\n\u2192-to-\u27f6 : \u2200 {A : Set a} {B : Setoid b \u2113} \u2192\n         (A \u2192 Setoid.Carrier B) \u2192\n         Dependent.Func (setoid A) (Trivial.indexedSetoid B)\n\u2192-to-\u27f6 = :\u2192-to-\u03a0\n\n------------------------------------------------------------------------\n-- More complex rearrangement lemmas\n\n-- A lemma that is very similar to Lemma\u00a02.4.3 from the HoTT book.\n\nnaturality : \u2200 {x y} {x\u2261y : x \u2261 y} {f g : A \u2192 B}\n             (f\u2261g : \u2200 x \u2192 f x \u2261 g x) \u2192\n             trans (cong f x\u2261y) (f\u2261g y) \u2261 trans (f\u2261g x) (cong g x\u2261y)\nnaturality {x = x} {x\u2261y = refl} f\u2261g =\n  f\u2261g x               \u2261\u27e8 sym (trans-refl\u02b3 _) \u27e9\n  trans (f\u2261g x) refl  \u220e\n  where open \u2261-Reasoning\n\n-- A lemma that is very similar to Corollary\u00a02.4.4 from the HoTT book.\n\ncong-\u2261id : \u2200 {f : A \u2192 A} {x : A} (f\u2261id : \u2200 x \u2192 f x \u2261 x) \u2192\n           cong f (f\u2261id x) \u2261 f\u2261id (f x)\ncong-\u2261id {f = f} {x} f\u2261id = begin\n  cong f fx\u2261x                                    \u2261\u27e8 sym (trans-refl\u02b3 _) \u27e9\n  trans (cong f fx\u2261x) refl                       \u2261\u27e8 cong (trans _) (sym (trans-sym\u02b3 fx\u2261x)) \u27e9\n  trans (cong f fx\u2261x) (trans fx\u2261x (sym fx\u2261x))    \u2261\u27e8 sym (trans-assoc (cong f fx\u2261x)) \u27e9\n  trans (trans (cong f fx\u2261x) fx\u2261x) (sym fx\u2261x)    \u2261\u27e8 cong (\u03bb p \u2192 trans p (sym _)) (naturality f\u2261id) \u27e9\n  trans (trans f\u00b2x\u2261x (cong id fx\u2261x)) (sym fx\u2261x)  \u2261\u27e8 cong (\u03bb p \u2192 trans (trans f\u00b2x\u2261x p) (sym fx\u2261x)) (cong-id _) \u27e9\n  trans (trans f\u00b2x\u2261x fx\u2261x) (sym fx\u2261x)            \u2261\u27e8 trans-assoc f\u00b2x\u2261x \u27e9\n  trans f\u00b2x\u2261x (trans fx\u2261x (sym fx\u2261x))            \u2261\u27e8 cong (trans _) (trans-sym\u02b3 fx\u2261x) \u27e9\n  trans f\u00b2x\u2261x refl                               \u2261\u27e8 trans-refl\u02b3 _ \u27e9\n  f\u2261id (f x)                                     \u220e\n  where open \u2261-Reasoning; fx\u2261x = f\u2261id x; f\u00b2x\u2261x = f\u2261id (f x)\n\nmodule _ (_\u225f_ : DecidableEquality A) {x y : A} where\n\n  \u2261-\u225f-identity : (eq : x \u2261 y) \u2192 x \u225f y \u2261 yes eq\n  \u2261-\u225f-identity eq = dec-yes-irr (x \u225f y) (Decidable\u21d2UIP.\u2261-irrelevant _\u225f_) eq\n\n  \u2262-\u225f-identity : (x\u2262y : x \u2262 y) \u2192 x \u225f y \u2261 no x\u2262y\n  \u2262-\u225f-identity = dec-no (x \u225f y)\n\n\n------------------------------------------------------------------------\n-- Inspect\n\n-- Inspect can be used when you want to pattern match on the result r\n-- of some expression e, and you also need to \"remember\" that r \u2261 e.\n\n-- See README.Inspect for an explanation of how/why to use this.\n\n-- Normally (but not always) the new `with ... in` syntax described at\n-- https://agda.readthedocs.io/en/v2.6.4/language/with-abstraction.html#with-abstraction-equality\n-- can be used instead.\"\n\nrecord Reveal_\u00b7_is_ {A : Set a} {B : A \u2192 Set b}\n                    (f : (x : A) \u2192 B x) (x : A) (y : B x) :\n                    Set (a \u2294 b) where\n  constructor [_]\n  field eq : f x \u2261 y\n\ninspect : \u2200 {A : Set a} {B : A \u2192 Set b}\n          (f : (x : A) \u2192 B x) (x : A) \u2192 Reveal f \u00b7 x is f x\ninspect f x = [ refl ]\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nisPropositional : Set a \u2192 Set a\nisPropositional = Irrelevant\n\n{-# WARNING_ON_USAGE isPropositional\n\"Warning: isPropositional was deprecated in v2.0.\nPlease use Relation.Nullary.Irrelevant instead. \"\n#-}\n\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/Algebra/","title":"Relation.Binary.PropositionalEquality.Algebra","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional (intensional) equality - Algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality.Algebra where\n\nopen import Algebra.Bundles using (Magma)\nopen import Algebra.Core using (Op\u2082)\nopen import Algebra.Structures using (IsMagma)\nopen import Level using (Level)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; cong\u2082)\nopen import Relation.Binary.PropositionalEquality.Properties using (isEquivalence)\n\nprivate\n  variable\n    a : Level\n    A : Set a\n\n------------------------------------------------------------------------\n-- Any operation forms a magma over _\u2261_\n\nisMagma : (_\u2219_ : Op\u2082 A) \u2192 IsMagma _\u2261_ _\u2219_\nisMagma _\u2219_ = record\n  { isEquivalence = isEquivalence\n  ; \u2219-cong        = cong\u2082 _\u2219_\n  }\n\nmagma : (_\u2219_ : Op\u2082 A) \u2192 Magma _ _\nmagma _\u2219_ = record\n  { isMagma = isMagma _\u2219_\n  }\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/Core/","title":"Relation.Binary.PropositionalEquality.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional equality\n--\n-- This file contains some core definitions which are re-exported by\n-- Relation.Binary.PropositionalEquality.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality.Core where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (_\u2218_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Core using (Rel; REL)\nopen import Relation.Binary.Definitions\n  using (Symmetric; Transitive; Substitutive\n        ; _Respects_; _Respects\u02e1_; _Respects\u02b3_; _Respects\u2082_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nprivate\n  variable\n    a b \u2113 : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Propositional equality\n\nopen import Agda.Builtin.Equality public\n\ninfix 4 _\u2262_\n_\u2262_ : {A : Set a} \u2192 Rel A a\nx \u2262 y = \u00ac x \u2261 y\n\n------------------------------------------------------------------------\n-- Pointwise equality\n\ninfix 4 _\u2257_\n\n_\u2257_ : (f g : A \u2192 B) \u2192 Set _\n_\u2257_ {A = A} {B = B} f g = \u2200 x \u2192 f x \u2261 g x\n\n\n------------------------------------------------------------------------\n-- A variant of `refl` where the argument is explicit\n\npattern erefl x = refl {x = x}\n\n------------------------------------------------------------------------\n-- Congruence lemmas\n\ncong : \u2200 (f : A \u2192 B) {x y} \u2192 x \u2261 y \u2192 f x \u2261 f y\ncong f refl = refl\n\ncong\u2032 : \u2200 {f : A \u2192 B} x \u2192 f x \u2261 f x\ncong\u2032 _ = refl\n\nicong : \u2200 {f : A \u2192 B} {x y} \u2192 x \u2261 y \u2192 f x \u2261 f y\nicong = cong _\n\nicong\u2032 : \u2200 {f : A \u2192 B} x \u2192 f x \u2261 f x\nicong\u2032 _ = refl\n\ncong\u2082 : \u2200 (f : A \u2192 B \u2192 C) {x y u v} \u2192 x \u2261 y \u2192 u \u2261 v \u2192 f x u \u2261 f y v\ncong\u2082 f refl refl = refl\n\ncong-app : \u2200 {A : Set a} {B : A \u2192 Set b} {f g : (x : A) \u2192 B x} \u2192\n           f \u2261 g \u2192 (x : A) \u2192 f x \u2261 g x\ncong-app refl x = refl\n\n------------------------------------------------------------------------\n-- Properties of _\u2261_\n\nsym : Symmetric {A = A} _\u2261_\nsym refl = refl\n\ntrans : Transitive {A = A} _\u2261_\ntrans refl eq = eq\n\nsubst : Substitutive {A = A} _\u2261_ \u2113\nsubst P refl p = p\n\nsubst\u2082 : \u2200 (_\u223c_ : REL A B \u2113) {x y u v} \u2192 x \u2261 y \u2192 u \u2261 v \u2192 x \u223c u \u2192 y \u223c v\nsubst\u2082 _ refl refl p = p\n\nresp : \u2200 (P : A \u2192 Set \u2113) \u2192 P Respects _\u2261_\nresp P refl p = p\n\nresp\u02e1 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u02e1 _\u2261_\nresp\u02e1 _\u223c_ refl x\u223cy = x\u223cy\n\nresp\u02b3 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u02b3 _\u2261_\nresp\u02b3 _\u223c_ refl x\u223cy = x\u223cy\n\nresp\u2082 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u2082 _\u2261_\nresp\u2082 _\u223c_ = resp\u02b3 _\u223c_ , resp\u02e1 _\u223c_\n\n------------------------------------------------------------------------\n-- Properties of _\u2262_\n\n\u2262-sym : Symmetric {A = A} _\u2262_\n\u2262-sym x\u2262y =  x\u2262y \u2218 sym\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/Properties/","title":"Relation.Binary.PropositionalEquality.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional equality\n--\n-- This file contains some core properies of propositional equality\n-- which are re-exported by Relation.Binary.PropositionalEquality. They\n-- are ``equality rearrangement'' lemmas.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality.Properties where\n\nopen import Function.Base using (id; _\u2218_)\nopen import Level using (Level)\nopen import Relation.Binary.Bundles using (Setoid; DecSetoid; Preorder; Poset)\nopen import Relation.Binary.Structures\n  using (IsEquivalence; IsDecEquivalence; IsPreorder; IsPartialOrder)\nopen import Relation.Binary.Definitions using (DecidableEquality)\nimport Relation.Binary.Properties.Setoid as Setoid\n  using (\u2248-isPreorder; \u2248-isPartialOrder; \u2248-preorder; \u2248-poset)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; cong; refl; subst; trans; sym; subst\u2082; cong\u2082)\nopen import Relation.Binary.Reasoning.Syntax\nopen import Relation.Unary using (Pred)\n\n\n\nprivate\n  variable\n    a b c p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Standard eliminator for the propositional equality type\n\nJ : {A : Set a} {x : A} (B : (y : A) \u2192 x \u2261 y \u2192 Set b)\n    {y : A} (p : x \u2261 y) \u2192 B x refl \u2192 B y p\nJ B refl b = b\n\n------------------------------------------------------------------------\n-- Binary and/or dependent versions of standard operations on equality\n\ndcong : \u2200 {A : Set a} {B : A \u2192 Set b} (f : (x : A) \u2192 B x) {x y}\n      \u2192 (p : x \u2261 y) \u2192 subst B p (f x) \u2261 f y\ndcong f refl = refl\n\ndcong\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : Set c}\n         (f : (x : A) \u2192 B x \u2192 C) {x\u2081 x\u2082 y\u2081 y\u2082}\n       \u2192 (p : x\u2081 \u2261 x\u2082) \u2192 subst B p y\u2081 \u2261 y\u2082\n       \u2192 f x\u2081 y\u2081 \u2261 f x\u2082 y\u2082\ndcong\u2082 f refl refl = refl\n\ndsubst\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} (C : (x : A) \u2192 B x \u2192 Set c)\n          {x\u2081 x\u2082 y\u2081 y\u2082} (p : x\u2081 \u2261 x\u2082) \u2192 subst B p y\u2081 \u2261 y\u2082\n        \u2192 C x\u2081 y\u2081 \u2192 C x\u2082 y\u2082\ndsubst\u2082 C refl refl c = c\n\nddcong\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : (x : A) \u2192 B x \u2192 Set c}\n         (f : (x : A) (y : B x) \u2192 C x y) {x\u2081 x\u2082 y\u2081 y\u2082}\n         (p : x\u2081 \u2261 x\u2082) (q : subst B p y\u2081 \u2261 y\u2082)\n       \u2192 dsubst\u2082 C p q (f x\u2081 y\u2081) \u2261 f x\u2082 y\u2082\nddcong\u2082 f refl refl = refl\n\n------------------------------------------------------------------------\n-- Various equality rearrangement lemmas\n\ntrans-refl\u02b3 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans p refl \u2261 p\ntrans-refl\u02b3 refl = refl\n\ntrans-assoc : \u2200 {x y z u : A} (p : x \u2261 y) {q : y \u2261 z} {r : z \u2261 u} \u2192\n  trans (trans p q) r \u2261 trans p (trans q r)\ntrans-assoc refl = refl\n\ntrans-sym\u02e1 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans (sym p) p \u2261 refl\ntrans-sym\u02e1 refl = refl\n\ntrans-sym\u02b3 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans p (sym p) \u2261 refl\ntrans-sym\u02b3 refl = refl\n\ntrans-injective\u02e1 : \u2200 {x y z : A} {p\u2081 p\u2082 : x \u2261 y} (q : y \u2261 z) \u2192\n                   trans p\u2081 q \u2261 trans p\u2082 q \u2192 p\u2081 \u2261 p\u2082\ntrans-injective\u02e1 refl = subst\u2082 _\u2261_ (trans-refl\u02b3 _) (trans-refl\u02b3 _)\n\ntrans-injective\u02b3 : \u2200 {x y z : A} (p : x \u2261 y) {q\u2081 q\u2082 : y \u2261 z} \u2192\n                   trans p q\u2081 \u2261 trans p q\u2082 \u2192 q\u2081 \u2261 q\u2082\ntrans-injective\u02b3 refl eq = eq\n\ncong-id : \u2200 {x y : A} (p : x \u2261 y) \u2192 cong id p \u2261 p\ncong-id refl = refl\n\ncong-\u2218 : \u2200 {x y : A} {f : B \u2192 C} {g : A \u2192 B} (p : x \u2261 y) \u2192\n         cong (f \u2218 g) p \u2261 cong f (cong g p)\ncong-\u2218 refl = refl\n\nsym-cong : \u2200 {x y : A} {f : A \u2192 B} (p : x \u2261 y) \u2192 sym (cong f p) \u2261 cong f (sym p)\nsym-cong refl = refl\n\ntrans-cong : \u2200 {x y z : A} {f : A \u2192 B} (p : x \u2261 y) {q : y \u2261 z} \u2192\n             trans (cong f p) (cong f q) \u2261 cong f (trans p q)\ntrans-cong refl = refl\n\ncong\u2082-refl\u02e1 : \u2200 {_\u2219_ : A \u2192 B \u2192 C} {x u v} \u2192 (p : u \u2261 v) \u2192\n              cong\u2082 _\u2219_ refl p \u2261 cong (x \u2219_) p\ncong\u2082-refl\u02e1 refl = refl\n\ncong\u2082-refl\u02b3 : \u2200 {_\u2219_ : A \u2192 B \u2192 C} {x y u} \u2192 (p : x \u2261 y) \u2192\n              cong\u2082 _\u2219_ p refl \u2261 cong (_\u2219 u) p\ncong\u2082-refl\u02b3 refl = refl\n\nmodule _ {P : Pred A p} {x y : A} where\n\n  subst-injective : \u2200 (x\u2261y : x \u2261 y) {p q : P x} \u2192\n                    subst P x\u2261y p \u2261 subst P x\u2261y q \u2192 p \u2261 q\n  subst-injective refl p\u2261q = p\u2261q\n\n  subst-subst : \u2200 {z} (x\u2261y : x \u2261 y) {y\u2261z : y \u2261 z} {p : P x} \u2192\n                subst P y\u2261z (subst P x\u2261y p) \u2261 subst P (trans x\u2261y y\u2261z) p\n  subst-subst refl = refl\n\n  subst-subst-sym : (x\u2261y : x \u2261 y) {p : P y} \u2192\n                    subst P x\u2261y (subst P (sym x\u2261y) p) \u2261 p\n  subst-subst-sym refl = refl\n\n  subst-sym-subst : (x\u2261y : x \u2261 y) {p : P x} \u2192\n                    subst P (sym x\u2261y) (subst P x\u2261y p) \u2261 p\n  subst-sym-subst refl = refl\n\nsubst-\u2218 : \u2200 {x y : A} {P : Pred B p} {f : A \u2192 B}\n          (x\u2261y : x \u2261 y) {p : P (f x)} \u2192\n          subst (P \u2218 f) x\u2261y p \u2261 subst P (cong f x\u2261y) p\nsubst-\u2218 refl = refl\n\n-- Lemma 2.3.11 in the HoTT book, and `transport_map` in the UniMath\n-- library\nsubst-application\u2032 : \u2200 {a b\u2081 b\u2082} {A : Set a}\n                     (B\u2081 : A \u2192 Set b\u2081) {B\u2082 : A \u2192 Set b\u2082}\n                     {x\u2081 x\u2082 : A} {y : B\u2081 x\u2081}\n                     (g : \u2200 x \u2192 B\u2081 x \u2192 B\u2082 x) (eq : x\u2081 \u2261 x\u2082) \u2192\n                     subst B\u2082 eq (g x\u2081 y) \u2261 g x\u2082 (subst B\u2081 eq y)\nsubst-application\u2032 _ _ refl = refl\n\nsubst-application : \u2200 {a\u2081 a\u2082 b\u2081 b\u2082} {A\u2081 : Set a\u2081} {A\u2082 : Set a\u2082}\n                    (B\u2081 : A\u2081 \u2192 Set b\u2081) {B\u2082 : A\u2082 \u2192 Set b\u2082}\n                    {f : A\u2082 \u2192 A\u2081} {x\u2081 x\u2082 : A\u2082} {y : B\u2081 (f x\u2081)}\n                    (g : \u2200 x \u2192 B\u2081 (f x) \u2192 B\u2082 x) (eq : x\u2081 \u2261 x\u2082) \u2192\n                    subst B\u2082 eq (g x\u2081 y) \u2261 g x\u2082 (subst B\u2081 (cong f eq) y)\nsubst-application _ _ refl = refl\n\n------------------------------------------------------------------------\n-- Structure of equality as a binary relation\n\nisEquivalence : IsEquivalence {A = A} _\u2261_\nisEquivalence = record\n  { refl  = refl\n  ; sym   = sym\n  ; trans = trans\n  }\n\nisDecEquivalence : DecidableEquality A \u2192 IsDecEquivalence _\u2261_\nisDecEquivalence _\u225f_ = record\n  { isEquivalence = isEquivalence\n  ; _\u225f_           = _\u225f_\n  }\n\nsetoid : Set a \u2192 Setoid _ _\nsetoid A = record\n  { Carrier       = A\n  ; _\u2248_           = _\u2261_\n  ; isEquivalence = isEquivalence\n  }\n\ndecSetoid : DecidableEquality A \u2192 DecSetoid _ _\ndecSetoid _\u225f_ = record\n  { _\u2248_              = _\u2261_\n  ; isDecEquivalence = isDecEquivalence _\u225f_\n  }\n\n------------------------------------------------------------------------\n-- Bundles for equality as a binary relation\n\nisPreorder : IsPreorder {A = A} _\u2261_ _\u2261_\nisPreorder = Setoid.\u2248-isPreorder (setoid _)\n\nisPartialOrder : IsPartialOrder {A = A} _\u2261_ _\u2261_\nisPartialOrder = Setoid.\u2248-isPartialOrder (setoid _)\n\npreorder : Set a \u2192 Preorder _ _ _\npreorder A = Setoid.\u2248-preorder (setoid A)\n\nposet : Set a \u2192 Poset _ _ _\nposet A = Setoid.\u2248-poset (setoid A)\n\n------------------------------------------------------------------------\n-- Reasoning\n\n-- This is a special instance of `Relation.Binary.Reasoning.Setoid`.\n-- Rather than instantiating the latter with (setoid A), we reimplement\n-- equation chains from scratch since then goals are printed much more\n-- readably.\nmodule \u2261-Reasoning {a} {A : Set a} where\n\n  open begin-syntax {A = A} _\u2261_ id public\n  open \u2261-syntax {A = A} _\u2261_ trans public\n  open end-syntax {A = A} _\u2261_ refl public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Base/Double/","title":"Relation.Binary.Reasoning.Base.Double","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The basic code for equational reasoning with two relations:\n-- equality and some other ordering.\n------------------------------------------------------------------------\n--\n-- See `Data.Nat.Properties` or `Relation.Binary.Reasoning.PartialOrder`\n-- for examples of how to instantiate this module.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Level using (_\u2294_)\nopen import Function.Base using (case_of_)\nopen import Relation.Nullary.Decidable.Core using (Dec; yes; no)\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\nopen import Relation.Binary.Definitions using (Reflexive; Trans)\nopen import Relation.Binary.Structures using (IsPreorder)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Reasoning.Syntax\n\n\nmodule Relation.Binary.Reasoning.Base.Double {a \u2113\u2081 \u2113\u2082} {A : Set a}\n  {_\u2248_ : Rel A \u2113\u2081} {_\u2272_ : Rel A \u2113\u2082} (isPreorder : IsPreorder _\u2248_ _\u2272_)\n  where\n\nopen IsPreorder isPreorder\n\n------------------------------------------------------------------------\n-- A datatype to hide the current relation type\n\ninfix 4 _IsRelatedTo_\n\ndata _IsRelatedTo_ (x y : A) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  nonstrict : (x\u2272y : x \u2272 y) \u2192 x IsRelatedTo y\n  equals    : (x\u2248y : x \u2248 y) \u2192 x IsRelatedTo y\n\nstart : _IsRelatedTo_ \u21d2 _\u2272_\nstart (equals x\u2248y) = reflexive x\u2248y\nstart (nonstrict x\u2272y) = x\u2272y\n\n\u2261-go : Trans _\u2261_ _IsRelatedTo_ _IsRelatedTo_\n\u2261-go x\u2261y (equals y\u2248z) = equals (case x\u2261y of \u03bb where \u2261.refl \u2192 y\u2248z)\n\u2261-go x\u2261y (nonstrict y\u2264z) = nonstrict (case x\u2261y of \u03bb where \u2261.refl \u2192 y\u2264z)\n\n\u2272-go : Trans _\u2272_ _IsRelatedTo_ _IsRelatedTo_\n\u2272-go x\u2272y (equals y\u2248z) = nonstrict (\u223c-resp\u02b3-\u2248 y\u2248z x\u2272y)\n\u2272-go x\u2272y (nonstrict y\u2272z) = nonstrict (trans x\u2272y y\u2272z)\n\n\u2248-go : Trans _\u2248_ _IsRelatedTo_ _IsRelatedTo_\n\u2248-go x\u2248y (equals y\u2248z) = equals (Eq.trans x\u2248y y\u2248z)\n\u2248-go x\u2248y (nonstrict y\u2272z) = nonstrict (\u223c-resp\u02e1-\u2248 (Eq.sym x\u2248y) y\u2272z)\n\nstop : Reflexive _IsRelatedTo_\nstop = equals Eq.refl\n\n------------------------------------------------------------------------\n-- A record that is used to ensure that the final relation proved by the\n-- chain of reasoning can be converted into the required relation.\n\ndata IsEquality {x y} : x IsRelatedTo y \u2192 Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  isEquality : \u2200 x\u2248y \u2192 IsEquality (equals x\u2248y)\n\nIsEquality? : \u2200 {x y} (x\u2272y : x IsRelatedTo y) \u2192 Dec (IsEquality x\u2272y)\nIsEquality? (nonstrict _) = no \u03bb()\nIsEquality? (equals x\u2248y)  = yes (isEquality x\u2248y)\n\nextractEquality : \u2200 {x y} {x\u2272y : x IsRelatedTo y} \u2192 IsEquality x\u2272y \u2192 x \u2248 y\nextractEquality (isEquality x\u2248y) = x\u2248y\n\nequalitySubRelation : SubRelation  _IsRelatedTo_ _ _\nequalitySubRelation = record\n  { IsS = IsEquality\n  ; IsS? = IsEquality?\n  ; extract = extractEquality\n  }\n\n------------------------------------------------------------------------\n-- Reasoning combinators\n\nopen begin-syntax  _IsRelatedTo_ start public\nopen begin-equality-syntax  _IsRelatedTo_ equalitySubRelation public\nopen \u2261-syntax _IsRelatedTo_ \u2261-go public\nopen \u2248-syntax _IsRelatedTo_ _IsRelatedTo_ \u2248-go Eq.sym public\nopen \u2272-syntax _IsRelatedTo_ _IsRelatedTo_ \u2272-go public\nopen end-syntax _IsRelatedTo_ stop public\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nopen \u223c-syntax _IsRelatedTo_ _IsRelatedTo_ \u2272-go public\n{-# WARNING_ON_USAGE step-\u223c\n\"Warning: step-\u223c and _\u223c\u27e8_\u27e9_ syntax was deprecated in v2.0.\nPlease use step-\u2272 and _\u2272\u27e8_\u27e9_ instead. \"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Base/Single/","title":"Relation.Binary.Reasoning.Base.Single","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The basic code for equational reasoning with a single relation\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Level using (_\u2294_)\nopen import Function.Base using (case_of_)\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\nopen import Relation.Binary.Definitions using (Reflexive; Transitive; Trans)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Reasoning.Syntax\n\nmodule Relation.Binary.Reasoning.Base.Single\n  {a \u2113} {A : Set a} (_\u223c_ : Rel A \u2113)\n  (refl : Reflexive _\u223c_) (trans : Transitive _\u223c_)\n  where\n\n------------------------------------------------------------------------\n-- Definition of \"related to\"\n\n-- This seemingly unnecessary type is used to make it possible to\n-- infer arguments even if the underlying equality evaluates.\n\ninfix 4 _IsRelatedTo_\n\ndata _IsRelatedTo_ (x y : A) : Set \u2113 where\n  relTo : (x\u223cy : x \u223c y) \u2192 x IsRelatedTo y\n\nstart : _IsRelatedTo_ \u21d2 _\u223c_\nstart (relTo x\u223cy) = x\u223cy\n\n\u223c-go : Trans _\u223c_ _IsRelatedTo_ _IsRelatedTo_\n\u223c-go x\u223cy (relTo y\u223cz) = relTo (trans x\u223cy y\u223cz)\n\n\u2261-go : Trans _\u2261_ _IsRelatedTo_ _IsRelatedTo_\n\u2261-go x\u2261y (relTo y\u223cz) = relTo (case x\u2261y of \u03bb where \u2261.refl \u2192 y\u223cz)\n\nstop : Reflexive _IsRelatedTo_\nstop = relTo refl\n\n------------------------------------------------------------------------\n-- Reasoning combinators\n\nopen begin-syntax _IsRelatedTo_ start public\nopen \u2261-syntax _IsRelatedTo_ \u2261-go public\nopen \u223c-syntax _IsRelatedTo_ _IsRelatedTo_ \u223c-go public\nopen end-syntax _IsRelatedTo_ stop public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Base/Triple/","title":"Relation.Binary.Reasoning.Base.Triple","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The basic code for equational reasoning with three relations:\n-- equality, strict ordering and non-strict ordering.\n------------------------------------------------------------------------\n--\n-- See `Data.Nat.Properties` or `Relation.Binary.Reasoning.PartialOrder`\n-- for examples of how to instantiate this module.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\n\nopen import Relation.Binary.Core using (Rel; _\u21d2_)\nopen import Relation.Binary.Structures using (IsPreorder)\nopen import Relation.Binary.Definitions\n  using (Transitive; _Respects\u2082_; Reflexive; Trans; Irreflexive; Asymmetric)\n\nmodule Relation.Binary.Reasoning.Base.Triple {a \u2113\u2081 \u2113\u2082 \u2113\u2083} {A : Set a}\n  {_\u2248_ : Rel A \u2113\u2081} {_\u2264_ : Rel A \u2113\u2082} {_&lt;_ : Rel A \u2113\u2083}\n  (isPreorder : IsPreorder _\u2248_ _\u2264_)\n  (&lt;-asym : Asymmetric _&lt;_) (&lt;-trans : Transitive _&lt;_) (&lt;-resp-\u2248 : _&lt;_ Respects\u2082 _\u2248_)\n  (&lt;\u21d2\u2264 : _&lt;_ \u21d2 _\u2264_)\n  (&lt;-\u2264-trans : Trans _&lt;_ _\u2264_ _&lt;_) (\u2264-&lt;-trans : Trans _\u2264_ _&lt;_ _&lt;_)\n  where\n\nopen import Data.Product.Base using (proj\u2081; proj\u2082)\nopen import Level using (_\u2294_)\nopen import Function.Base using (case_of_)\nopen import Relation.Nullary.Decidable.Core\n  using (Dec; yes; no)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Reasoning.Syntax\n\nopen IsPreorder isPreorder\n\n------------------------------------------------------------------------\n-- A datatype to abstract over the current relation\n\ninfix 4 _IsRelatedTo_\n\ndata _IsRelatedTo_ (x y : A) : Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  strict    : (x&lt;y : x &lt; y) \u2192 x IsRelatedTo y\n  nonstrict : (x\u2264y : x \u2264 y) \u2192 x IsRelatedTo y\n  equals    : (x\u2248y : x \u2248 y) \u2192 x IsRelatedTo y\n\nstart : _IsRelatedTo_ \u21d2 _\u2264_\nstart (equals x\u2248y) = reflexive x\u2248y\nstart (nonstrict x\u2264y) = x\u2264y\nstart (strict x&lt;y) = &lt;\u21d2\u2264 x&lt;y\n\n\u2261-go : Trans _\u2261_ _IsRelatedTo_ _IsRelatedTo_\n\u2261-go x\u2261y (equals y\u2248z) = equals (case x\u2261y of \u03bb where \u2261.refl \u2192 y\u2248z)\n\u2261-go x\u2261y (nonstrict y\u2264z) = nonstrict (case x\u2261y of \u03bb where \u2261.refl \u2192 y\u2264z)\n\u2261-go x\u2261y (strict y&lt;z) = strict (case x\u2261y of \u03bb where \u2261.refl \u2192 y&lt;z)\n\n\u2248-go : Trans _\u2248_ _IsRelatedTo_ _IsRelatedTo_\n\u2248-go x\u2248y (equals y\u2248z) = equals (Eq.trans x\u2248y y\u2248z)\n\u2248-go x\u2248y (nonstrict y\u2264z) = nonstrict (\u223c-resp\u02e1-\u2248 (Eq.sym x\u2248y) y\u2264z)\n\u2248-go x\u2248y (strict y&lt;z) = strict (proj\u2082 &lt;-resp-\u2248 (Eq.sym x\u2248y) y&lt;z)\n\n\u2264-go : Trans _\u2264_ _IsRelatedTo_ _IsRelatedTo_\n\u2264-go x\u2264y (equals y\u2248z) = nonstrict (\u223c-resp\u02b3-\u2248 y\u2248z x\u2264y)\n\u2264-go x\u2264y (nonstrict y\u2264z) = nonstrict (trans x\u2264y y\u2264z)\n\u2264-go x\u2264y (strict y&lt;z) = strict (\u2264-&lt;-trans x\u2264y y&lt;z)\n\n&lt;-go : Trans _&lt;_ _IsRelatedTo_ _IsRelatedTo_\n&lt;-go x&lt;y (equals y\u2248z) = strict (proj\u2081 &lt;-resp-\u2248 y\u2248z x&lt;y)\n&lt;-go x&lt;y (nonstrict y\u2264z) = strict (&lt;-\u2264-trans x&lt;y y\u2264z)\n&lt;-go x&lt;y (strict y&lt;z) = strict (&lt;-trans x&lt;y y&lt;z)\n\nstop : Reflexive _IsRelatedTo_\nstop = equals Eq.refl\n\n\n------------------------------------------------------------------------\n-- Types that are used to ensure that the final relation proved by the\n-- chain of reasoning can be converted into the required relation.\n\ndata IsStrict {x y} : x IsRelatedTo y \u2192 Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  isStrict : \u2200 x&lt;y \u2192 IsStrict (strict x&lt;y)\n\nIsStrict? : \u2200 {x y} (x\u2272y : x IsRelatedTo y) \u2192 Dec (IsStrict x\u2272y)\nIsStrict? (strict    x&lt;y) = yes (isStrict x&lt;y)\nIsStrict? (nonstrict _)   = no \u03bb()\nIsStrict? (equals    _)   = no \u03bb()\n\nextractStrict : \u2200 {x y} {x\u2272y : x IsRelatedTo y} \u2192 IsStrict x\u2272y \u2192 x &lt; y\nextractStrict (isStrict x&lt;y) = x&lt;y\n\nstrictRelation : SubRelation _IsRelatedTo_ _ _\nstrictRelation = record\n  { IsS = IsStrict\n  ; IsS? = IsStrict?\n  ; extract = extractStrict\n  }\n\n------------------------------------------------------------------------\n-- Equality sub-relation\n\ndata IsEquality {x y} : x IsRelatedTo y \u2192 Set (a \u2294 \u2113\u2081 \u2294 \u2113\u2082 \u2294 \u2113\u2083) where\n  isEquality : \u2200 x\u2248y \u2192 IsEquality (equals x\u2248y)\n\nIsEquality? : \u2200 {x y} (x\u2272y : x IsRelatedTo y) \u2192 Dec (IsEquality x\u2272y)\nIsEquality? (strict    _) = no \u03bb()\nIsEquality? (nonstrict _) = no \u03bb()\nIsEquality? (equals x\u2248y)  = yes (isEquality x\u2248y)\n\nextractEquality : \u2200 {x y} {x\u2272y : x IsRelatedTo y} \u2192 IsEquality x\u2272y \u2192 x \u2248 y\nextractEquality (isEquality x\u2248y) = x\u2248y\n\neqRelation : SubRelation _IsRelatedTo_ _ _\neqRelation = record\n  { IsS = IsEquality\n  ; IsS? = IsEquality?\n  ; extract = extractEquality\n  }\n\n------------------------------------------------------------------------\n-- Reasoning combinators\n\nopen begin-syntax _IsRelatedTo_ start public\nopen begin-equality-syntax _IsRelatedTo_ eqRelation public\nopen begin-strict-syntax _IsRelatedTo_ strictRelation public\nopen begin-contradiction-syntax _IsRelatedTo_ strictRelation &lt;-asym public\nopen \u2261-syntax _IsRelatedTo_ \u2261-go public\nopen \u2248-syntax _IsRelatedTo_ _IsRelatedTo_ \u2248-go Eq.sym public\nopen \u2264-syntax _IsRelatedTo_ _IsRelatedTo_ \u2264-go public\nopen &lt;-syntax _IsRelatedTo_ _IsRelatedTo_ &lt;-go public\nopen end-syntax _IsRelatedTo_ stop public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Preorder/","title":"Relation.Binary.Reasoning.Preorder","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Convenient syntax for \"equational reasoning\" using a preorder\n------------------------------------------------------------------------\n\n-- Example uses:\n--\n--    u\u223cy : u \u223c y\n--    u\u223cy = begin\n--      u  \u2248\u27e8 u\u2248v \u27e9\n--      v  \u2261\u27e8 v\u2261w \u27e9\n--      w  \u223c\u27e8 w\u223cy \u27e9\n--      y  \u2248\u27e8 z\u2248y \u27e9\n--      z  \u220e\n--\n--    u\u2248w : u \u2248 w\n--    u\u2248w = begin-equality\n--      u  \u2248\u27e8 u\u2248v \u27e9\n--      v  \u2261\u27e8 v\u2261w \u27e9\n--      w  \u2261\u27e8 x\u2261w \u27e8\n--      x  \u220e\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Preorder)\n\nmodule Relation.Binary.Reasoning.Preorder\n  {p\u2081 p\u2082 p\u2083} (P : Preorder p\u2081 p\u2082 p\u2083) where\n\nopen Preorder P\n\n------------------------------------------------------------------------\n-- Publicly re-export the contents of the base module\n\nopen import Relation.Binary.Reasoning.Base.Double isPreorder public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Setoid/","title":"Relation.Binary.Reasoning.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Convenient syntax for reasoning with a setoid\n------------------------------------------------------------------------\n\n-- Example use:\n\n-- n*0\u22610 : \u2200 n \u2192 n * 0 \u2261 0\n-- n*0\u22610 zero    = refl\n-- n*0\u22610 (suc n) = begin\n--   suc n * 0 \u2248\u27e8 refl \u27e9\n--   n * 0 + 0 \u2248\u27e8 ... \u27e9\n--   n * 0     \u2248\u27e8 n*0\u22610 n \u27e9\n--   0         \u220e\n\n-- Module `\u2261-Reasoning` in `Relation.Binary.PropositionalEquality`\n-- is recommended for equational reasoning when the underlying equality\n-- is `_\u2261_`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Reasoning.Syntax using (module \u2248-syntax)\n\nmodule Relation.Binary.Reasoning.Setoid {s\u2081 s\u2082} (S : Setoid s\u2081 s\u2082) where\n\nopen Setoid S\n\nimport Relation.Binary.Reasoning.Base.Single _\u2248_ refl trans\n  as SingleRelReasoning\n\n------------------------------------------------------------------------\n-- Reasoning combinators\n\n-- Export the combinators for single relation reasoning, hiding the\n-- single misnamed combinator.\nopen SingleRelReasoning public\n  hiding (step-\u223c)\n  renaming (\u223c-go to \u2248-go)\n\n-- Re-export the equality-based combinators instead\nopen \u2248-syntax _IsRelatedTo_ _IsRelatedTo_ \u2248-go sym public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Syntax/","title":"Relation.Binary.Reasoning.Syntax","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Syntax for the building blocks of equational reasoning modules\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\n-- List of `Reasoning` modules that do not use this framework and so\n-- need to be updated manually if the syntax changes.\n--\n--   Data/Vec/Relation/Binary/Equality/Cast\n--   Relation/Binary/HeterogeneousEquality\n--   Effect/Monad/Partiality\n--   Effect/Monad/Partiality/All\n--   Codata/Guarded/Stream/Relation/Binary/Pointwise\n--   Function/Reasoning\n\nmodule Relation.Binary.Reasoning.Syntax where\n\nopen import Level using (Level; _\u2294_; suc)\nopen import Relation.Nullary.Decidable.Core\n  using (Dec; True; toWitness)\nopen import Relation.Nullary.Negation.Core using (contradiction)\nopen import Relation.Binary.Core using (Rel; REL; _\u21d2_)\nopen import Relation.Binary.Definitions\n  using (_Respects\u02b3_; Asymmetric; Trans; Sym; Reflexive)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261\n  using (_\u2261_)\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 \u2113\u2083 \u2113\u2084 : Level\n    A B C : Set a\n    x y z : A\n\n------------------------------------------------------------------------\n-- Syntax for beginning a reasoning chain\n------------------------------------------------------------------------\n\n------------------------------------------------------------------------\n-- Basic begin syntax\n\nmodule begin-syntax\n  (R : REL A B \u2113\u2081)\n  {S : REL A B \u2113\u2082}\n  (reflexive : R \u21d2 S)\n  where\n\n  infix 1 begin_\n\n  begin_ : R x y \u2192 S x y\n  begin_ = reflexive\n\n------------------------------------------------------------------------\n-- Begin subrelation syntax\n\n-- Sometimes we want to support sub-relations with the\n-- same reasoning operators as the main relations (e.g. perform equality\n-- proofs with non-strict reasoning operators). This record bundles all\n-- the parts needed to extract the sub-relation proofs.\nrecord SubRelation {A : Set a} (R : Rel A \u2113\u2081) \u2113\u2082 \u2113\u2083 : Set (a \u2294 \u2113\u2081 \u2294 suc \u2113\u2082 \u2294 suc \u2113\u2083) where\n  field\n    S : Rel A \u2113\u2082\n    IsS : R x y \u2192 Set \u2113\u2083\n    IsS? : \u2200 (xRy : R x y) \u2192 Dec (IsS xRy)\n    extract : \u2200 {xRy : R x y} \u2192 IsS xRy \u2192 S x y\n\nmodule begin-subrelation-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083)\n  where\n  open SubRelation sub\n\n  infix 1 begin_\n\n  begin_ : \u2200 {x y} (xRy : R x y) \u2192 {s : True (IsS? xRy)} \u2192 S x y\n  begin_ r {s} = extract (toWitness s)\n\n-- Begin equality syntax\nmodule begin-equality-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-equality_)\n\n-- Begin apartness syntax\nmodule begin-apartness-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-apartness_)\n\n-- Begin strict syntax\nmodule begin-strict-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-strict_)\n\n------------------------------------------------------------------------\n-- Begin membership syntax\n\nmodule begin-membership-syntax\n  (R : Rel A \u2113\u2081)\n  (_\u2208_ : REL B A \u2113\u2082)\n  (resp : _\u2208_ Respects\u02b3 R) where\n\n  infix  1 step-\u2208\n\n  step-\u2208 : \u2200 (x : B) {xs ys} \u2192 R xs ys \u2192 x \u2208 xs \u2192 x \u2208 ys\n  step-\u2208 x = resp\n\n  syntax step-\u2208 x  xs\u2286ys x\u2208xs  = x \u2208\u27e8 x\u2208xs \u27e9 xs\u2286ys\n\n------------------------------------------------------------------------\n-- Begin contradiction syntax\n\n-- Used with asymmetric subrelations to derive a contradiction from a\n-- proof that an element is related to itself.\nmodule begin-contradiction-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083)\n  (asym : Asymmetric (SubRelation.S sub))\n  where\n\n  open SubRelation sub\n\n  infix 1 begin-contradiction_\n\n  begin-contradiction_ : \u2200 (xRx : R x x) {s : True (IsS? xRx)} \u2192\n                         \u2200 {b} {B : Set b} \u2192 B\n  begin-contradiction_ {x} r {s} = contradiction x&lt;x (asym x&lt;x)\n    where\n    x&lt;x : S x x\n    x&lt;x = extract (toWitness s)\n\n------------------------------------------------------------------------\n-- Syntax for continuing a chain of reasoning steps\n------------------------------------------------------------------------\n\n-- Note that the arguments to the `step`s are not provided in their\n-- \"natural\" order and syntax declarations are later used to re-order\n-- them. This is because the `step` ordering allows the type-checker to\n-- better infer the middle argument `y` from the `_IsRelatedTo_`\n-- argument (see issue 622).\n--\n-- This has two practical benefits. First it speeds up type-checking by\n-- approximately a factor of 5. Secondly it allows the combinators to be\n-- used with macros that use reflection, e.g. `Tactic.RingSolver`, where\n-- they need to be able to extract `y` using reflection.\n\n------------------------------------------------------------------------\n-- Syntax for unidirectional relations\n\n-- See https://github.com/agda/agda-stdlib/issues/2150 for a possible\n-- simplification.\n\nmodule _\n  {R : REL A B \u2113\u2082}\n  (S : REL B C \u2113\u2081)\n  (T : REL A C \u2113\u2083)\n  (step : Trans R S T)\n  where\n\n  forward : \u2200 (x : A) {y z} \u2192 S y z \u2192 R x y \u2192 T x z\n  forward x yRz x\u223cy = step {x} x\u223cy yRz\n\n  -- Arbitrary relation syntax\n  module \u223c-syntax where\n    infixr 2 step-\u223c\n    step-\u223c = forward\n    syntax step-\u223c x yRz x\u223cy = x \u223c\u27e8 x\u223cy \u27e9 yRz\n\n\n  -- Preorder syntax\n  module \u2272-syntax where\n    infixr 2 step-\u2272\n    step-\u2272 = forward\n    syntax step-\u2272 x yRz x\u2272y = x \u2272\u27e8 x\u2272y \u27e9 yRz\n\n\n  -- Partial order syntax\n  module \u2264-syntax where\n    infixr 2 step-\u2264\n    step-\u2264 = forward\n    syntax step-\u2264 x yRz x\u2264y = x \u2264\u27e8 x\u2264y \u27e9 yRz\n\n\n  -- Strict partial order syntax\n  module &lt;-syntax where\n    infixr 2 step-&lt;\n    step-&lt; = forward\n    syntax step-&lt; x yRz x&lt;y = x &lt;\u27e8 x&lt;y \u27e9 yRz\n\n\n  -- Subset order syntax\n  module \u2286-syntax where\n    infixr 2 step-\u2286\n    step-\u2286 = forward\n    syntax step-\u2286 x yRz x\u2286y = x \u2286\u27e8 x\u2286y \u27e9 yRz\n\n\n  -- Strict subset order syntax\n  module \u2282-syntax where\n    infixr 2 step-\u2282\n    step-\u2282 = forward\n    syntax step-\u2282 x yRz x\u2282y = x \u2282\u27e8 x\u2282y \u27e9 yRz\n\n\n  -- Square subset order syntax\n  module \u2291-syntax where\n    infixr 2 step-\u2291\n    step-\u2291 = forward\n    syntax step-\u2291 x yRz x\u2291y = x \u2291\u27e8 x\u2291y \u27e9 yRz\n\n\n  -- Strict square subset order syntax\n  module \u228f-syntax where\n    infixr 2 step-\u228f\n    step-\u228f = forward\n    syntax step-\u228f x yRz x\u228fy = x \u228f\u27e8 x\u228fy \u27e9 yRz\n\n\n  -- Divisibility syntax\n  module \u2223-syntax where\n    infixr 2 step-\u2223\n    step-\u2223 = forward\n    syntax step-\u2223 x yRz x\u2223y = x \u2223\u27e8 x\u2223y \u27e9 yRz\n\n\n  -- Single-step syntax\n  module \u27f6-syntax where\n    infixr 2 step-\u27f6\n    step-\u27f6 = forward\n    syntax step-\u27f6 x yRz x\u2223y = x \u27f6\u27e8 x\u2223y \u27e9 yRz\n\n\n  -- Multi-step syntax\n  module \u27f6*-syntax where\n    infixr 2 step-\u27f6*\n    step-\u27f6* = forward\n    syntax step-\u27f6* x yRz x\u2223y = x \u27f6*\u27e8 x\u2223y \u27e9 yRz\n\n\n------------------------------------------------------------------------\n-- Syntax for bidirectional relations\n\n  module _\n    {U : REL B A \u2113\u2084}\n    (sym : Sym U R)\n    where\n\n    backward : \u2200 x {y z} \u2192 S y z \u2192 U y x \u2192 T x z\n    backward x yRz x\u2248y = forward x yRz (sym x\u2248y)\n\n    -- Setoid equality syntax\n    module \u2248-syntax where\n      infixr 2 step-\u2248-\u27e9 step-\u2248-\u27e8\n      step-\u2248-\u27e9 = forward\n      step-\u2248-\u27e8 = backward\n      syntax step-\u2248-\u27e9 x yRz x\u2248y = x \u2248\u27e8 x\u2248y \u27e9 yRz\n      syntax step-\u2248-\u27e8 x yRz y\u2248x = x \u2248\u27e8 y\u2248x \u27e8 yRz\n\n      -- Deprecated\n      infixr 2 step-\u2248 step-\u2248\u02d8\n      step-\u2248 = step-\u2248-\u27e9\n      {-# WARNING_ON_USAGE step-\u2248\n      \"Warning: step-\u2248 was deprecated in v2.0.\n      Please use step-\u2248-\u27e9 instead.\"\n      #-}\n      step-\u2248\u02d8 = step-\u2248-\u27e8\n      {-# WARNING_ON_USAGE step-\u2248\u02d8\n      \"Warning: step-\u2248\u02d8 and _\u2248\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u2248-\u27e8 and _\u2248\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u2248\u02d8 x yRz y\u2248x = x \u2248\u02d8\u27e8 y\u2248x \u27e9 yRz\n\n\n    -- Container equality syntax\n    module \u224b-syntax where\n      infixr 2 step-\u224b-\u27e9 step-\u224b-\u27e8\n      step-\u224b-\u27e9 = forward\n      step-\u224b-\u27e8 = backward\n      syntax step-\u224b-\u27e9 x yRz x\u224by = x \u224b\u27e8 x\u224by \u27e9 yRz\n      syntax step-\u224b-\u27e8 x yRz y\u224bx = x \u224b\u27e8 y\u224bx \u27e8 yRz\n\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-\u224b step-\u224b\u02d8\n      step-\u224b = step-\u224b-\u27e9\n      {-# WARNING_ON_USAGE step-\u224b\n      \"Warning: step-\u224b was deprecated in v2.0.\n      Please use step-\u224b-\u27e9 instead.\"\n      #-}\n      step-\u224b\u02d8 = step-\u224b-\u27e8\n      {-# WARNING_ON_USAGE step-\u224b\u02d8\n      \"Warning: step-\u224b\u02d8 and _\u224b\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u224b-\u27e8 and _\u224b\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u224b\u02d8 x yRz y\u224bx = x \u224b\u02d8\u27e8 y\u224bx \u27e9 yRz\n\n\n    -- Other equality syntax\n    module \u2243-syntax where\n      infixr 2 step-\u2243-\u27e9 step-\u2243-\u27e8\n      step-\u2243-\u27e9 = forward\n      step-\u2243-\u27e8 = backward\n      syntax step-\u2243-\u27e9 x yRz x\u2243y = x \u2243\u27e8 x\u2243y \u27e9 yRz\n      syntax step-\u2243-\u27e8 x yRz y\u2243x = x \u2243\u27e8 y\u2243x \u27e8 yRz\n\n\n    -- Apartness relation syntax\n    module #-syntax where\n      infixr 2 step-#-\u27e9 step-#-\u27e8\n      step-#-\u27e9 = forward\n      step-#-\u27e8 = backward\n      syntax step-#-\u27e9 x yRz x#y = x #\u27e8 x#y \u27e9 yRz\n      syntax step-#-\u27e8 x yRz y#x = x #\u27e8 y#x \u27e8 yRz\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-# step-#\u02d8\n      step-# = step-#-\u27e9\n      {-# WARNING_ON_USAGE step-#\n      \"Warning: step-# was deprecated in v2.0.\n      Please use step-#-\u27e9 instead.\"\n      #-}\n      step-#\u02d8 = step-#-\u27e8\n      {-# WARNING_ON_USAGE step-#\u02d8\n      \"Warning: step-#\u02d8 and _#\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-#-\u27e8 and _#\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-#\u02d8 x yRz y#x = x #\u02d8\u27e8 y#x \u27e9 yRz\n\n\n    -- Bijection syntax\n    module \u2916-syntax where\n      infixr 2 step-\u2916 step-\u2b3b\n      step-\u2916 = forward\n      step-\u2b3b = backward\n      syntax step-\u2916 x yRz x\u2916y = x \u2916\u27e8 x\u2916y \u27e9 yRz\n      syntax step-\u2b3b x yRz y\u2916x = x \u2b3b\u27e8 y\u2916x \u27e9 yRz\n\n\n    -- Inverse syntax\n    module \u2194-syntax where\n      infixr 2 step-\u2194-\u27e9 step-\u2194-\u27e8\n      step-\u2194-\u27e9 = forward\n      step-\u2194-\u27e8 = backward\n      syntax step-\u2194-\u27e9 x yRz x\u2194y = x \u2194\u27e8 x\u2194y \u27e9 yRz\n      syntax step-\u2194-\u27e8 x yRz y\u2194x = x \u2194\u27e8 y\u2194x \u27e8 yRz\n\n\n    -- Inverse syntax\n    module \u21ad-syntax where\n      infixr 2 step-\u21ad-\u27e9 step-\u21ad-\u27e8\n      step-\u21ad-\u27e9 = forward\n      step-\u21ad-\u27e8 = backward\n      syntax step-\u21ad-\u27e9 x yRz x\u21ady = x \u21ad\u27e8 x\u21ady \u27e9 yRz\n      syntax step-\u21ad-\u27e8 x yRz y\u21adx = x \u21ad\u27e8 y\u21adx \u27e8 yRz\n\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-\u21ad step-\u21ad\u02d8\n      step-\u21ad = forward\n      {-# WARNING_ON_USAGE step-\u21ad\n      \"Warning: step-\u21ad was deprecated in v2.0.\n      Please use step-\u21ad-\u27e9 instead.\"\n      #-}\n      step-\u21ad\u02d8 = backward\n      {-# WARNING_ON_USAGE step-\u21ad\u02d8\n      \"Warning: step-\u21ad\u02d8 and _\u21ad\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u21ad-\u27e8 and _\u21ad\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u21ad\u02d8 x yRz y\u21adx = x \u21ad\u02d8\u27e8 y\u21adx \u27e9 yRz\n\n------------------------------------------------------------------------\n-- Propositional equality\n\n-- Crucially often the step function cannot just be `subst` or pattern\n-- match on `refl` as we often want to compute which constructor the\n-- relation begins with, in order for the implicit subrelation\n-- arguments to resolve. See `\u2261-noncomputable-syntax` below if this\n-- is not required.\nmodule \u2261-syntax\n  (R : REL A B \u2113\u2081)\n  (step : Trans _\u2261_ R R)\n  where\n\n  infixr 2 step-\u2261-\u27e9  step-\u2261-\u2223 step-\u2261-\u27e8\n  step-\u2261-\u27e9 = forward R R step\n\n  step-\u2261-\u2223 : \u2200 x {y} \u2192 R x y \u2192 R x y\n  step-\u2261-\u2223 x xRy = xRy\n\n  step-\u2261-\u27e8 = backward R R step \u2261.sym\n\n  syntax step-\u2261-\u27e9 x yRz x\u2261y = x \u2261\u27e8 x\u2261y \u27e9 yRz\n  syntax step-\u2261-\u2223 x xRy     = x \u2261\u27e8\u27e9 xRy\n  syntax step-\u2261-\u27e8 x yRz y\u2261x = x \u2261\u27e8 y\u2261x \u27e8 yRz\n\n\n  -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n  infixr 2 step-\u2261 step-\u2261\u02d8\n  step-\u2261 = step-\u2261-\u27e9\n  {-# WARNING_ON_USAGE step-\u2261\n  \"Warning: step-\u2261 was deprecated in v2.0.\n  Please use step-\u2261-\u27e9 instead.\"\n  #-}\n  step-\u2261\u02d8 = step-\u2261-\u27e8\n  {-# WARNING_ON_USAGE step-\u2261\u02d8\n  \"Warning: step-\u2261\u02d8 and _\u2261\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n  Please use step-\u2261-\u27e8 and _\u2261\u27e8_\u27e8_ instead.\"\n  #-}\n  syntax step-\u2261\u02d8 x yRz y\u2261x = x \u2261\u02d8\u27e8 y\u2261x \u27e9 yRz\n\n\n-- Unlike \u2261-syntax above, chains of reasoning using this syntax will not\n-- reduce when proofs of propositional equality which are not definitionally\n-- equal to `refl` are passed.\nmodule \u2261-noncomputing-syntax (R : REL A B \u2113\u2081) where\n\n  private\n    step : Trans _\u2261_ R R\n    step \u2261.refl xRy = xRy\n\n  open \u2261-syntax R step public\n\n------------------------------------------------------------------------\n-- Syntax for ending a chain of reasoning\n------------------------------------------------------------------------\n\nmodule end-syntax\n  (R : Rel A \u2113\u2081)\n  (reflexive : Reflexive R)\n  where\n\n  infix 3 _\u220e\n\n  _\u220e : \u2200 x \u2192 R x x\n  x \u220e = reflexive\n\n</pre>"},{"location":"md/Relation/Binary/Structures/","title":"Relation.Binary.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Structures for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core\n\nmodule Relation.Binary.Structures\n  {a \u2113} {A : Set a} -- The underlying set\n  (_\u2248_ : Rel A \u2113)   -- The underlying equality relation\n  where\n\nopen import Data.Product.Base using (proj\u2081; proj\u2082; _,_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Consequences\n  using (tri\u21d2dec\u2248; tri\u21d2dec&lt;; trans\u2227irr\u21d2asym)\nopen import Relation.Binary.Definitions\n\nprivate\n  variable\n    \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Equivalences\n------------------------------------------------------------------------\n-- Note all the following equivalences refer to the equality provided\n-- as a module parameter at the top of this file.\n\nrecord IsPartialEquivalence : Set (a \u2294 \u2113) where\n  field\n    sym   : Symmetric _\u2248_\n    trans : Transitive _\u2248_\n\n-- The preorders of this library are defined in terms of an underlying\n-- equivalence relation, and hence equivalence relations are not\n-- defined in terms of preorders.\n\n-- To preserve backwards compatability, equivalence relations are\n-- not defined in terms of their partial counterparts.\n\nrecord IsEquivalence : Set (a \u2294 \u2113) where\n  field\n    refl  : Reflexive _\u2248_\n    sym   : Symmetric _\u2248_\n    trans : Transitive _\u2248_\n\n  reflexive : _\u2261_ \u21d2 _\u2248_\n  reflexive \u2261.refl = refl\n\n  isPartialEquivalence : IsPartialEquivalence\n  isPartialEquivalence = record\n    { sym = sym\n    ; trans = trans\n    }\n\n\nrecord IsDecEquivalence : Set (a \u2294 \u2113) where\n  infix 4 _\u225f_\n  field\n    isEquivalence : IsEquivalence\n    _\u225f_           : Decidable _\u2248_\n\n  open IsEquivalence isEquivalence public\n\n\n------------------------------------------------------------------------\n-- Preorders\n------------------------------------------------------------------------\n\nrecord IsPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsEquivalence\n    -- Reflexivity is expressed in terms of the underlying equality:\n    reflexive     : _\u2248_ \u21d2 _\u2272_\n    trans         : Transitive _\u2272_\n\n  module Eq = IsEquivalence isEquivalence\n\n  refl : Reflexive _\u2272_\n  refl = reflexive Eq.refl\n\n  \u2272-resp\u02e1-\u2248 : _\u2272_ Respects\u02e1 _\u2248_\n  \u2272-resp\u02e1-\u2248 x\u2248y x\u223cz = trans (reflexive (Eq.sym x\u2248y)) x\u223cz\n\n  \u2272-resp\u02b3-\u2248 : _\u2272_ Respects\u02b3 _\u2248_\n  \u2272-resp\u02b3-\u2248 x\u2248y z\u223cx = trans z\u223cx (reflexive x\u2248y)\n\n  \u2272-resp-\u2248 : _\u2272_ Respects\u2082 _\u2248_\n  \u2272-resp-\u2248 = \u2272-resp\u02b3-\u2248 , \u2272-resp\u02e1-\u2248\n\n  \u223c-resp\u02e1-\u2248 = \u2272-resp\u02e1-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp\u02e1-\u2248\n  \"Warning: \u223c-resp\u02e1-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp\u02e1-\u2248 instead. \"\n  #-}\n  \u223c-resp\u02b3-\u2248 = \u2272-resp\u02b3-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp\u02b3-\u2248\n  \"Warning: \u223c-resp\u02b3-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp\u02b3-\u2248 instead. \"\n  #-}\n  \u223c-resp-\u2248 = \u2272-resp-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp-\u2248\n  \"Warning: \u223c-resp-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp-\u2248 instead. \"\n  #-}\n\n\nrecord IsTotalPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2272_\n    total      : Total _\u2272_\n\n  open IsPreorder isPreorder public\n\n\nrecord IsDecPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2272_\n    _\u225f_        : Decidable _\u2248_\n    _\u2272?_       : Decidable _\u2272_\n\n  open IsPreorder isPreorder public\n    hiding (module Eq)\n\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n\n------------------------------------------------------------------------\n-- Partial orders\n------------------------------------------------------------------------\n\nrecord IsPartialOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2264_\n    antisym    : Antisymmetric _\u2248_ _\u2264_\n\n  open IsPreorder isPreorder public\n    renaming\n    ( \u223c-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n    ; \u223c-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n    ; \u223c-resp-\u2248  to \u2264-resp-\u2248\n    )\n\n\nrecord IsDecPartialOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _\u2264?_\n  field\n    isPartialOrder : IsPartialOrder _\u2264_\n    _\u225f_            : Decidable _\u2248_\n    _\u2264?_           : Decidable _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n    hiding (module Eq)\n\n  isDecPreorder : IsDecPreorder _\u2264_\n  isDecPreorder = record\n    { isPreorder = isPreorder\n    ; _\u225f_ = _\u225f_\n    ; _\u2272?_ = _\u2264?_\n    }\n\n  open IsDecPreorder isDecPreorder public\n    using (module Eq)\n\n\nrecord IsStrictPartialOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsEquivalence\n    irrefl        : Irreflexive _\u2248_ _&lt;_\n    trans         : Transitive _&lt;_\n    &lt;-resp-\u2248      : _&lt;_ Respects\u2082 _\u2248_\n\n  module Eq = IsEquivalence isEquivalence\n\n  asym : Asymmetric _&lt;_\n  asym {x} {y} = trans\u2227irr\u21d2asym Eq.refl trans irrefl {x = x} {y}\n\n  &lt;-resp\u02b3-\u2248 : _&lt;_ Respects\u02b3 _\u2248_\n  &lt;-resp\u02b3-\u2248 = proj\u2081 &lt;-resp-\u2248\n\n  &lt;-resp\u02e1-\u2248 : _&lt;_ Respects\u02e1 _\u2248_\n  &lt;-resp\u02e1-\u2248 = proj\u2082 &lt;-resp-\u2248\n\n\nrecord IsDecStrictPartialOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _&lt;?_\n  field\n    isStrictPartialOrder : IsStrictPartialOrder _&lt;_\n    _\u225f_                  : Decidable _\u2248_\n    _&lt;?_                 : Decidable _&lt;_\n\n  private\n    module SPO = IsStrictPartialOrder isStrictPartialOrder\n\n  open SPO public hiding (module Eq)\n\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = SPO.isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n\n------------------------------------------------------------------------\n-- Total orders\n------------------------------------------------------------------------\n\nrecord IsTotalOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPartialOrder : IsPartialOrder _\u2264_\n    total          : Total _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n\n  isTotalPreorder : IsTotalPreorder _\u2264_\n  isTotalPreorder = record\n    { isPreorder = isPreorder\n    ; total      = total\n    }\n\n\nrecord IsDecTotalOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _\u2264?_\n  field\n    isTotalOrder : IsTotalOrder _\u2264_\n    _\u225f_          : Decidable _\u2248_\n    _\u2264?_         : Decidable _\u2264_\n\n  open IsTotalOrder isTotalOrder public\n    hiding (module Eq)\n\n  isDecPartialOrder : IsDecPartialOrder _\u2264_\n  isDecPartialOrder = record\n    { isPartialOrder = isPartialOrder\n    ; _\u225f_            = _\u225f_\n    ; _\u2264?_           = _\u2264?_\n    }\n\n  open IsDecPartialOrder isDecPartialOrder public\n    using (isDecPreorder; module Eq)\n\n-- Note that these orders are decidable. The current implementation\n-- of `Trichotomous` subsumes irreflexivity and asymmetry. See\n-- `Relation.Binary.Structures.Biased` for ways of constructing this\n-- record without having to prove `isStrictPartialOrder`.\n\nrecord IsStrictTotalOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isStrictPartialOrder : IsStrictPartialOrder _&lt;_\n    compare              : Trichotomous _\u2248_ _&lt;_\n\n  open IsStrictPartialOrder isStrictPartialOrder public\n    hiding (module Eq)\n\n  -- `Trichotomous` necessarily separates out the equality case so\n  --  it implies decidability.\n  infix 4 _\u225f_ _&lt;?_\n\n  _\u225f_ : Decidable _\u2248_\n  _\u225f_ = tri\u21d2dec\u2248 compare\n\n  _&lt;?_ : Decidable _&lt;_\n  _&lt;?_ = tri\u21d2dec&lt; compare\n\n  isDecStrictPartialOrder : IsDecStrictPartialOrder _&lt;_\n  isDecStrictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    ; _\u225f_                  = _\u225f_\n    ; _&lt;?_                 = _&lt;?_\n    }\n\n  -- Redefine the `Eq` module to include decidability proofs\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n  isDecEquivalence : IsDecEquivalence\n  isDecEquivalence = record\n    { isEquivalence = isEquivalence\n    ; _\u225f_           = _\u225f_\n    }\n  {-# WARNING_ON_USAGE isDecEquivalence\n  \"Warning: isDecEquivalence was deprecated in v2.0.\n  Please use Eq.isDecEquivalence instead. \"\n  #-}\n\nrecord IsDenseLinearOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isStrictTotalOrder : IsStrictTotalOrder _&lt;_\n    dense              : Dense _&lt;_\n\n  open IsStrictTotalOrder isStrictTotalOrder public\n\n\n------------------------------------------------------------------------\n-- Apartness relations\n------------------------------------------------------------------------\n\nrecord IsApartnessRelation (_#_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    irrefl  : Irreflexive _\u2248_ _#_\n    sym     : Symmetric _#_\n    cotrans : Cotransitive _#_\n\n  _\u00ac#_ : A \u2192 A \u2192 Set _\n  x \u00ac# y = \u00ac (x # y)\n</pre>"},{"location":"md/Relation/Binary/Structures/Biased/","title":"Relation.Binary.Structures.Biased","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Ways to give instances of certain structures where some fields can\n-- be given in terms of others\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\n\nmodule Relation.Binary.Structures.Biased\n  {a \u2113} {A : Set a} -- The underlying set\n  (_\u2248_ : Rel A \u2113)   -- The underlying equality relation\n  where\n\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Consequences using (tri\u21d2irr; tri\u21d2asym; trans\u2227tri\u21d2resp)\nopen import Relation.Binary.Definitions using (Transitive; Trichotomous)\n\nopen import Relation.Binary.Structures _\u2248_\n\nprivate\n  variable\n    \u2113\u2082 : Level\n\n-- To construct a StrictTotalOrder you only need to prove transitivity and\n-- trichotomy as the current implementation of `Trichotomous` subsumes\n-- irreflexivity and asymmetry.\nrecord IsStrictTotalOrder\u1d9c (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsEquivalence\n    trans         : Transitive _&lt;_\n    compare       : Trichotomous _\u2248_ _&lt;_\n\n  isStrictTotalOrder\u1d9c : IsStrictTotalOrder _&lt;_\n  isStrictTotalOrder\u1d9c = record\n    { isStrictPartialOrder = record\n      { isEquivalence = isEquivalence\n      ; irrefl = tri\u21d2irr compare\n      ; trans = trans\n      ; &lt;-resp-\u2248 = trans\u2227tri\u21d2resp Eq.sym Eq.trans trans compare\n      }\n    ; compare = compare\n    } where module Eq = IsEquivalence isEquivalence\n\nopen IsStrictTotalOrder\u1d9c public\n  using (isStrictTotalOrder\u1d9c)\n</pre>"},{"location":"md/Relation/Nullary/","title":"Relation.Nullary","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on nullary relations (like negation and decidability)\n------------------------------------------------------------------------\n\n-- Some operations on/properties of nullary relations, i.e. sets.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Agda.Builtin.Maybe using (Maybe)\nopen import Level using (Level)\n\nprivate\n  variable\n    p : Level\n    P : Set p\n\n\n------------------------------------------------------------------------\n-- Re-exports\n\nopen import Relation.Nullary.Recomputable public using (Recomputable)\nopen import Relation.Nullary.Negation.Core public\nopen import Relation.Nullary.Reflects public hiding (recompute; recompute-constant)\nopen import Relation.Nullary.Decidable.Core public\nopen import Relation.Nullary.Irrelevant public\n\n------------------------------------------------------------------------\n-- Weak decidability\n-- `nothing` is 'don't know'/'give up'; `just` is `yes`/`definitely`\n\nWeaklyDecidable : Set p \u2192 Set p\nWeaklyDecidable = Maybe\n</pre>"},{"location":"md/Relation/Nullary/Decidable/","title":"Relation.Nullary.Decidable","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on and properties of decidable relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Decidable where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (true; false)\nopen import Data.Product.Base using (\u2203; _,_)\nopen import Function.Bundles\n  using (Injection; module Injection; module Equivalence; _\u21d4_; _\u2194_; mk\u2194\u209b\u2032)\nopen import Relation.Binary.Bundles using (Setoid; module Setoid)\nopen import Relation.Binary.Definitions using (Decidable)\nopen import Relation.Nullary.Irrelevant using (Irrelevant)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Nullary.Reflects using (invert)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261\n  using (_\u2261_; refl; sym; trans)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Re-exporting the core definitions\n\nopen import Relation.Nullary.Decidable.Core public\n\n------------------------------------------------------------------------\n-- Maps\n\nmap : A \u21d4 B \u2192 Dec A \u2192 Dec B\nmap A\u21d4B = map\u2032 to from\n  where open Equivalence A\u21d4B\n\n-- If there is an injection from one setoid to another, and the\n-- latter's equivalence relation is decidable, then the former's\n-- equivalence relation is also decidable.\n\nmodule _ {S : Setoid a \u2113\u2081} {T : Setoid b \u2113\u2082} (injection : Injection S T) where\n\n  open Injection injection\n\n  via-injection : Decidable Eq\u2082._\u2248_ \u2192 Decidable Eq\u2081._\u2248_\n  via-injection _\u225f_ x y = map\u2032 injective cong (to x \u225f to y)\n\n------------------------------------------------------------------------\n-- A lemma relating True and Dec\n\nTrue-\u2194 : (a? : Dec A) \u2192 Irrelevant A \u2192 True a? \u2194 A\nTrue-\u2194 a? irr = mk\u2194\u209b\u2032 to from to-from (from-to a?)\n  where\n  to = toWitness {a? = a?}\n  from = fromWitness {a? = a?}\n  to-from : \u2200 a \u2192 to (from a) \u2261 a\n  to-from a = irr _ a\n  from-to : \u2200 a? (x : True a?) \u2192 fromWitness (toWitness x) \u2261 x\n  from-to (yes _) _ = refl\n\n------------------------------------------------------------------------\n-- Result of decidability\n\nisYes\u2257does : (a? : Dec A) \u2192 isYes a? \u2261 does a?\nisYes\u2257does (true  because _) = refl\nisYes\u2257does (false because _) = refl\n\ndec-true : (a? : Dec A) \u2192 A \u2192 does a? \u2261 true\ndec-true (true  because   _ ) a = refl\ndec-true (false because [\u00aca]) a = contradiction a (invert [\u00aca])\n\ndec-false : (a? : Dec A) \u2192 \u00ac A \u2192 does a? \u2261 false\ndec-false (false because  _ ) \u00aca = refl\ndec-false (true  because [a]) \u00aca = contradiction (invert [a]) \u00aca\n\ndec-yes-recompute : (a? : Dec A) \u2192 .(a : A) \u2192 a? \u2261 yes (recompute a? a)\ndec-yes-recompute a? a with yes _ \u2190 a? | refl \u2190 dec-true a? (recompute a? a) = refl\n\ndec-yes-irr : (a? : Dec A) \u2192 Irrelevant A \u2192 (a : A) \u2192 a? \u2261 yes a\ndec-yes-irr a? irr a =\n  trans (dec-yes-recompute a? a) (\u2261.cong yes (recompute-irrelevant-id a? irr a))\n\ndec-yes : (a? : Dec A) \u2192 A \u2192 \u2203 \u03bb a \u2192 a? \u2261 yes a\ndec-yes a? a = _ , dec-yes-recompute a? a\n\ndec-no : (a? : Dec A) (\u00aca : \u00ac A) \u2192 a? \u2261 no \u00aca\ndec-no a? \u00aca with no _ \u2190 a? | refl \u2190 dec-false a? \u00aca = refl\n\n\u230a\u230b-map\u2032 : \u2200 t f (a? : Dec A) \u2192 \u230a map\u2032 {B = B} t f a? \u230b \u2261 \u230a a? \u230b\n\u230a\u230b-map\u2032 t f a? = trans (isYes\u2257does (map\u2032 t f a?)) (sym (isYes\u2257does a?))\n\ndoes-\u2261 : (a? b? : Dec A) \u2192 does a? \u2261 does b?\ndoes-\u2261 a? (yes a) = dec-true a? a\ndoes-\u2261 a? (no \u00aca) = dec-false a? \u00aca\n\ndoes-\u21d4 : A \u21d4 B \u2192 (a? : Dec A) \u2192 (b? : Dec B) \u2192 does a? \u2261 does b?\ndoes-\u21d4 A\u21d4B a? = does-\u2261 (map A\u21d4B a?)\n</pre>"},{"location":"md/Relation/Nullary/Decidable/Core/","title":"Relation.Nullary.Decidable.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on and properties of decidable relations\n--\n-- This file contains some core definitions which are re-exported by\n-- Relation.Nullary.Decidable\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Decidable.Core where\n\n-- decToMaybe was deprecated in v2.1 #2330/#2336\n-- this can go through `Data.Maybe.Base` once that deprecation is fully done.\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Agda.Builtin.Maybe using (Maybe; just; nothing)\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool; T; false; true; not; _\u2227_; _\u2228_)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Data.Empty.Polymorphic using (\u22a5)\nopen import Data.Product.Base using (_\u00d7_)\nopen import Data.Sum.Base using (_\u228e_; inj\u2081; inj\u2082)\nopen import Function.Base using (_\u2218_; const; _$_; flip)\nopen import Relation.Nullary.Irrelevant using (Irrelevant)\nopen import Relation.Nullary.Recomputable.Core as Recomputable\n  using (Recomputable)\nopen import Relation.Nullary.Reflects as Reflects\n  hiding (recompute; recompute-constant)\nopen import Relation.Nullary.Negation.Core\n  using (\u00ac_; Stable; negated-stable; contradiction; DoubleNegation)\n\n\nprivate\n  variable\n    a b : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Definition.\n\n-- Decidability proofs have two parts: the `does` term which contains\n-- the boolean result and the `proof` term which contains a proof that\n-- reflects the boolean result. This definition allows the boolean\n-- part of the decision procedure to compute independently from the\n-- proof. This leads to better computational behaviour when we only care\n-- about the result and not the proof. See README.Design.Decidability\n-- for further details.\n\ninfix 2 _because_\n\nrecord Dec (A : Set a) : Set a where\n  constructor _because_\n  field\n    does  : Bool\n    proof : Reflects A does\n\nopen Dec public\n\npattern yes a =  true because of\u02b8  a\npattern no \u00aca = false because of\u207f \u00aca\n\n------------------------------------------------------------------------\n-- Flattening\n\nmodule _ {A : Set a} where\n\n  From-yes : Dec A \u2192 Set a\n  From-yes (true  because _) = A\n  From-yes (false because _) = \u22a4\n\n  From-no : Dec A \u2192 Set a\n  From-no (false because _) = \u00ac A\n  From-no (true  because _) = \u22a4\n\n------------------------------------------------------------------------\n-- Recompute\n\n-- Given an irrelevant proof of a decidable type, a proof can\n-- be recomputed and subsequently used in relevant contexts.\n\nrecompute : Dec A \u2192 Recomputable A\nrecompute = Reflects.recompute \u2218 proof\n\nrecompute-constant : (a? : Dec A) (p q : A) \u2192 recompute a? p \u2261 recompute a? q\nrecompute-constant = Recomputable.recompute-constant \u2218 recompute\n\nrecompute-irrelevant-id : (a? : Dec A) \u2192 Irrelevant A \u2192 (a : A) \u2192 recompute a? a \u2261 a\nrecompute-irrelevant-id = Recomputable.recompute-irrelevant-id \u2218 recompute\n\n------------------------------------------------------------------------\n-- Interaction with negation, sum, product etc.\n\ninfixr 1 _\u228e-dec_\ninfixr 2 _\u00d7-dec_ _\u2192-dec_\n\nT? : \u2200 x \u2192 Dec (T x)\nT? x = x because T-reflects x\n\n\u00ac? : Dec A \u2192 Dec (\u00ac A)\ndoes  (\u00ac? a?) = not (does a?)\nproof (\u00ac? a?) = \u00ac-reflects (proof a?)\n\n\u22a4-dec : Dec {a} \u22a4\ndoes  \u22a4-dec = true\nproof \u22a4-dec = \u22a4-reflects\n\n_\u00d7-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u00d7 B)\ndoes  (a? \u00d7-dec b?) = does a? \u2227 does b?\nproof (a? \u00d7-dec b?) = proof a? \u00d7-reflects proof b?\n\n\u22a5-dec : Dec {a} \u22a5\ndoes  \u22a5-dec  = false\nproof \u22a5-dec  = \u22a5-reflects\n\n_\u228e-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u228e B)\ndoes  (a? \u228e-dec b?) = does a? \u2228 does b?\nproof (a? \u228e-dec b?) = proof a? \u228e-reflects proof b?\n\n_\u2192-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u2192 B)\ndoes  (a? \u2192-dec b?) = not (does a?) \u2228 does b?\nproof (a? \u2192-dec b?) = proof a? \u2192-reflects proof b?\n\n------------------------------------------------------------------------\n-- Relationship with Maybe\n\ndec\u21d2maybe : Dec A \u2192 Maybe A\ndec\u21d2maybe ( true because [a]) = just (invert [a])\ndec\u21d2maybe (false because  _ ) = nothing\n\n------------------------------------------------------------------------\n-- Relationship with Sum\n\ntoSum : Dec A \u2192 A \u228e \u00ac A\ntoSum ( true because  [p]) = inj\u2081 (invert  [p])\ntoSum (false because [\u00acp]) = inj\u2082 (invert [\u00acp])\n\nfromSum : A \u228e \u00ac A \u2192 Dec A\nfromSum (inj\u2081 p)  = yes p\nfromSum (inj\u2082 \u00acp) = no \u00acp\n\n------------------------------------------------------------------------\n-- Relationship with booleans\n\n-- `isYes` is a stricter version of `does`. The lack of computation\n-- means that we can recover the proposition `P` from `isYes a?` by\n-- unification. This is useful when we are using the decision procedure\n-- for proof automation.\n\nisYes : Dec A \u2192 Bool\nisYes (true  because _) = true\nisYes (false because _) = false\n\nisNo : Dec A \u2192 Bool\nisNo = not \u2218 isYes\n\nTrue : Dec A \u2192 Set\nTrue = T \u2218 isYes\n\nFalse : Dec A \u2192 Set\nFalse = T \u2218 isNo\n\n-- The traditional name for isYes is \u230a_\u230b, indicating the stripping of evidence.\n\u230a_\u230b = isYes\n\n------------------------------------------------------------------------\n-- Witnesses\n\n-- Gives a witness to the \"truth\".\ntoWitness : {a? : Dec A} \u2192 True a? \u2192 A\ntoWitness {a? = true  because [a]} _  = invert [a]\ntoWitness {a? = false because  _ } ()\n\n-- Establishes a \"truth\", given a witness.\nfromWitness : {a? : Dec A} \u2192 A \u2192 True a?\nfromWitness {a? = true  because   _ } = const _\nfromWitness {a? = false because [\u00aca]} = invert [\u00aca]\n\n-- Variants for False.\ntoWitnessFalse : {a? : Dec A} \u2192 False a? \u2192 \u00ac A\ntoWitnessFalse {a? = true  because   _ } ()\ntoWitnessFalse {a? = false because [\u00aca]} _  = invert [\u00aca]\n\nfromWitnessFalse : {a? : Dec A} \u2192 \u00ac A \u2192 False a?\nfromWitnessFalse {a? = true  because [a]} = flip _$_ (invert [a])\nfromWitnessFalse {a? = false because  _ } = const _\n\n-- If a decision procedure returns \"yes\", then we can extract the\n-- proof using from-yes.\nfrom-yes : (a? : Dec A) \u2192 From-yes a?\nfrom-yes (true  because [a]) = invert [a]\nfrom-yes (false because _ ) = _\n\n-- If a decision procedure returns \"no\", then we can extract the proof\n-- using from-no.\nfrom-no : (a? : Dec A) \u2192 From-no a?\nfrom-no (false because [\u00aca]) = invert [\u00aca]\nfrom-no (true  because   _ ) = _\n\n------------------------------------------------------------------------\n-- Maps\n\nmap\u2032 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Dec A \u2192 Dec B\ndoes  (map\u2032 A\u2192B B\u2192A a?)                   = does a?\nproof (map\u2032 A\u2192B B\u2192A (true  because  [a])) = of (A\u2192B (invert [a]))\nproof (map\u2032 A\u2192B B\u2192A (false because [\u00aca])) = of (invert [\u00aca] \u2218 B\u2192A)\n\n------------------------------------------------------------------------\n-- Relationship with double-negation\n\n-- Decidable predicates are stable.\n\ndecidable-stable : Dec A \u2192 Stable A\ndecidable-stable (true  because  [a]) \u00ac\u00aca = invert [a]\ndecidable-stable (false because [\u00aca]) \u00ac\u00aca = contradiction (invert [\u00aca]) \u00ac\u00aca\n\n\u00ac-drop-Dec : Dec (\u00ac \u00ac A) \u2192 Dec (\u00ac A)\n\u00ac-drop-Dec \u00ac\u00aca? = map\u2032 negated-stable contradiction (\u00ac? \u00ac\u00aca?)\n\n-- A double-negation-translated variant of excluded middle (or: every\n-- nullary relation is decidable in the double-negation monad).\n\n\u00ac\u00ac-excluded-middle : DoubleNegation (Dec A)\n\u00ac\u00ac-excluded-middle \u00ac?a = \u00ac?a (no (\u03bb a \u2192 \u00ac?a (yes a)))\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nexcluded-middle = \u00ac\u00ac-excluded-middle\n{-# WARNING_ON_USAGE excluded-middle\n\"Warning: excluded-middle was deprecated in v2.0.\nPlease use \u00ac\u00ac-excluded-middle instead.\"\n#-}\n\n-- Version 2.1\n\ndecToMaybe = dec\u21d2maybe\n{-# WARNING_ON_USAGE decToMaybe\n\"Warning: decToMaybe was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.dec\u21d2maybe instead.\"\n#-}\n\nfromDec = toSum\n{-# WARNING_ON_USAGE fromDec\n\"Warning: fromDec was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.toSum instead.\"\n#-}\n\ntoDec = fromSum\n{-# WARNING_ON_USAGE toDec\n\"Warning: toDec was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.fromSum instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Nullary/Irrelevant/","title":"Relation.Nullary.Irrelevant","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- A type `A` is irrelevant if all of its elements are equal.\n-- This is also refered to as \"A is an h-proposition\".\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Irrelevant where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Level using (Level)\n\nprivate\n  variable\n    p : Level\n\nIrrelevant : Set p \u2192 Set p\nIrrelevant P = \u2200 (p\u2081 p\u2082 : P) \u2192 p\u2081 \u2261 p\u2082\n</pre>"},{"location":"md/Relation/Nullary/Negation/","title":"Relation.Nullary.Negation","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties related to negation\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Negation where\n\nopen import Data.Bool.Base using (Bool; false; true; if_then_else_)\nopen import Data.Product.Base as Product using (_,_; \u03a3; \u03a3-syntax; \u2203; curry; uncurry)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082; [_,_])\nopen import Effect.Monad using (RawMonad; mkRawMonad)\nopen import Function.Base using (flip; _\u2218_; const; _\u2218\u2032_)\nopen import Level using (Level)\nopen import Relation.Nullary.Decidable.Core using (Dec; yes; no; \u00ac\u00ac-excluded-middle)\nopen import Relation.Unary using (Universal; Pred)\n\nprivate\n  variable\n    a b c d p w : Level\n    A B C D : Set a\n    P : Pred A p\n    Whatever : Set w\n\n------------------------------------------------------------------------\n-- Re-export public definitions\n\nopen import Relation.Nullary.Negation.Core public\n\n------------------------------------------------------------------------\n-- Quantifier juggling\n\n\u2203\u27f6\u00ac\u2200\u00ac : \u2203 P \u2192 \u00ac (\u2200 x \u2192 \u00ac P x)\n\u2203\u27f6\u00ac\u2200\u00ac = flip uncurry\n\n\u2200\u27f6\u00ac\u2203\u00ac : (\u2200 x \u2192 P x) \u2192 \u00ac \u2203 \u03bb x \u2192 \u00ac P x\n\u2200\u27f6\u00ac\u2203\u00ac \u2200xPx (x , \u00acPx) = \u00acPx (\u2200xPx x)\n\n\u00ac\u2203\u27f6\u2200\u00ac : \u00ac \u2203 (\u03bb x \u2192 P x) \u2192 \u2200 x \u2192 \u00ac P x\n\u00ac\u2203\u27f6\u2200\u00ac = curry\n\n\u2200\u00ac\u27f6\u00ac\u2203 : (\u2200 x \u2192 \u00ac P x) \u2192 \u00ac \u2203 (\u03bb x \u2192 P x)\n\u2200\u00ac\u27f6\u00ac\u2203 = uncurry\n\n\u2203\u00ac\u27f6\u00ac\u2200 : \u2203 (\u03bb x \u2192 \u00ac P x) \u2192 \u00ac (\u2200 x \u2192 P x)\n\u2203\u00ac\u27f6\u00ac\u2200 = flip \u2200\u27f6\u00ac\u2203\u00ac\n\n------------------------------------------------------------------------\n-- Double Negation\n\n-- Double-negation is a monad (if we assume that all elements of \u00ac \u00ac P\n-- are equal).\n\n\u00ac\u00ac-Monad : RawMonad {a} DoubleNegation\n\u00ac\u00ac-Monad = mkRawMonad\n  DoubleNegation\n  contradiction\n  (\u03bb x f \u2192 negated-stable (\u00ac\u00ac-map f x))\n\n\u00ac\u00ac-push : DoubleNegation \u03a0[ P ] \u2192 \u03a0[ DoubleNegation \u2218 P ]\n\u00ac\u00ac-push \u00ac\u00ac\u2200P a \u00acPa = \u00ac\u00ac\u2200P (\u03bb \u2200P \u2192 \u00acPa (\u2200P a))\n\n-- If Whatever is instantiated with \u00ac\u00a0\u00ac\u00a0something, then this function\n-- is call with current continuation in the double-negation monad, or,\n-- if you will, a double-negation translation of Peirce's law.\n--\n-- In order to prove \u00ac\u00a0\u00ac\u00a0P one can assume \u00ac\u00a0P and prove \u22a5. However,\n-- sometimes it is nice to avoid leaving the double-negation monad; in\n-- that case this function can be used (with Whatever instantiated to\n-- \u22a5).\n\ncall/cc : ((A \u2192 Whatever) \u2192 DoubleNegation A) \u2192 DoubleNegation A\ncall/cc hyp \u00aca = hyp (flip contradiction \u00aca) \u00aca\n\n-- The \"independence of premise\" rule, in the double-negation monad.\n-- It is assumed that the index set (A) is inhabited.\n\nindependence-of-premise : A \u2192 (B \u2192 \u03a3 A P) \u2192 DoubleNegation (\u03a3[ x \u2208 A ] (B \u2192 P x))\nindependence-of-premise {A = A} {B = B} {P = P} q f = \u00ac\u00ac-map helper \u00ac\u00ac-excluded-middle\n  where\n  helper : Dec B \u2192 \u03a3[ x \u2208 A ] (B \u2192 P x)\n  helper (yes p) = Product.map\u2082 const (f p)\n  helper (no \u00acp) = (q , flip contradiction \u00acp)\n\n-- The independence of premise rule for binary sums.\n\nindependence-of-premise-\u228e : (A \u2192 B \u228e C) \u2192 DoubleNegation ((A \u2192 B) \u228e (A \u2192 C))\nindependence-of-premise-\u228e {A = A} {B = B} {C = C} f = \u00ac\u00ac-map helper \u00ac\u00ac-excluded-middle\n  where\n  helper : Dec A \u2192 (A \u2192 B) \u228e (A \u2192 C)\n  helper (yes p) = Sum.map const const (f p)\n  helper (no \u00acp) = inj\u2081 (flip contradiction \u00acp)\n\nprivate\n\n  -- Note that independence-of-premise-\u228e is a consequence of\n  -- independence-of-premise (for simplicity it is assumed that Q and\n  -- R have the same type here):\n\n  corollary : {B C : Set b} \u2192 (A \u2192 B \u228e C) \u2192 DoubleNegation ((A \u2192 B) \u228e (A \u2192 C))\n  corollary {A = A} {B = B} {C = C} f =\n    \u00ac\u00ac-map helper (independence-of-premise true ([ _,_ true , _,_ false ] \u2218\u2032 f))\n    where\n    helper : \u2203 (\u03bb b \u2192 A \u2192 if b then B else C) \u2192 (A \u2192 B) \u228e (A \u2192 C)\n    helper (true  , f) = inj\u2081 f\n    helper (false , f) = inj\u2082 f\n</pre>"},{"location":"md/Relation/Nullary/Negation/Core/","title":"Relation.Nullary.Negation.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core properties related to negation\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Negation.Core where\n\nopen import Data.Empty using (\u22a5; \u22a5-elim-irr)\nopen import Data.Sum.Base using (_\u228e_; [_,_]; inj\u2081; inj\u2082)\nopen import Function.Base using (flip; _\u2218_; const)\nopen import Level using (Level; _\u2294_)\n\nprivate\n  variable\n    a p q w : Level\n    A B C : Set a\n    Whatever : Set w\n\n------------------------------------------------------------------------\n-- Negation.\n\ninfix 3 \u00ac_\n\u00ac_ : Set a \u2192 Set a\n\u00ac A = A \u2192 \u22a5\n\n------------------------------------------------------------------------\n-- Stability.\n\n-- Double-negation\nDoubleNegation : Set a \u2192 Set a\nDoubleNegation A = \u00ac \u00ac A\n\n-- Stability under double-negation.\nStable : Set a \u2192 Set a\nStable A = \u00ac \u00ac A \u2192 A\n\n------------------------------------------------------------------------\n-- Relationship to sum\n\ninfixr 1 _\u00ac-\u228e_\n_\u00ac-\u228e_ : \u00ac A \u2192 \u00ac B \u2192 \u00ac (A \u228e B)\n_\u00ac-\u228e_ = [_,_]\n\n------------------------------------------------------------------------\n-- Uses of negation\n\ncontradiction-irr : .A \u2192 \u00ac A \u2192 Whatever\ncontradiction-irr a \u00aca = \u22a5-elim-irr (\u00aca a)\n\ncontradiction : A \u2192 \u00ac A \u2192 Whatever\ncontradiction a = contradiction-irr a\n\ncontradiction\u2082 : A \u228e B \u2192 \u00ac A \u2192 \u00ac B \u2192 Whatever\ncontradiction\u2082 (inj\u2081 a) \u00aca \u00acb = contradiction a \u00aca\ncontradiction\u2082 (inj\u2082 b) \u00aca \u00acb = contradiction b \u00acb\n\ncontraposition : (A \u2192 B) \u2192 \u00ac B \u2192 \u00ac A\ncontraposition f \u00acb a = contradiction (f a) \u00acb\n\n-- Self-contradictory propositions are false by 'diagonalisation'\n\ncontra-diagonal : (A \u2192 \u00ac A) \u2192 \u00ac A\ncontra-diagonal self a = self a a\n\n-- Everything is stable in the double-negation monad.\nstable : \u00ac \u00ac Stable A\nstable \u00ac[\u00ac\u00aca\u2192a] = \u00ac[\u00ac\u00aca\u2192a] (contradiction (\u00ac[\u00ac\u00aca\u2192a] \u2218 const))\n\n-- Negated predicates are stable.\nnegated-stable : Stable (\u00ac A)\nnegated-stable \u00ac\u00ac\u00aca a = \u00ac\u00ac\u00aca (contradiction a)\n\n\u00ac\u00ac-map : (A \u2192 B) \u2192 \u00ac \u00ac A \u2192 \u00ac \u00ac B\n\u00ac\u00ac-map f = contraposition (contraposition f)\n\n-- Note also the following use of flip:\nprivate\n  note : (A \u2192 \u00ac B) \u2192 B \u2192 \u00ac A\n  note = flip\n\n</pre>"},{"location":"md/Relation/Nullary/Recomputable/","title":"Relation.Nullary.Recomputable","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Recomputable types and their algebra as Harrop formulas\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Recomputable where\n\nopen import Data.Empty using (\u22a5)\nopen import Data.Irrelevant using (Irrelevant; irrelevant; [_])\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Level using (Level)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nprivate\n  variable\n    a b : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Re-export\n\nopen import Relation.Nullary.Recomputable.Core public\n\n\n------------------------------------------------------------------------\n-- Constructions\n\n-- Irrelevant types are Recomputable\n\nirrelevant-recompute : Recomputable (Irrelevant A)\nirrelevant (irrelevant-recompute [ a ]) = a\n\n-- Corollary: so too is \u22a5\n\n\u22a5-recompute : Recomputable \u22a5\n\u22a5-recompute = irrelevant-recompute\n\n_\u00d7-recompute_ : Recomputable A \u2192 Recomputable B \u2192 Recomputable (A \u00d7 B)\n(rA \u00d7-recompute rB) p = rA (p .proj\u2081) , rB (p .proj\u2082)\n\n_\u2192-recompute_ : (A : Set a) \u2192 Recomputable B \u2192 Recomputable (A \u2192 B)\n(A \u2192-recompute rB) f a = rB (f a)\n\n\u03a0-recompute : (B : A \u2192 Set b) \u2192 (\u2200 x \u2192 Recomputable (B x)) \u2192 Recomputable (\u2200 x \u2192 B x)\n\u03a0-recompute B rB f a = rB a (f a)\n\n\u2200-recompute : (B : A \u2192 Set b) \u2192 (\u2200 {x} \u2192 Recomputable (B x)) \u2192 Recomputable (\u2200 {x} \u2192 B x)\n\u2200-recompute B rB f = rB f\n\n-- Corollary: negations are Recomputable\n\n\u00ac-recompute : Recomputable (\u00ac A)\n\u00ac-recompute {A = A} = A \u2192-recompute \u22a5-recompute\n\n</pre>"},{"location":"md/Relation/Nullary/Recomputable/Core/","title":"Relation.Nullary.Recomputable.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Recomputable types and their algebra as Harrop formulas\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Recomputable.Core where\n\nopen import Agda.Builtin.Equality using (_\u2261_; refl)\nopen import Level using (Level)\nopen import Relation.Nullary.Irrelevant using (Irrelevant)\n\nprivate\n  variable\n    a : Level\n    A : Set a\n\n\n------------------------------------------------------------------------\n-- Definition\n--\n-- The idea of being 'recomputable' is that, given an *irrelevant* proof\n-- of a proposition `A` (signalled by being a value of type `.A`, all of\n-- whose inhabitants are identified up to definitional equality, and hence\n-- do *not* admit pattern-matching), one may 'promote' such a value to a\n-- 'genuine' value of `A`, available for subsequent eg. pattern-matching.\n\nRecomputable : (A : Set a) \u2192 Set a\nRecomputable A = .A \u2192 A\n\n------------------------------------------------------------------------\n-- Fundamental properties:\n-- given `Recomputable A`, `recompute` is a constant function;\n-- moreover, the identity, if `A` is propositionally irrelevant.\n\nmodule _ (recompute : Recomputable A) where\n\n  recompute-constant : (p q : A) \u2192 recompute p \u2261 recompute q\n  recompute-constant _ _ = refl\n\n  recompute-irrelevant-id : Irrelevant A \u2192 (a : A) \u2192 recompute a \u2261 a\n  recompute-irrelevant-id irr a = irr (recompute a) a\n\n</pre>"},{"location":"md/Relation/Nullary/Reflects/","title":"Relation.Nullary.Reflects","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of the `Reflects` construct\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Reflects where\n\nopen import Agda.Builtin.Equality\n\nopen import Data.Bool.Base\nopen import Data.Sum.Base using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Data.Empty.Polymorphic using (\u22a5)\nopen import Level using (Level)\nopen import Function.Base using (_$_; _\u2218_; const; id)\nopen import Relation.Nullary.Negation.Core\n  using (\u00ac_; contradiction-irr; contradiction; _\u00ac-\u228e_)\nopen import Relation.Nullary.Recomputable as Recomputable using (Recomputable)\n\nprivate\n  variable\n    a : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- `Reflects` idiom.\n\n-- The truth value of A is reflected by a boolean value.\n-- `Reflects A b` is equivalent to `if b then A else \u00ac A`.\n\ndata Reflects (A : Set a) : Bool \u2192 Set a where\n  of\u02b8 : ( a :   A) \u2192 Reflects A true\n  of\u207f : (\u00aca : \u00ac A) \u2192 Reflects A false\n\n------------------------------------------------------------------------\n-- Constructors and destructors\n\n-- These lemmas are intended to be used mostly when `b` is a value, so\n-- that the `if` expressions have already been evaluated away.\n-- In this case, `of` works like the relevant constructor (`of\u207f` or\n-- `of\u02b8`), and `invert` strips off the constructor to just give either\n-- the proof of `A` or the proof of `\u00ac A`.\n\nof : \u2200 {b} \u2192 if b then A else \u00ac A \u2192 Reflects A b\nof {b = false} \u00aca = of\u207f \u00aca\nof {b = true }  a = of\u02b8 a\n\ninvert : \u2200 {b} \u2192 Reflects A b \u2192 if b then A else \u00ac A\ninvert (of\u02b8  a) = a\ninvert (of\u207f \u00aca) = \u00aca\n\n------------------------------------------------------------------------\n-- recompute\n\n-- Given an irrelevant proof of a reflected type, a proof can\n-- be recomputed and subsequently used in relevant contexts.\n\nrecompute : \u2200 {b} \u2192 Reflects A b \u2192 Recomputable A\nrecompute (of\u02b8  a) _ = a\nrecompute (of\u207f \u00aca) a = contradiction-irr a \u00aca\n\nrecompute-constant : \u2200 {b} (r : Reflects A b) (p q : A) \u2192\n                     recompute r p \u2261 recompute r q\nrecompute-constant = Recomputable.recompute-constant \u2218 recompute\n\n------------------------------------------------------------------------\n-- Interaction with true, false, negation, product, sums etc.\n\ninfixr 1 _\u228e-reflects_\ninfixr 2 _\u00d7-reflects_ _\u2192-reflects_\n\n\u22a5-reflects : Reflects (\u22a5 {a}) false\n\u22a5-reflects = of \u03bb()\n\n\u22a4-reflects : Reflects (\u22a4 {a}) true\n\u22a4-reflects = of _\n\nT-reflects : \u2200 b \u2192 Reflects (T b) b\nT-reflects true  = of _\nT-reflects false = of id\n\n\u00ac-reflects : \u2200 {b} \u2192 Reflects A b \u2192 Reflects (\u00ac A) (not b)\n\u00ac-reflects (of\u02b8  a) = of (_$ a)\n\u00ac-reflects (of\u207f \u00aca) = of \u00aca\n\n_\u00d7-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n               Reflects (A \u00d7 B) (a \u2227 b)\nof\u02b8  a \u00d7-reflects of\u02b8  b = of (a , b)\nof\u02b8  a \u00d7-reflects of\u207f \u00acb = of (\u00acb \u2218 proj\u2082)\nof\u207f \u00aca \u00d7-reflects _      = of (\u00aca \u2218 proj\u2081)\n\n_\u228e-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n               Reflects (A \u228e B) (a \u2228 b)\nof\u02b8  a \u228e-reflects      _ = of (inj\u2081 a)\nof\u207f \u00aca \u228e-reflects of\u02b8  b = of (inj\u2082 b)\nof\u207f \u00aca \u228e-reflects of\u207f \u00acb = of (\u00aca \u00ac-\u228e \u00acb)\n\n_\u2192-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n                Reflects (A \u2192 B) (not a \u2228 b)\nof\u02b8  a \u2192-reflects of\u02b8  b = of (const b)\nof\u02b8  a \u2192-reflects of\u207f \u00acb = of (\u00acb \u2218 (_$ a))\nof\u207f \u00aca \u2192-reflects _      = of (\u03bb a \u2192 contradiction a \u00aca)\n\n------------------------------------------------------------------------\n-- Other lemmas\n\nfromEquivalence : \u2200 {b} \u2192 (T b \u2192 A) \u2192 (A \u2192 T b) \u2192 Reflects A b\nfromEquivalence {b = true}  sound complete = of (sound _)\nfromEquivalence {b = false} sound complete = of complete\n\n-- `Reflects` is deterministic.\ndet : \u2200 {b b\u2032} \u2192 Reflects A b \u2192 Reflects A b\u2032 \u2192 b \u2261 b\u2032\ndet (of\u02b8  a) (of\u02b8  _) = refl\ndet (of\u02b8  a) (of\u207f \u00aca) = contradiction a \u00aca\ndet (of\u207f \u00aca) (of\u02b8  a) = contradiction a \u00aca\ndet (of\u207f \u00aca) (of\u207f  _) = refl\n\nT-reflects-elim : \u2200 {a b} \u2192 Reflects (T a) b \u2192 b \u2261 a\nT-reflects-elim {a} r = det r (T-reflects a)\n</pre>"},{"location":"md/Relation/Unary/","title":"Relation.Unary","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Unary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Unary where\n\nopen import Data.Empty using (\u22a5)\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.Product.Base using (_\u00d7_; _,_; \u03a3-syntax; \u2203; uncurry; swap)\nopen import Data.Sum.Base using (_\u228e_; [_,_])\nopen import Function.Base using (_\u2218_; _|&gt;_)\nopen import Level using (Level; _\u2294_; 0\u2113; suc; Lift)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Relation.Nullary as Nullary using (\u00ac_; Dec; True)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\n-- Unary relations are known as predicates and `Pred A \u2113` can be viewed\n-- as some property that elements of type A might satisfy.\n\n-- Consequently `P : Pred A \u2113` can also be seen as a subset of A\n-- containing all the elements of A that satisfy property P. This view\n-- informs much of the notation used below.\n\nPred : \u2200 {a} \u2192 Set a \u2192 (\u2113 : Level) \u2192 Set (a \u2294 suc \u2113)\nPred A \u2113 = A \u2192 Set \u2113\n\n------------------------------------------------------------------------\n-- Special sets\n\n-- The empty set.\n-- Explicitly not level polymorphic as this often causes unsolved metas;\n-- see `Relation.Unary.Polymorphic` for a level-polymorphic version.\n\n\u2205 : Pred A 0\u2113\n\u2205 = \u03bb _ \u2192 \u22a5\n\n-- The singleton set.\n\n\uff5b_\uff5d : A \u2192 Pred A _\n\uff5b x \uff5d = x \u2261_\n\n-- The universal set.\n-- Explicitly not level polymorphic (see comments for `\u2205` for more details)\n\nU : Pred A 0\u2113\nU = \u03bb _ \u2192 \u22a4\n\n------------------------------------------------------------------------\n-- Membership\n\ninfix 4 _\u2208_ _\u2209_\n\n_\u2208_ : A \u2192 Pred A \u2113 \u2192 Set _\nx \u2208 P = P x\n\n_\u2209_ : A \u2192 Pred A \u2113 \u2192 Set _\nx \u2209 P = \u00ac x \u2208 P\n\n------------------------------------------------------------------------\n-- Subset relations\n\ninfix 4 _\u2286_ _\u2287_ _\u2288_ _\u2289_ _\u2282_ _\u2283_ _\u2284_ _\u2285_ _\u2250_ _\u2250\u2032_\n\n_\u2286_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2286 Q = \u2200 {x} \u2192 x \u2208 P \u2192 x \u2208 Q\n\n_\u2287_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2287 Q = Q \u2286 P\n\n_\u2288_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2288 Q = \u00ac (P \u2286 Q)\n\n_\u2289_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2289 Q = \u00ac (P \u2287 Q)\n\n_\u2282_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2282 Q = P \u2286 Q \u00d7 Q \u2288 P\n\n_\u2283_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2283 Q = Q \u2282 P\n\n_\u2284_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2284 Q = \u00ac (P \u2282 Q)\n\n_\u2285_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2285 Q = \u00ac (P \u2283 Q)\n\n_\u2250_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2250 Q = (P \u2286 Q) \u00d7 (Q \u2286 P)\n\n-- The following primed variants of _\u2286_ can be used when 'x' can't\n-- be inferred from 'x \u2208 P'.\n\ninfix 4 _\u2286\u2032_ _\u2287\u2032_ _\u2288\u2032_ _\u2289\u2032_ _\u2282\u2032_ _\u2283\u2032_ _\u2284\u2032_ _\u2285\u2032_\n\n_\u2286\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2286\u2032 Q = \u2200 x \u2192 x \u2208 P \u2192 x \u2208 Q\n\n_\u2287\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nQ \u2287\u2032 P = P \u2286\u2032 Q\n\n_\u2288\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2288\u2032 Q = \u00ac (P \u2286\u2032 Q)\n\n_\u2289\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2289\u2032 Q = \u00ac (P \u2287\u2032 Q)\n\n_\u2282\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2282\u2032 Q = P \u2286\u2032 Q \u00d7 Q \u2288\u2032 P\n\n_\u2283\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2283\u2032 Q = Q \u2282\u2032 P\n\n_\u2284\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2284\u2032 Q = \u00ac (P \u2282\u2032 Q)\n\n_\u2285\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2285\u2032 Q = \u00ac (P \u2283\u2032 Q)\n\n_\u2250\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2250\u2032 Q = (P \u2286\u2032 Q) \u00d7 (Q \u2286\u2032 P)\n\n------------------------------------------------------------------------\n-- Properties of sets\n\ninfix 10 Satisfiable Universal IUniversal\n\n-- Emptiness - no element satisfies P.\n\nEmpty : Pred A \u2113 \u2192 Set _\nEmpty P = \u2200 x \u2192 x \u2209 P\n\n-- Satisfiable - at least one element satisfies P.\n\nSatisfiable : Pred A \u2113 \u2192 Set _\nSatisfiable P = \u2203 \u03bb x \u2192 x \u2208 P\n\nsyntax Satisfiable P = \u2203\u27e8 P \u27e9\n\n-- Universality - all elements satisfy P.\n\nUniversal : Pred A \u2113 \u2192 Set _\nUniversal P = \u2200 x \u2192 x \u2208 P\n\nsyntax Universal  P = \u03a0[ P ]\n\n-- Implicit universality - all elements satisfy P.\n\nIUniversal : Pred A \u2113 \u2192 Set _\nIUniversal P = \u2200 {x} \u2192 x \u2208 P\n\nsyntax IUniversal P = \u2200[ P ]\n\n-- Irrelevance - any two proofs that an element satifies P are\n-- indistinguishable.\n\nIrrelevant : Pred A \u2113 \u2192 Set _\nIrrelevant P = \u2200 {x} \u2192 Nullary.Irrelevant (P x)\n\n-- Recomputability - we can rebuild a relevant proof given an\n-- irrelevant one.\n\nRecomputable : Pred A \u2113 \u2192 Set _\nRecomputable P = \u2200 {x} \u2192 Nullary.Recomputable (P x)\n\n-- Stability - instances of P are stable wrt double negation\n\nStable : Pred A \u2113 \u2192 Set _\nStable P = \u2200 x \u2192 Nullary.Stable (P x)\n\n-- Weak Decidability\n\nWeaklyDecidable : Pred A \u2113 \u2192 Set _\nWeaklyDecidable P = \u2200 x \u2192 Nullary.WeaklyDecidable (P x)\n\n-- Decidability - it is possible to determine if an arbitrary element\n-- satisfies P.\n\nDecidable : Pred A \u2113 \u2192 Set _\nDecidable P = \u2200 x \u2192 Dec (P x)\n\n-- Erasure: A decidable predicate gives rise to another one, more\n-- amenable to \u03b7-expansion\n\n\u230a_\u230b : {P : Pred A \u2113} \u2192 Decidable P \u2192 Pred A \u2113\n\u230a P? \u230b a = Lift _ (True (P? a))\n\n------------------------------------------------------------------------\n-- Operations on sets\n\ninfix 10 \u22c3 \u22c2\ninfixr 9 _\u22a2_\ninfixr 8 _\u21d2_\ninfixr 7 _\u2229_\ninfixr 6 _\u222a_\ninfixr 6 _\u2216_\ninfix 4 _\u226c_ _\u22a5_ _\u22a5\u2032_\n\n-- Complement.\n\n\u2201 : Pred A \u2113 \u2192 Pred A \u2113\n\u2201 P = \u03bb x \u2192 x \u2209 P\n\n-- Implication.\n\n_\u21d2_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u21d2 Q = \u03bb x \u2192 x \u2208 P \u2192 x \u2208 Q\n\n-- Union.\n\n_\u222a_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u222a Q = \u03bb x \u2192 x \u2208 P \u228e x \u2208 Q\n\n-- Intersection.\n\n_\u2229_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u2229 Q = \u03bb x \u2192 x \u2208 P \u00d7 x \u2208 Q\n\n-- Difference.\n\n_\u2216_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u2216 Q = \u03bb x \u2192 x \u2208 P \u00d7 x \u2209 Q\n\n-- Infinitary union.\n\n\u22c3 : \u2200 {i} (I : Set i) \u2192 (I \u2192 Pred A \u2113) \u2192 Pred A _\n\u22c3 I P = \u03bb x \u2192 \u03a3[ i \u2208 I ] P i x\n\nsyntax \u22c3 I (\u03bb i \u2192 P) = \u22c3[ i \u2236 I ] P\n\n-- Infinitary intersection.\n\n\u22c2 : \u2200 {i} (I : Set i) \u2192 (I \u2192 Pred A \u2113) \u2192 Pred A _\n\u22c2 I P = \u03bb x \u2192 (i : I) \u2192 P i x\n\nsyntax \u22c2 I (\u03bb i \u2192 P) = \u22c2[ i \u2236 I ] P\n\n-- Positive version of non-disjointness, dual to inclusion.\n\n_\u226c_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u226c Q = \u2203 \u03bb x \u2192 x \u2208 P \u00d7 x \u2208 Q\n\n-- Disjoint\n\n_\u22a5_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u22a5 Q = P \u2229 Q \u2286 \u2205\n\n_\u22a5\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u22a5\u2032 Q = P \u2229 Q \u2286\u2032 \u2205\n\n-- Update.\n\n_\u22a2_ : (A \u2192 B) \u2192 Pred B \u2113 \u2192 Pred A \u2113\nf \u22a2 P = \u03bb x \u2192 P (f x)\n\n------------------------------------------------------------------------\n-- Predicate combinators\n\n-- These differ from the set operations above, as the carrier set of the\n-- resulting predicates are not the same as the carrier set of the\n-- component predicates.\n\ninfixr  2 _\u27e8\u00d7\u27e9_\ninfixr  2 _\u27e8\u2299\u27e9_\ninfixr  1 _\u27e8\u228e\u27e9_\ninfixr  0 _\u27e8\u2192\u27e9_\ninfixl  9 _\u27e8\u00b7\u27e9_\ninfix  10 _~\ninfixr  9 _\u27e8\u2218\u27e9_\ninfixr  2 _//_ _\\\\_\n\n-- Product.\n\n_\u27e8\u00d7\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P \u27e8\u00d7\u27e9 Q) (x , y) = x \u2208 P \u00d7 y \u2208 Q\n\n-- Sum over one element.\n\n_\u27e8\u228e\u27e9_ : Pred A \u2113 \u2192 Pred B \u2113 \u2192 Pred (A \u228e B) _\nP \u27e8\u228e\u27e9 Q = [ P , Q ]\n\n-- Sum over two elements.\n\n_\u27e8\u2299\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P \u27e8\u2299\u27e9 Q) (x , y) = x \u2208 P \u228e y \u2208 Q\n\n-- Implication.\n\n_\u27e8\u2192\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u2192 B) _\n(P \u27e8\u2192\u27e9 Q) f = P \u2286 Q \u2218 f\n\n-- Product.\n\n_\u27e8\u00b7\u27e9_ : (P : Pred A \u2113\u2081) (Q : Pred B \u2113\u2082) \u2192\n        (P \u27e8\u00d7\u27e9 (P \u27e8\u2192\u27e9 Q)) \u2286 Q \u2218 uncurry _|&gt;_\n(P \u27e8\u00b7\u27e9 Q) (p , f) = f p\n\n-- Converse.\n\n_~ : Pred (A \u00d7 B) \u2113 \u2192 Pred (B \u00d7 A) \u2113\nP ~ = P \u2218 swap\n\n-- Composition.\n\n_\u27e8\u2218\u27e9_ : Pred (A \u00d7 B) \u2113\u2081 \u2192 Pred (B \u00d7 C) \u2113\u2082 \u2192 Pred (A \u00d7 C) _\n(P \u27e8\u2218\u27e9 Q) (x , z) = \u2203 \u03bb y \u2192 (x , y) \u2208 P \u00d7 (y , z) \u2208 Q\n\n-- Post-division.\n\n_//_ : Pred (A \u00d7 C) \u2113\u2081 \u2192 Pred (B \u00d7 C) \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P // Q) (x , y) = Q \u2218 (y ,_) \u2286 P \u2218 (x ,_)\n\n-- Pre-division.\n\n_\\\\_ : Pred (A \u00d7 C) \u2113\u2081 \u2192 Pred (A \u00d7 B) \u2113\u2082 \u2192 Pred (B \u00d7 C) _\nP \\\\ Q = (P ~ // Q ~) ~\n</pre>"},{"location":"md/Relation/Unary/PredicateTransformer/","title":"Relation.Unary.PredicateTransformer","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Predicate transformers\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Unary.PredicateTransformer where\n\nopen import Data.Product.Base using (\u2203)\nopen import Function.Base using (_\u2218_)\nopen import Level hiding (_\u2294_)\nopen import Relation.Unary\nopen import Relation.Binary.Core using (REL)\n\nprivate\n  variable\n    a b c i \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Heterogeneous and homogeneous predicate transformers\n\nPT : Set a \u2192 Set b \u2192 (\u2113\u2081 \u2113\u2082 : Level) \u2192 Set _\nPT A B \u2113\u2081 \u2113\u2082 = Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082\n\nPt : Set a \u2192 (\u2113 : Level) \u2192 Set _\nPt A \u2113 = PT A A \u2113 \u2113\n\n------------------------------------------------------------------------\n-- Composition and identity\n\ninfixr 9 _\u236e_\n\n_\u236e_ : PT B C \u2113\u2082 \u2113\u2083 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A C \u2113\u2081 _\nS \u236e T = S \u2218 T\n\nskip : PT A A \u2113 \u2113\nskip P = P\n\n------------------------------------------------------------------------\n-- Operations on predicates extend pointwise to predicate transformers\n\n-- The bottom and the top of the predicate transformer lattice.\n\nabort : PT A B 0\u2113 0\u2113\nabort = \u03bb _ \u2192 \u2205\n\nmagic : PT A B 0\u2113 0\u2113\nmagic = \u03bb _ \u2192 U\n\n-- Negation.\n\ninfix 8 \u223c_\n\n\u223c_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082\n\u223c T = \u2201 \u2218 T\n\n-- Refinement.\n\ninfix 4 _\u2291_ _\u2292_ _\u2291\u2032_ _\u2292\u2032_\n\n_\u2291_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 Set _\nS \u2291 T = \u2200 {X} \u2192 S X \u2286 T X\n\n_\u2291\u2032_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 Set _\nS \u2291\u2032 T = \u2200 X \u2192 S X \u2286 T X\n\n_\u2292_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 Set _\nT \u2292 S = T \u2291 S\n\n_\u2292\u2032_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 Set _\nT \u2292\u2032 S = S \u2291\u2032 T\n\n-- The dual of refinement.\n\ninfix 4 _\u22e2_\n\n_\u22e2_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 Set _\nS \u22e2 T = \u2203 \u03bb X \u2192 S X \u226c T X\n\n-- Union.\n\ninfixl 6 _\u2293_\n\n_\u2293_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082\nS \u2293 T = \u03bb X \u2192 S X \u222a T X\n\n-- Intersection.\n\ninfixl 7 _\u2294_\n\n_\u2294_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082\nS \u2294 T = \u03bb X \u2192 S X \u2229 T X\n\n-- Implication.\n\ninfixl 8 _\u21db_\n\n_\u21db_ : PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082 \u2192 PT A B \u2113\u2081 \u2113\u2082\nS \u21db T = \u03bb X \u2192 S X \u21d2 T X\n\n-- Infinitary union and intersection.\n\ninfix 9 \u2a06 \u2a05\n\n\u2a06 : \u2200 (I : Set i) \u2192 (I \u2192 PT A B \u2113\u2081 \u2113\u2082) \u2192 PT A B \u2113\u2081 _\n\u2a06 I T = \u03bb X \u2192 \u22c3[ i \u2236 I ] T i X\n\nsyntax \u2a06 I (\u03bb i \u2192 T) = \u2a06[ i \u2236 I ] T\n\n\u2a05 : \u2200 (I : Set i) \u2192 (I \u2192 PT A B \u2113\u2081 \u2113\u2082) \u2192 PT A B \u2113\u2081 _\n\u2a05 I T = \u03bb X \u2192 \u22c2[ i \u2236 I ] T i X\n\nsyntax \u2a05 I (\u03bb i \u2192 T) = \u2a05[ i \u2236 I ] T\n\n-- Angelic and demonic update.\n\n\u27e8_\u27e9 : REL A B \u2113 \u2192 PT B A \u2113 _\n\u27e8 R \u27e9 P = \u03bb x \u2192 R x \u226c P\n\n[_] : REL A B \u2113 \u2192 PT B A \u2113 _\n[ R ] P = \u03bb x \u2192 R x \u2286 P\n</pre>"},{"location":"md/Relation/Unary/Properties/","title":"Relation.Unary.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of constructions over unary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Unary.Properties where\n\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; swap; proj\u2081; zip\u2032)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nopen import Data.Unit.Base using (tt)\nopen import Function.Base using (id; _$_; _\u2218_; _\u2218\u2082_)\nopen import Level using (Level)\nopen import Relation.Binary.Core as Binary\nopen import Relation.Binary.Definitions\n  hiding (Decidable; Universal; Irrelevant; Empty)\nopen import Relation.Binary.PropositionalEquality.Core using (refl; _\u2257_)\nopen import Relation.Nullary.Decidable as Dec\n  using (yes; no; _\u228e-dec_; _\u00d7-dec_; \u00ac?; map\u2032; does)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Unary\n\nprivate\n  variable\n    a b \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- The empty set\n\n\u2205? : Decidable {A = A} \u2205\n\u2205? _ = no \u03bb()\n\n\u2205-Empty : Empty {A = A} \u2205\n\u2205-Empty x ()\n\n\u2201\u2205-Universal : Universal {A = A} (\u2201 \u2205)\n\u2201\u2205-Universal = \u03bb x x\u2208\u2205 \u2192 x\u2208\u2205\n\n------------------------------------------------------------------------\n-- The universe\n\nU? : Decidable {A = A} U\nU? _ = yes tt\n\nU-Universal : Universal {A = A} U\nU-Universal = \u03bb _ \u2192 _\n\n\u2201U-Empty : Empty {A = A} (\u2201 U)\n\u2201U-Empty = \u03bb x x\u2208\u2201U \u2192 x\u2208\u2201U _\n\n------------------------------------------------------------------------\n-- Subset properties\n\n\u2205-\u2286 : (P : Pred A \u2113) \u2192 \u2205 \u2286 P\n\u2205-\u2286 P ()\n\n\u2286-U : (P : Pred A \u2113) \u2192 P \u2286 U\n\u2286-U P _ = _\n\n\u2286-refl : Reflexive {A = Pred A \u2113} _\u2286_\n\u2286-refl x\u2208P = x\u2208P\n\n\u2286-reflexive : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2286_\n\u2286-reflexive (P\u2286Q , Q\u2286P) = P\u2286Q\n\n\u2286-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286_ _\u2286_ _\u2286_\n\u2286-trans P\u2286Q Q\u2286R x\u2208P = Q\u2286R (P\u2286Q x\u2208P)\n\n\u2286-antisym : Antisymmetric {A = Pred A \u2113} _\u2250_ _\u2286_\n\u2286-antisym = _,_\n\n\u2286-min : Min {B = Pred A \u2113} _\u2286_ \u2205\n\u2286-min = \u2205-\u2286\n\n\u2286-max : Max {A = Pred A \u2113} _\u2286_ U\n\u2286-max = \u2286-U\n\n\u2282\u21d2\u2286 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2286_\n\u2282\u21d2\u2286 = proj\u2081\n\n\u2282-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282_ _\u2282_ _\u2282_\n\u2282-trans (P\u2286Q , Q\u2288P) (Q\u2286R , R\u2288Q) = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 R\u2288Q (\u03bb x\u2208R \u2192 P\u2286Q (R\u2286P x\u2208R)))\n\n\u2282-\u2286-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282_ _\u2286_ _\u2282_\n\u2282-\u2286-trans (P\u2286Q , Q\u2288P) Q\u2286R = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 Q\u2288P (\u03bb x\u2208Q \u2192 R\u2286P (Q\u2286R x\u2208Q)))\n\n\u2286-\u2282-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286_ _\u2282_ _\u2282_\n\u2286-\u2282-trans P\u2286Q (Q\u2286R , R\u2288Q) = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 R\u2288Q (\u03bb R\u2286Q \u2192 P\u2286Q (R\u2286P R\u2286Q)))\n\n\u2282-resp\u02b3-\u2250 : _Respects\u02b3_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2250_\n\u2282-resp\u02b3-\u2250 (Q\u2286R , _) P\u2282Q = \u2282-\u2286-trans P\u2282Q Q\u2286R\n\n\u2282-resp\u02e1-\u2250 : _Respects\u02e1_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2250_\n\u2282-resp\u02e1-\u2250 (_ , R\u2286Q) P\u2282Q = \u2286-\u2282-trans R\u2286Q P\u2282Q\n\n\u2282-resp-\u2250 : _Respects\u2082_ {A = Pred A \u2113} _\u2282_ _\u2250_\n\u2282-resp-\u2250 = \u2282-resp\u02b3-\u2250 , \u2282-resp\u02e1-\u2250\n\n\u2282-irrefl : Irreflexive {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2282_\n\u2282-irrefl (_ , Q\u2286P) (_ , Q\u2288P) = Q\u2288P Q\u2286P\n\n\u2282-antisym : Antisymmetric {A = Pred A \u2113} _\u2250_ _\u2282_\n\u2282-antisym (P\u2286Q , _) (Q\u2286P , _) = \u2286-antisym P\u2286Q Q\u2286P\n\n\u2282-asym : Asymmetric {A = Pred A \u2113} _\u2282_\n\u2282-asym (_ , Q\u2288P) = Q\u2288P \u2218 proj\u2081\n\n\u2205-\u2286\u2032 : (P : Pred A \u2113) \u2192 \u2205 \u2286\u2032 P\n\u2205-\u2286\u2032 _ _ = \u03bb ()\n\n\u2286\u2032-U : (P : Pred A \u2113) \u2192 P \u2286\u2032 U\n\u2286\u2032-U _ _ _ = _\n\n\u2286\u2032-refl : Reflexive {A = Pred A \u2113} _\u2286\u2032_\n\u2286\u2032-refl x x\u2208P = x\u2208P\n\n\u2286\u2032-reflexive : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2286\u2032_\n\u2286\u2032-reflexive (P\u2286Q , Q\u2286P) = P\u2286Q\n\n\u2286\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286\u2032_ _\u2286\u2032_ _\u2286\u2032_\n\u2286\u2032-trans P\u2286Q Q\u2286R x x\u2208P = Q\u2286R x (P\u2286Q x x\u2208P)\n\n\u2286\u2032-antisym : Antisymmetric {A = Pred A \u2113} _\u2250\u2032_ _\u2286\u2032_\n\u2286\u2032-antisym = _,_\n\n\u2286\u2032-min : Min {B = Pred A \u2113} _\u2286\u2032_ \u2205\n\u2286\u2032-min = \u2205-\u2286\u2032\n\n\u2286\u2032-max : Max {A = Pred A \u2113} _\u2286\u2032_ U\n\u2286\u2032-max = \u2286\u2032-U\n\n\u2282\u2032\u21d2\u2286\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2286\u2032_\n\u2282\u2032\u21d2\u2286\u2032 = proj\u2081\n\n\u2282\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282\u2032_ _\u2282\u2032_ _\u2282\u2032_\n\u2282\u2032-trans (P\u2286Q , Q\u2288P) (Q\u2286R , R\u2288Q) = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 R\u2288Q (\u2286\u2032-trans R\u2286P P\u2286Q)\n\n\u2282\u2032-\u2286\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282\u2032_ _\u2286\u2032_ _\u2282\u2032_\n\u2282\u2032-\u2286\u2032-trans (P\u2286Q , Q\u2288P) Q\u2286R = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 Q\u2288P (\u2286\u2032-trans Q\u2286R R\u2286P)\n\n\u2286\u2032-\u2282\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286\u2032_ _\u2282\u2032_ _\u2282\u2032_\n\u2286\u2032-\u2282\u2032-trans P\u2286Q (Q\u2286R , R\u2288Q) = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 R\u2288Q (\u2286\u2032-trans R\u2286P P\u2286Q)\n\n\u2282\u2032-resp\u02b3-\u2250\u2032 : _Respects\u02b3_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp\u02b3-\u2250\u2032 (Q\u2286R , _) P\u2282Q = \u2282\u2032-\u2286\u2032-trans P\u2282Q Q\u2286R\n\n\u2282\u2032-resp\u02e1-\u2250\u2032 : _Respects\u02e1_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp\u02e1-\u2250\u2032 (_ , R\u2286Q) P\u2282Q = \u2286\u2032-\u2282\u2032-trans R\u2286Q P\u2282Q\n\n\u2282\u2032-resp-\u2250\u2032 : _Respects\u2082_ {A = Pred A \u2113\u2081} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp-\u2250\u2032 = \u2282\u2032-resp\u02b3-\u2250\u2032 , \u2282\u2032-resp\u02e1-\u2250\u2032\n\n\u2282\u2032-irrefl : Irreflexive {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2282\u2032_\n\u2282\u2032-irrefl (_ , Q\u2286P) (_ , Q\u2288P) = Q\u2288P Q\u2286P\n\n\u2282\u2032-antisym : Antisymmetric {A = Pred A \u2113} _\u2250\u2032_ _\u2282\u2032_\n\u2282\u2032-antisym (P\u2286Q , _) (Q\u2286P , _) = \u2286\u2032-antisym P\u2286Q Q\u2286P\n\n\u2286\u21d2\u2286\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2286_ _\u2286\u2032_\n\u2286\u21d2\u2286\u2032 P\u2286Q _ x\u2208P = P\u2286Q x\u2208P\n\n\u2286\u2032\u21d2\u2286 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2286\u2032_ _\u2286_\n\u2286\u2032\u21d2\u2286 P\u2286Q x\u2208P = P\u2286Q _ x\u2208P\n\n\u2282\u21d2\u2282\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2282\u2032_\n\u2282\u21d2\u2282\u2032 = Product.map \u2286\u21d2\u2286\u2032 (_\u2218 \u2286\u2032\u21d2\u2286)\n\n\u2282\u2032\u21d2\u2282 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2282_\n\u2282\u2032\u21d2\u2282 = Product.map \u2286\u2032\u21d2\u2286 (_\u2218 \u2286\u21d2\u2286\u2032)\n\n------------------------------------------------------------------------\n-- Equality properties\n\n\u2250-refl : Reflexive {A = Pred A \u2113} _\u2250_\n\u2250-refl = id , id\n\n\u2250-sym : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2250_\n\u2250-sym = swap\n\n\u2250-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2250_ _\u2250_ _\u2250_\n\u2250-trans = zip\u2032 (\u03bb P\u2286Q Q\u2286R x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) (\u03bb Q\u2286P R\u2286Q x\u2208R \u2192 Q\u2286P (R\u2286Q x\u2208R))\n\n\u2250\u2032-refl : Reflexive {A = Pred A \u2113} _\u2250\u2032_\n\u2250\u2032-refl = (\u03bb _ \u2192 id) , (\u03bb _ \u2192 id)\n\n\u2250\u2032-sym : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2250\u2032_\n\u2250\u2032-sym = swap\n\n\u2250\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2250\u2032_ _\u2250\u2032_ _\u2250\u2032_\n\u2250\u2032-trans = zip\u2032 (\u03bb P\u2286Q Q\u2286R x x\u2208P \u2192 Q\u2286R x (P\u2286Q x x\u2208P)) \u03bb Q\u2286P R\u2286Q x x\u2208R \u2192 Q\u2286P x (R\u2286Q x x\u2208R)\n\n\u2250\u21d2\u2250\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2250\u2032_\n\u2250\u21d2\u2250\u2032 = Product.map \u2286\u21d2\u2286\u2032 \u2286\u21d2\u2286\u2032\n\n\u2250\u2032\u21d2\u2250 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2250_\n\u2250\u2032\u21d2\u2250 = Product.map \u2286\u2032\u21d2\u2286 \u2286\u2032\u21d2\u2286\n\n------------------------------------------------------------------------\n-- Between/Disjoint properties\n\n\u226c-symmetric : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u226c_ _\u226c_\n\u226c-symmetric = Product.map\u2082 swap\n\n\u22a5-symmetric : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u22a5_ _\u22a5_\n\u22a5-symmetric = _\u2218 swap\n\n\u226c-sym : Symmetric {A = Pred A \u2113\u2081} _\u226c_\n\u226c-sym = \u226c-symmetric\n\n\u22a5-sym : Symmetric {A = Pred A \u2113\u2081} _\u22a5_\n\u22a5-sym = \u22a5-symmetric\n\n\u226c\u21d2\u00ac\u22a5 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u226c_ (\u00ac_ \u2218\u2082 _\u22a5_)\n\u226c\u21d2\u00ac\u22a5 P\u226cQ \u00acP\u22a5Q = \u00acP\u22a5Q (Product.proj\u2082 P\u226cQ)\n\n\u22a5\u21d2\u00ac\u226c : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u22a5_ (\u00ac_ \u2218\u2082 _\u226c_)\n\u22a5\u21d2\u00ac\u226c P\u22a5Q = P\u22a5Q \u2218 Product.proj\u2082\n\n------------------------------------------------------------------------\n-- Decidability properties\n\nmap : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n      P \u2250 Q \u2192 Decidable P \u2192 Decidable Q\nmap (P\u2286Q , Q\u2286P) P? x = map\u2032 P\u2286Q Q\u2286P (P? x)\n\n\u2201? : {P : Pred A \u2113} \u2192 Decidable P \u2192 Decidable (\u2201 P)\n\u2201? P? x = \u00ac? (P? x)\n\ninfix 2 _\u00d7?_ _\u2299?_\ninfix 10 _~?\ninfixr 1 _\u228e?_\ninfixr 7 _\u2229?_\ninfixr 6 _\u222a?_\n\n_\u222a?_ : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u222a Q)\n_\u222a?_ P? Q? x = (P? x) \u228e-dec (Q? x)\n\n_\u2229?_ : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u2229 Q)\n_\u2229?_ P? Q? x = (P? x) \u00d7-dec (Q? x)\n\n_\u00d7?_ : {P : Pred A \u2113\u2081} {Q : Pred B \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u00d7\u27e9 Q)\n_\u00d7?_ P? Q? (a , b) = (P? a) \u00d7-dec (Q? b)\n\n_\u2299?_ : {P : Pred A \u2113\u2081} {Q : Pred B \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u2299\u27e9 Q)\n_\u2299?_ P? Q? (a , b) = (P? a) \u228e-dec (Q? b)\n\n_\u228e?_ : {P : Pred A \u2113} {Q : Pred B \u2113} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u228e\u27e9 Q)\n_\u228e?_ P? Q? (inj\u2081 a) = P? a\n_\u228e?_ P? Q? (inj\u2082 b) = Q? b\n\n_~? : {P : Pred (A \u00d7 B) \u2113} \u2192 Decidable P \u2192 Decidable (P ~)\n_~? P? = P? \u2218 swap\n\ndoes-\u2261 : {P : Pred A \u2113} \u2192 (P? P?\u2032 : Decidable P) \u2192\n         does \u2218 P? \u2257 does \u2218 P?\u2032\ndoes-\u2261 P? P?\u2032 x = Dec.does-\u2261 (P? x) (P?\u2032 x)\n\ndoes-\u2250 : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192 P \u2250 Q \u2192\n         (P? : Decidable P) \u2192 (Q? : Decidable Q) \u2192\n         does \u2218 P? \u2257 does \u2218 Q?\ndoes-\u2250 P\u2250Q P? = does-\u2261 (map P\u2250Q P?)\n\n------------------------------------------------------------------------\n-- Irrelevant properties\n\nU-irrelevant : Irrelevant {A = A} U\nU-irrelevant a b = refl\n\n\u2201-irrelevant : (P : Pred A \u2113) \u2192 Irrelevant (\u2201 P)\n\u2201-irrelevant P a b = refl\n</pre>"},{"location":"md/Scm/Abstract-Syntax/","title":"Scm.Abstract-Syntax","text":"<pre>\nmodule Scm.Abstract-Syntax where\n\nopen import Data.Integer.Base  renaming (\u2124 to Int) public\nopen import Data.String.Base   using (String) public\n\ndata       Con    : Set     -- constants, *excluding* quotations\nvariable   K      : Con\nIde               = String  -- identifiers (variables)\nvariable   I      : Ide\ndata       Exp    : Set     -- expressions\nvariable   E      : Exp\ndata       Exp\u22c6   : Set     -- expression sequences\nvariable   E\u22c6     : Exp\u22c6\n\ndata       Body   : Set     -- body expression or definition\nvariable   B      : Body\ndata       Body\u207a  : Set     -- body sequences\nvariable   B\u207a     : Body\u207a\ndata       Prog   : Set     -- programs\nvariable   \u03a0      : Prog\n\n------------------------------------------------------------------------\n-- Literal constants\n\ndata Con where                -- basic constants\n  int  : Int \u2192 Con            -- integer numerals\n  #t   : Con                  -- true\n  #f   : Con                  -- false\n\n------------------------------------------------------------------------\n-- Expressions\n\ndata Exp where                          -- expressions\n  con          : Con \u2192 Exp              -- K\n  ide          : Ide \u2192 Exp              -- I\n  \u2985_\u2423_\u2986        : Exp \u2192 Exp\u22c6 \u2192 Exp       -- (E E\u22c6)\n  \u2985lambda_\u2423_\u2986  : Ide \u2192 Exp \u2192 Exp        -- (lambda I E)\n  \u2985if_\u2423_\u2423_\u2986    : Exp \u2192 Exp \u2192 Exp \u2192 Exp  -- (if E E\u2081 E\u2082)\n  \u2985set!_\u2423_\u2986    : Ide \u2192 Exp \u2192 Exp        -- (set! I E)\n\ndata Exp\u22c6 where                         -- expression sequences\n  \u2423\u2423\u2423          : Exp\u22c6                   -- empty sequence\n  _\u2423\u2423_         : Exp \u2192 Exp\u22c6 \u2192 Exp\u22c6      -- prefix sequence E E\u22c6\n</pre> <p>\\iflatex\\fi</p> <pre>\n------------------------------------------------------------------------\n-- Definitions and Programs\n\ndata Body where\n  \u2423\u2423_          : Exp \u2192 Body             -- side-effect expression E\n  \u2985define_\u2423_\u2986  : Ide \u2192 Exp \u2192 Body       -- definition (define I E)\n  \u2985begin_\u2986     : Body\u207a \u2192 Body           -- block (begin B\u207a)\n\ndata Body\u207a where                        -- body sequence\n  \u2423\u2423_          : Body \u2192 Body\u207a           -- single body sequence B\n  _\u2423\u2423_         : Body \u2192 Body\u207a \u2192 Body\u207a   -- prefix body sequence B B\u207a\n\ndata Prog where                         -- programs\n  \u2423\u2423\u2423          : Prog                   -- empty program\n  \u2423\u2423_          : Body\u207a \u2192 Prog           -- non-empty program B\u207a\n\ninfix 30 \u2423\u2423_\ninfixr 20 _\u2423\u2423_\n</pre>"},{"location":"md/Scm/Auxiliary-Functions/","title":"Scm.Auxiliary-Functions","text":"<pre>\nmodule Scm.Auxiliary-Functions where\n\nopen import Scm.Notation\nopen import Scm.Abstract-Syntax\nopen import Scm.Domain-Equations\n\n-- Environments \u03c1 : \ud835\udc14 = Ide \u2192 \ud835\udc0b\n\npostulate _==_ : Ide \u2192 Ide \u2192 Bool\n\n_[_/_] : \ud835\udc14 \u2192 \ud835\udc0b \u2192 Ide \u2192 \ud835\udc14\n\u03c1 [ \u03b1 / I ] = \u03bb I\u2032 \u2192 \u03b7 (I == I\u2032) \u27f6 \u03b1 , \u03c1 I\u2032\n\npostulate unknown : \ud835\udc0b\n-- \u03c1 I = unknown represents the lack of a binding for I in \u03c1\n\npostulate initial-env : \ud835\udc14\n-- initial-env shoud include various procedures and values\n\n-- Stores \u03c3 : \ud835\udc12 = \ud835\udc0b \u2192 \ud835\udc04\n\n_[_/_]\u2032 : \ud835\udc12 \u2192 \ud835\udc04 \u2192 \ud835\udc0b \u2192 \ud835\udc12\n\u03c3 [ \u03f5 / \u03b1 ]\u2032 = \u03bb \u03b1\u2032 \u2192 (\u03b1 ==\u1d38 \u03b1\u2032) \u27f6 \u03f5 , \u03c3 \u03b1\u2032\n\nassign : \ud835\udc0b \u2192 \ud835\udc04 \u2192 \ud835\udc02 \u2192 \ud835\udc02\nassign = \u03bb \u03b1 \u03f5 \u03b8 \u03c3 \u2192 \u03b8 (\u03c3 [ \u03f5 / \u03b1 ]\u2032)\n\nhold : \ud835\udc0b \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\nhold = \u03bb \u03b1 \u03ba \u03c3 \u2192 \u03ba (\u03c3 \u03b1) \u03c3\n\npostulate new : (\ud835\udc0b \u2192 \ud835\udc02) \u2192 \ud835\udc02\n-- new \u03ba \u03c3 = \u03ba \u03b1 \u03c3\u2032 where \u03c3 \u03b1 = unallocated, \u03c3\u2032 \u03b1 \u2260 unallocated\n\nalloc : \ud835\udc04 \u2192 (\ud835\udc0b \u2192 \ud835\udc02) \u2192 \ud835\udc02\nalloc = \u03bb \u03f5 \u03ba \u2192 new (\u03bb \u03b1 \u2192 assign \u03b1 \u03f5 (\u03ba \u03b1))\n-- should be \u22a5 when \u03f5 |-\ud835\udc0c == unallocated\n\ninitial-store : \ud835\udc12\ninitial-store = \u03bb \u03b1 \u2192 \u03b7 unallocated \ud835\udc0c-in-\ud835\udc04\n\npostulate finished : \ud835\udc02\n-- normal termination with answer depending on final store\n\ntruish : \ud835\udc04 \u2192 \ud835\udc13\ntruish =\n  \u03bb \u03f5 \u2192 (\u03f5 \u2208-\ud835\udc13) \u27f6\n      (((\u03f5 |-\ud835\udc13) ==\u1d40 \u03b7 false) \u27f6 \u03b7 false , \u03b7 true) ,\n    \u03b7 true\n</pre> <pre>\n-- Lists\n\ncons : \ud835\udc05\ncons =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 alloc (\u03f5\u22c6 \u2193 1) (\u03bb \u03b1\u2081 \u2192\n                        alloc (\u03f5\u22c6 \u2193 2) (\u03bb \u03b1\u2082 \u2192\n                          \u03ba ((\u03b1\u2081 , \u03b1\u2082) \ud835\udc0f-in-\ud835\udc04))) , \n    \u22a5\n\nlist : \ud835\udc05\nlist = fix \u03bb list\u2032 \u2192\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n    (# \u03f5\u22c6 ==\u22a5 0) \u27f6 \u03ba (\u03b7 null \ud835\udc0c-in-\ud835\udc04) ,\n      list\u2032 (\u03f5\u22c6 \u2020 1) (\u03bb \u03f5 \u2192 cons \u27e8 (\u03f5\u22c6 \u2193 1) , \u03f5 \u27e9 \u03ba)\n\ncar : \ud835\udc05\ncar =\n  \u03bb \u03f5\u22c6 \u03ba \u2192 (# \u03f5\u22c6 ==\u22a5 1) \u27f6 hold ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u2193\u00b21) \u03ba , \u22a5\n\ncdr : \ud835\udc05\ncdr =\n  \u03bb \u03f5\u22c6 \u03ba \u2192 (# \u03f5\u22c6 ==\u22a5 1) \u27f6 hold ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u2193\u00b22) \u03ba , \u22a5\n\nsetcar : \ud835\udc05\nsetcar =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 assign  ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u2193\u00b21)\n                             (\u03f5\u22c6 \u2193 2)\n                             (\u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)) , \n    \u22a5\n\nsetcdr : \ud835\udc05\nsetcdr =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 assign  ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u2193\u00b22)\n                             (\u03f5\u22c6 \u2193 2)\n                             (\u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)) , \n    \u22a5\n</pre>"},{"location":"md/Scm/Domain-Equations/","title":"Scm.Domain-Equations","text":"<pre>\nmodule Scm.Domain-Equations where\n\nopen import Scm.Notation\nopen import Scm.Abstract-Syntax using (Ide; Int)\n\n-- Domain declarations\n\npostulate  \ud835\udc0b   :  Domain  -- locations\nvariable   \u03b1   :  \ud835\udc0b\n\ud835\udc0d              :  Domain  -- natural numbers\n\ud835\udc13              :  Domain  -- booleans\n\ud835\udc11              :  Domain  -- numbers\n\ud835\udc0f              :  Domain  -- pairs\n\ud835\udc0c              :  Domain  -- miscellaneous\nvariable   \u03bc   :  \ud835\udc0c\n\ud835\udc05              :  Domain  -- procedure values\nvariable   \u03c6   :  \ud835\udc05\npostulate  \ud835\udc04   :  Domain  -- expressed values\nvariable   \u03f5   :  \ud835\udc04\n\ud835\udc12              :  Domain  -- stores\nvariable   \u03c3   :  \ud835\udc12\n\ud835\udc14              :  Domain  -- environments\nvariable   \u03c1   :  \ud835\udc14\n\ud835\udc02              :  Domain  -- command continuations\nvariable   \u03b8   :  \ud835\udc02\npostulate  \ud835\udc00   :  Domain  -- answers\n\n\ud835\udc04\u22c6             =  \ud835\udc04 \u22c6\nvariable   \u03f5\u22c6  :  \ud835\udc04\u22c6\n\n-- Domain equations\n\ndata Misc : Set where null unallocated undefined unspecified : Misc\n\n\ud835\udc0d     =  Nat\u22a5\n\ud835\udc13     =  Bool\u22a5\n\ud835\udc11     =  Int +\u22a5\n\ud835\udc0f     =  \ud835\udc0b \u00d7 \ud835\udc0b\n\ud835\udc0c     =  Misc +\u22a5\n\ud835\udc05     =  \ud835\udc04\u22c6 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n-- \ud835\udc04  =  \ud835\udc13 + \ud835\udc11 + \ud835\udc0f + \ud835\udc0c + \ud835\udc05\n\ud835\udc12     =  \ud835\udc0b \u2192 \ud835\udc04\n\ud835\udc14     =  Ide \u2192 \ud835\udc0b\n\ud835\udc02     =  \ud835\udc12 \u2192 \ud835\udc00\n</pre> <p>\\iflatex\\fi</p> <pre>\n-- Injections, tests, and projections\n\npostulate\n  _\ud835\udc13-in-\ud835\udc04    : \ud835\udc13   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc13       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc13       : \ud835\udc04   \u2192 \ud835\udc13\n\n  _\ud835\udc11-in-\ud835\udc04    : \ud835\udc11   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc11       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc11       : \ud835\udc04   \u2192 \ud835\udc11\n\n  _\ud835\udc0f-in-\ud835\udc04    : \ud835\udc0f  \u2192 \ud835\udc04\n  _\u2208-\ud835\udc0f       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc0f       : \ud835\udc04   \u2192 \ud835\udc0f\n\n  _\ud835\udc0c-in-\ud835\udc04    : \ud835\udc0c   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc0c       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc0c       : \ud835\udc04   \u2192 \ud835\udc0c\n\n  _\ud835\udc05-in-\ud835\udc04    : \ud835\udc05   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc05       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc05       : \ud835\udc04   \u2192 \ud835\udc05\n\n-- Operations on flat domains\n\npostulate\n  _==\u1d38_  : \ud835\udc0b \u2192 \ud835\udc0b \u2192 \ud835\udc13\n  _==\u1d39_  : \ud835\udc0c \u2192 \ud835\udc0c \u2192 \ud835\udc13\n  _==\u1d3f_  : \ud835\udc11 \u2192 \ud835\udc11 \u2192 \ud835\udc13\n  _==\u1d40_  : \ud835\udc13 \u2192 \ud835\udc13 \u2192 \ud835\udc13\n  _&lt;\u1d3f_   : \ud835\udc11 \u2192 \ud835\udc11 \u2192 \ud835\udc13\n  _+\u1d3f_   : \ud835\udc11 \u2192 \ud835\udc11 \u2192 \ud835\udc11\n  _\u2227\u1d40_   : \ud835\udc13 \u2192 \ud835\udc13 \u2192 \ud835\udc13\n</pre>"},{"location":"md/Scm/Notation/","title":"Scm.Notation","text":"<pre>\nmodule Scm.Notation where\n\nopen import Data.Bool.Base    using (Bool; false; true) public\nopen import Data.Nat.Base     renaming (\u2115 to Nat) using (suc) public\nopen import Data.String.Base  using (String) public\nopen import Data.Unit.Base    using (\u22a4)\nopen import Function          using (id; _\u2218_) public\n\nDomain = Set -- unsound!\n\nvariable\n  A B C  : Set\n  D E F  : Domain\n  n      : Nat\n\n------------------------------------------------------------------------\n-- Domains\n\npostulate\n  \u22a5 : D              -- bottom element\n  fix : (D \u2192 D) \u2192 D  -- fixed point of endofunction\n\n------------------------------------------------------------------------\n-- Flat domains\n\npostulate\n  _+\u22a5    : Set \u2192 Domain          -- lifted set\n  \u03b7      : A \u2192 A +\u22a5              -- inclusion\n  _\u266f     : (A \u2192 D) \u2192 (A +\u22a5 \u2192 D)  -- Kleisli extension\n\nBool\u22a5    = Bool +\u22a5               -- truth value domain\nNat\u22a5     = Nat +\u22a5                -- natural number domain\nString\u22a5  = String +\u22a5             -- meta-string domain\n\npostulate\n  _==\u22a5_  : Nat\u22a5 \u2192 Nat \u2192 Bool\u22a5    -- strict numerical equality\n  _&gt;=\u22a5_  : Nat\u22a5 \u2192 Nat \u2192 Bool\u22a5    -- strict greater or equal\n  _\u27f6_,_  : Bool\u22a5 \u2192 D \u2192 D \u2192 D     -- McCarthy conditional\n\n------------------------------------------------------------------------\n-- Sum domains\n\npostulate\n  _+_    : Domain \u2192 Domain \u2192 Domain         -- separated sum\n  inj\u2081   : D \u2192 D + E                        -- injection\n  inj\u2082   : E \u2192 D + E                        -- injection\n  [_,_]  : (D \u2192 F) \u2192 (E \u2192 F) \u2192 (D + E \u2192 F)  -- case analysis\n</pre> <pre>\n------------------------------------------------------------------------\n-- Product domains\n\npostulate\n  _\u00d7_  : Domain \u2192 Domain \u2192 Domain  -- cartesian product\n  _,_  : D \u2192 E \u2192 D \u00d7 E             -- pairing\n  _\u2193\u00b21  : D \u00d7 E \u2192 D                -- 1st projection\n  _\u2193\u00b22  : D \u00d7 E \u2192 E                -- 2nd projection\n  _\u2193\u00b31   : D \u00d7 E \u00d7 F \u2192 D           -- 1st projection\n  _\u2193\u00b32   : D \u00d7 E \u00d7 F \u2192 E           -- 2nd projection\n  _\u2193\u00b33   : D \u00d7 E \u00d7 F \u2192 F           -- 3rd projection\n------------------------------------------------------------------------\n-- Tuple domains\n\n_^_ : Domain \u2192 Nat \u2192 Domain   -- D ^ n               n-tuples\nD ^ 0            = \u22a4\nD ^ 1            = D\nD ^ suc (suc n)  = D \u00d7 (D ^ suc n)\n\n------------------------------------------------------------------------\n-- Finite sequence domains\n\npostulate\n  _\u22c6     : Domain \u2192 Domain    -- D \u22c6 domain of finite sequences \n  \u27e8\u27e9     : D \u22c6                -- empty sequence\n  \u27e8_\u27e9    : (D ^ suc n) \u2192 D \u22c6  -- \u27e8 d\u2081 , ... , d\u2099\u208a\u2081 \u27e9 non-empty sequence\n  #      : D \u22c6 \u2192 Nat\u22a5         -- # d\u22c6                sequence length\n  _\u00a7_    : D \u22c6 \u2192 D \u22c6 \u2192 D \u22c6    -- d\u22c6 \u00a7 d\u22c6             concatenation\n  _\u2193_    : D \u22c6 \u2192 Nat \u2192 D      -- d\u22c6 \u2193 n              nth component\n  _\u2020_    : D \u22c6 \u2192 Nat \u2192 D \u22c6    -- d\u22c6 \u2020 n              nth tail\n\n------------------------------------------------------------------------\n-- Grouping precedence\n\ninfixr 1   _+_\ninfixr 2   _\u00d7_\ninfixr 4   _,_\ninfix  8   _^_\ninfixr 20  _\u27f6_,_\n\n\u27e6_\u27e7 = id\n</pre>"},{"location":"md/Scm/Semantic-Functions/","title":"Scm.Semantic-Functions","text":"<pre>\nmodule Scm.Semantic-Functions where\n\nopen import Scm.Notation\nopen import Scm.Abstract-Syntax\nopen import Scm.Domain-Equations\nopen import Scm.Auxiliary-Functions\n\n\ud835\udca6\u27e6_\u27e7    : Con \u2192 \ud835\udc04\n\u2130\u27e6_\u27e7    : Exp \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u2130\u22c6\u27e6_\u27e7  : Exp\u22c6 \u2192 \ud835\udc14 \u2192 (\ud835\udc04\u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u27e6_\u27e7    : Body \u2192 \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u212c\u207a\u27e6_\u27e7   : Body\u207a \u2192 \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\ud835\udcab\u27e6_\u27e7    : Prog \u2192 \ud835\udc00\n\n-- Constant denotations \ud835\udca6\u27e6 K \u27e7 : \ud835\udc04\n\n\ud835\udca6\u27e6 int Z \u27e7  = \u03b7 Z \ud835\udc11-in-\ud835\udc04\n\ud835\udca6\u27e6 #t \u27e7     = \u03b7 true \ud835\udc13-in-\ud835\udc04\n\ud835\udca6\u27e6 #f \u27e7     = \u03b7 false \ud835\udc13-in-\ud835\udc04\n\n-- Expression denotations\n\n\u2130\u27e6 con K \u27e7 \u03c1 \u03ba = \u03ba (\ud835\udca6\u27e6 K \u27e7)\n\n\u2130\u27e6 ide I \u27e7 \u03c1 \u03ba = hold (\u03c1 I) \u03ba\n\n\u2130\u27e6 \u2985 E \u2423 E\u22c6 \u2986 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    \u2130\u22c6\u27e6 E\u22c6 \u27e7 \u03c1 (\u03bb \u03f5\u22c6 \u2192\n      (\u03f5 |-\ud835\udc05) \u03f5\u22c6 \u03ba))\n\n\u2130\u27e6 \u2985lambda I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u03ba (  (\u03bb \u03f5\u22c6 \u03ba\u2032 \u2192\n          list \u03f5\u22c6 (\u03bb \u03f5 \u2192 \n            alloc \u03f5 (\u03bb \u03b1 \u2192\n              \u2130\u27e6 E \u27e7 (\u03c1 [ \u03b1 / I ]) \u03ba\u2032))\n       ) \ud835\udc05-in-\ud835\udc04)\n\n\u2130\u27e6 \u2985if E \u2423 E\u2081 \u2423 E\u2082 \u2986 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    truish \u03f5 \u27f6 \u2130\u27e6 E\u2081 \u27e7 \u03c1 \u03ba , \u2130\u27e6 E\u2082 \u27e7 \u03c1 \u03ba)\n\n\u2130\u27e6 \u2985set! I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    assign (\u03c1 I) \u03f5 (\n      \u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)))\n\n-- \u2130\u22c6\u27e6_\u27e7  : Exp\u22c6 \u2192 \ud835\udc14 \u2192 (\ud835\udc04\u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2130\u22c6\u27e6 \u2423\u2423\u2423 \u27e7 \u03c1 \u03ba = \u03ba \u27e8\u27e9\n\n\u2130\u22c6\u27e6 E \u2423\u2423 E\u22c6 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    \u2130\u22c6\u27e6 E\u22c6 \u27e7 \u03c1 (\u03bb \u03f5\u22c6 \u2192\n      \u03ba (\u27e8 \u03f5 \u27e9 \u00a7 \u03f5\u22c6)))\n</pre> <p>\\iflatex\\fi</p> <pre>\n-- Body denotations \u212c\u27e6 B \u27e7 : \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u27e6 \u2423\u2423 E \u27e7 \u03c1 \u03ba = \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192 \u03ba \u03c1)\n\n\u212c\u27e6 \u2985define I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192 (\u03c1 I ==\u1d38 unknown) \u27f6 \n                      alloc \u03f5 (\u03bb \u03b1 \u2192 \u03ba (\u03c1 [ \u03b1 / I ])),\n                    assign (\u03c1 I) \u03f5 (\u03ba \u03c1))\n\n\u212c\u27e6 \u2985begin B\u207a \u2986 \u27e7 \u03c1 \u03ba = \u212c\u207a\u27e6 B\u207a \u27e7 \u03c1 \u03ba\n\n-- Body sequence denotations \u212c\u207a\u27e6 B\u207a \u27e7 : \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u207a\u27e6 \u2423\u2423 B \u27e7 \u03c1 \u03ba = \u212c\u27e6 B \u27e7 \u03c1 \u03ba\n\n\u212c\u207a\u27e6 B \u2423\u2423 B\u207a \u27e7 \u03c1 \u03ba = \u212c\u27e6 B \u27e7 \u03c1 (\u03bb \u03c1\u2032 \u2192 \u212c\u207a\u27e6 B\u207a \u27e7 \u03c1\u2032 \u03ba)\n\n-- Program denotations \ud835\udcab\u27e6 \u03a0 \u27e7 : \ud835\udc00\n\n\ud835\udcab\u27e6 \u2423\u2423\u2423 \u27e7 = finished initial-store\n\n\ud835\udcab\u27e6 \u2423\u2423 B\u207a \u27e7 = \u212c\u207a\u27e6 B\u207a \u27e7 initial-env (\u03bb \u03c1 \u2192 finished) initial-store\n</pre>"},{"location":"md/Scm/index/","title":"Scm.index","text":"<pre>\nmodule Scm.index where\n\nimport Scm.Notation\nimport Scm.Abstract-Syntax\nimport Scm.Domain-Equations\nimport Scm.Semantic-Functions\nimport Scm.Auxiliary-Functions\n</pre>"}]}